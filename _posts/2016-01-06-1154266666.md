---
layout: post
title: ld.so分析
categories:
- Pocket
tags:
---
原文地址：http://m.blog.csdn.net/article/details?id=9429941

收藏时间：2016-01-06 13:05:32

<div  lang="en">
<p nodeIndex="18"><a href="http://blog.chinaunix.net/uid-725631-id-253186.html" nodeIndex="774"><span nodeIndex="775">http://blog.chinaunix.net/uid-725631-id-253186.html</span></a></p>
<p nodeIndex="19">ld.so分析1</p><p brd="1" nodeIndex="20">1.入口 <br nodeIndex="777">
elf/rtld.c中</p>
<p brd="1" nodeIndex="21">#ifdef RTLD_START <br nodeIndex="778">
RTLD_START <br nodeIndex="779">
#else <br nodeIndex="780">
# error "sysdeps/MACHINE/dl-machine.h fails to define RTLD_START" <br nodeIndex="781">
#endif</p>
<p brd="1" nodeIndex="22">该宏定义在sysdeps/i386/dl-machine.h</p>
<p brd="1" nodeIndex="23">#define RTLD_START asm ("\n\ <br nodeIndex="782">
.text\n\ <br nodeIndex="783">
.align 16\n\ <br nodeIndex="784">
0: movl (%esp), %ebx\n\ <br nodeIndex="785">
ret\n\ <br nodeIndex="786">
.align 16\n\ <br nodeIndex="787">
.globl _start\n\ ld.so入口 <br nodeIndex="788">
.globl _dl_start_user\n\ <br nodeIndex="789">
_start:\n\ <br nodeIndex="790">
# Note that _dl_start gets the parameter in %eax.\n\ <br nodeIndex="791">
movl %esp, %eax\n\ 当值esp值作为参数传递给_dl_start,_dl_start函数原型是static Elf32_Addr __attribute__ ((__used__)) __attribute__ ((regparm (3), stdcall)) _dl_start (void *arg) <br nodeIndex="792">
call _dl_start\n\ //调用_dl_start,完成动态链接,返回用户入口地址,_dl_start自己平栈 <br nodeIndex="793">
_dl_start_user:\n\ <br nodeIndex="794">
# Save the user entry point address in %edi.\n\ <br nodeIndex="795">
movl %eax, %edi\n\ 保存用户程序入口地址 <br nodeIndex="796">
# Point %ebx at the GOT.\n\ <br nodeIndex="797">
call 0b\n\ //等价于 call 1f;1:pop %ebx;addl $_GLOBAL_OFFSET_TABLE_+[.-1b], %ebx;获取GOT地址，存入%ebx <br nodeIndex="798">
addl $_GLOBAL_OFFSET_TABLE_, %ebx\n\//%ebx指向本条指令地址,加上GOT相对于本指令的偏移，即得到GOT地址 <br nodeIndex="799">
# Store the highest stack address\n\ <br nodeIndex="800">
/* <br nodeIndex="801">
00000020 0000950a R_386_GOTPC 00000000 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="802">
00000026 00009603 R_386_GOT32 00000000 __libc_stack_end <br nodeIndex="803">
0000002e 00009709 R_386_GOTOFF 00000004 _dl_skip_args <br nodeIndex="804">
*/ <br nodeIndex="805">
movl __libc_stack_end@GOT(%ebx), %eax\n\ __libc_stack_end是GLOBAL变量,存在于GOT中 <br nodeIndex="806">
movl %esp, (%eax)\n\ 存入esp <br nodeIndex="807">
# See if we were run as a command with the executable file\n\ <br nodeIndex="808">
# name as an extra leading argument.\n\ <br nodeIndex="809">
movl _dl_skip_args@GOTOFF(%ebx), %eax\n\ _dl_skip_args是LOCAL变量,不存在于GOT中 <br nodeIndex="810">
# Pop the original argument count.\n\ <br nodeIndex="811">
popl %edx\n\弹出原始参数个数 <br nodeIndex="812">
# Adjust the stack pointer to skip _dl_skip_args words.\n\ <br nodeIndex="813">
leal (%esp,%eax,4), %esp\n\//跳过需要skip的参数，这些参数被ld.so处理了 <br nodeIndex="814">
# Subtract _dl_skip_args from argc.\n\ <br nodeIndex="815">
subl %eax, %edx\n\减掉 <br nodeIndex="816">
# Push argc back on the stack.\n\ <br nodeIndex="817">
push %edx\n\//重新压回 <br nodeIndex="818">
# The special initializer gets called with the stack just\n\ <br nodeIndex="819">
# as the application's entry point will see it; it can\n\ <br nodeIndex="820">
# switch stacks if it moves these contents over.\n\ <br nodeIndex="821">
" RTLD_START_SPECIAL_INIT "\n\ 空宏 <br nodeIndex="822">
# Load the parameters again.\n\ <br nodeIndex="823">
# (eax, edx, ecx, *--esp) = (_dl_loaded, argc, argv, envp)\n\ <br nodeIndex="824">
//为_dl_init准备参数,_dl_init的原型是 <br nodeIndex="825">
//void __attribute__((regparm(3),stdcall)) _dl_init (struct link_map *main_map, int argc, char **argv, char **env) <br nodeIndex="826">
movl _rtld_local@GOTOFF(%ebx), %eax\n\//取ld.so的_rtld_local入%eax <br nodeIndex="827">
leal 8(%esp,%edx,4), %esi\n\ esi指向envp <br nodeIndex="828">
leal 4(%esp), %ecx\n\ ecx指向argv <br nodeIndex="829">
pushl %esi\n\ 第四个参数使用堆栈传递 <br nodeIndex="830">
# Call the function to run the initializers.\n\ <br nodeIndex="831">
call _dl_init_internal@PLT\n\调用_dl_init <br nodeIndex="832">
# Pass our finalizer function to the user in %edx, as per ELF ABI.\n\ <br nodeIndex="833">
leal _dl_fini@GOTOFF(%ebx), %edx\n\ 取_dl_fini入edx,传给user <br nodeIndex="834">
# Jump to the user's entry point.\n\ <br nodeIndex="835">
jmp *%edi\n\ <br nodeIndex="836">
.previous\n\ <br nodeIndex="837">
");</p>
<p brd="1" nodeIndex="24">结合crt1.o的分析，大家就很清楚控制和参数是如何被传递的。</p>
<p brd="1" nodeIndex="25">注意扩展属性regparm(3)表示传参数时前三个参数使用%eax,%edx,%ecx寄存器，后面的参数仍然使用堆栈传 <br nodeIndex="838">
stdcall属性表示函数自己平栈，除非使用了可变参数(仍然由调用者平栈)</p>
<p brd="1" nodeIndex="26">2.内核传递给ld.so的参数在堆栈中的形式如下</p>
<p brd="1" nodeIndex="27">position content size (bytes) + comment <br nodeIndex="839">
------------------------------------------------------------------------ <br nodeIndex="840">
stack pointer -> [ argc = number of args ] 4 <br nodeIndex="841">
[ argv[0] (pointer) ] 4 (program name) <br nodeIndex="842">
[ argv[1] (pointer) ] 4 <br nodeIndex="843">
[ argv[..] (pointer) ] 4 * x <br nodeIndex="844">
[ argv[n - 1] (pointer) ] 4 <br nodeIndex="845">
[ argv[n] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="28">[ envp[0] (pointer) ] 4 <br nodeIndex="846">
[ envp[1] (pointer) ] 4 <br nodeIndex="847">
[ envp[..] (pointer) ] 4 <br nodeIndex="848">
[ envp[term] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="29">[ auxv[0] AT_PHDR (Elf32_auxv_t) ] 8 <br nodeIndex="849">
[ auxv[1] AT_PHENT (Elf32_auxv_t) ] 8 <br nodeIndex="850">
[ auxv[2] AT_PHNUM (Elf32_auxv_t) ] 8 <br nodeIndex="851">
[ auxv[3] AT_BASE (Elf32_auxv_t) ] 8 <br nodeIndex="852">
[ auxv[4] AT_FLAGS (Elf32_auxv_t) ] 8 <br nodeIndex="853">
[ auxv[5] AT_ENTRY (Elf32_auxv_t) ] 8 <br nodeIndex="854">
[ auxv[6] AT_UID (Elf32_auxv_t) ] 8 <br nodeIndex="855">
[ auxv[7] AT_EUID (Elf32_auxv_t) ] 8 <br nodeIndex="856">
[ auxv[8] AT_GID (Elf32_auxv_t) ] 8 <br nodeIndex="857">
[ auxv[9] AT_EGID (Elf32_auxv_t) ] 8 <br nodeIndex="858">
[ auxv[10] AT_HWCAP (Elf32_auxv_t) ] 8 <br nodeIndex="859">
[ auxv[11] AT_PAGESZ (Elf32_auxv_t) ] 8 <br nodeIndex="860">
[ auxv[12] AT_CLKTCK (Elf32_auxv_t) ] 8 <br nodeIndex="861">
[ auxv[13] AT_PLATFORM (Elf32_auxv_t) ] 8 <br nodeIndex="862">
[ auxv[14] (Elf32_auxv_t) ] 8 (= AT_NULL vector)</p>
<p brd="1" nodeIndex="30">[ padding ] 0 - 15 <br nodeIndex="863">
[ padding ] 16 <br nodeIndex="864">
[ padding ] 0 - 15</p>
<p brd="1" nodeIndex="31">[k_platform] 0 - 65 <br nodeIndex="865">
[ argument ASCIIZ strings ] >= 0 <br nodeIndex="866">
[ environment ASCIIZ str. ] >= 0 <br nodeIndex="867">
[filename] >=0</p>
<p brd="1" nodeIndex="32">(0xbffffffc) [ end marker ] 4 (= NULL)</p>
<p brd="1" nodeIndex="33">(0xc0000000) < top of stack > 0 (virtual)</p>
<p nodeIndex="34">ld.so分析2</p>
<p brd="1" nodeIndex="35">内核是如何执行程序的,本分析基于内核版本2.4.0</p>
<p brd="1" nodeIndex="36">1.用户空间接口 <br nodeIndex="868">
man execve显示如下的函数原型</p>
<p brd="1" nodeIndex="37">execve - execute program</p>
<p brd="1" nodeIndex="38">SYNOPSIS <br nodeIndex="869">
#include <unistd.h></p>
<p brd="1" nodeIndex="39">int execve(const char *filename, char *const argv [], char *const <br nodeIndex="870">
envp[]);</p>
<p brd="1" nodeIndex="40">2.glibc中实现</p>
<p brd="1" nodeIndex="41">在glibc中,execve对应的文件是 <br nodeIndex="871">
sysdeps/unix/sysv/linux/execve.c</p>
<p brd="1" nodeIndex="42">int <br nodeIndex="872">
__execve (file, argv, envp) <br nodeIndex="873">
const char *file; <br nodeIndex="874">
char *const argv[]; <br nodeIndex="875">
char *const envp[]; <br nodeIndex="876">
{ <br nodeIndex="877">
/* If this is a threaded application kill all other threads. */ <br nodeIndex="878">
if (__pthread_kill_other_threads_np) <br nodeIndex="879">
__pthread_kill_other_threads_np (); <br nodeIndex="880">
#if __BOUNDED_POINTERS__ //该宏未定义 <br nodeIndex="881">
{ <br nodeIndex="882">
char *const *v; <br nodeIndex="883">
int i; <br nodeIndex="884">
char *__unbounded *__unbounded ubp_argv; <br nodeIndex="885">
char *__unbounded *__unbounded ubp_envp; <br nodeIndex="886">
char *__unbounded *__unbounded ubp_v;</p>
<p brd="1" nodeIndex="43">for (v = argv; *v; v++) <br nodeIndex="887">
; <br nodeIndex="888">
i = v - argv + 1; <br nodeIndex="889">
ubp_argv = (char *__unbounded *__unbounded) alloca (sizeof (*ubp_argv) * i); <br nodeIndex="890">
for (v = argv, ubp_v = ubp_argv; --i; v++, ubp_v++) <br nodeIndex="891">
*ubp_v = CHECK_STRING (*v); <br nodeIndex="892">
*ubp_v = 0;</p>
<p brd="1" nodeIndex="44">for (v = envp; *v; v++) <br nodeIndex="893">
; <br nodeIndex="894">
i = v - envp + 1; <br nodeIndex="895">
ubp_envp = (char *__unbounded *__unbounded) alloca (sizeof (*ubp_envp) * i); <br nodeIndex="896">
for (v = envp, ubp_v = ubp_envp; --i; v++, ubp_v++) <br nodeIndex="897">
*ubp_v = CHECK_STRING (*v); <br nodeIndex="898">
*ubp_v = 0;</p>
<p brd="1" nodeIndex="45">return INLINE_SYSCALL (execve, 3, CHECK_STRING (file), ubp_argv, ubp_envp); <br nodeIndex="899">
} <br nodeIndex="900">
#else <br nodeIndex="901">
return INLINE_SYSCALL (execve, 3, file, argv, envp);//所以这行有效 <br nodeIndex="902">
#endif <br nodeIndex="903">
}</p>
<p brd="1" nodeIndex="46">INLINE_SYSCALL的定义在 <br nodeIndex="904">
sysdeps/unix/sysv/linux/i386/sysdeps.h</p>
<p brd="1" nodeIndex="47">#define INLINE_SYSCALL(name, nr, args...) \ <br nodeIndex="905">
({ \ <br nodeIndex="906">
unsigned int resultvar; \ <br nodeIndex="907">
asm volatile ( \ <br nodeIndex="908">
LOADARGS_##nr \ <br nodeIndex="909">
"movl %1, %%eax\n\t" \ <br nodeIndex="910">
"int $0x80\n\t" \ <br nodeIndex="911">
RESTOREARGS_##nr \ <br nodeIndex="912">
: "=a" (resultvar) \ <br nodeIndex="913">
: "i" (__NR_##name) ASMFMT_##nr(args) : "memory", "cc"); \ <br nodeIndex="914">
if (resultvar >= 0xfffff001) \ <br nodeIndex="915">
{ \ <br nodeIndex="916">
__set_errno (-resultvar); \ <br nodeIndex="917">
resultvar = 0xffffffff; \ <br nodeIndex="918">
} \ <br nodeIndex="919">
(int) resultvar; })</p>
<p brd="1" nodeIndex="48">3.手工展开看看</p>
<p brd="1" nodeIndex="49">({ <br nodeIndex="920">
unsigned int resultvar; <br nodeIndex="921">
asm volatile ( <br nodeIndex="922">
LOADARGS_3 <br nodeIndex="923">
"movl %1, %%eax\n\t" <br nodeIndex="924">
"int $0x80\n\t" <br nodeIndex="925">
RESTOREARGS_3 <br nodeIndex="926">
: "=a" (resultvar) <br nodeIndex="927">
: "i" (__NR_execve) ASMFMT_3(args) : "memory", "cc"); <br nodeIndex="928">
if (resultvar >= 0xfffff001) <br nodeIndex="929">
{ <br nodeIndex="930">
__set_errno (-resultvar); <br nodeIndex="931">
resultvar = 0xffffffff; <br nodeIndex="932">
} <br nodeIndex="933">
(int) resultvar; })</p>
<p brd="1" nodeIndex="50">其中__NR_execve是execve的系统调用号,为11，定义在头文件unistd.h中 <br nodeIndex="934">
这其中又涉及到三个宏</p>
<p brd="1" nodeIndex="51">#define LOADARGS_1 \ <br nodeIndex="935">
"bpushl .L__X'%k2, %k2\n\t" \ <br nodeIndex="936">
"bmovl .L__X'%k2, %k2\n\t" <br nodeIndex="937">
#define LOADARGS_3 LOADARGS_1</p>
<p brd="1" nodeIndex="52">#define RESTOREARGS_1 \ <br nodeIndex="938">
"bpopl .L__X'%k2, %k2\n\t" <br nodeIndex="939">
#define RESTOREARGS_3 RESTOREARGS_1</p>
<p brd="1" nodeIndex="53">#define ASMFMT_3(arg1, arg2, arg3) \ <br nodeIndex="940">
, "aCD" (arg1), "c" (arg2), "d" (arg3)</p>
<p brd="1" nodeIndex="54">展开 <br nodeIndex="941">
({ <br nodeIndex="942">
unsigned int resultvar; <br nodeIndex="943">
asm volatile ( <br nodeIndex="944">
"bpushl .L__X'%k2, %k2\n\t" <br nodeIndex="945">
"bmovl .L__X'%k2, %k2\n\t" <br nodeIndex="946">
"movl %1, %%eax\n\t" <br nodeIndex="947">
"int $0x80\n\t" <br nodeIndex="948">
"bpopl .L__X'%k2, %k2\n\t" <br nodeIndex="949">
: "=a" (resultvar) <br nodeIndex="950">
: "i" (11) , "aCD" (arg1), "c" (arg2), "d" (arg3) : "memory", "cc"); <br nodeIndex="951">
if (resultvar >= 0xfffff001) <br nodeIndex="952">
{ <br nodeIndex="953">
__set_errno (-resultvar); <br nodeIndex="954">
resultvar = 0xffffffff; <br nodeIndex="955">
} <br nodeIndex="956">
(int) resultvar; })</p>
<p brd="1" nodeIndex="55">这里又涉及到三个asm宏,bpushl,bmovl,bpopl <br nodeIndex="957">
定义如下(也在该文件sysdeps.h中) <br nodeIndex="958">
asm (".L__X'%ebx = 1\n\t" <br nodeIndex="959">
".L__X'%ecx = 2\n\t" <br nodeIndex="960">
".L__X'%edx = 2\n\t" <br nodeIndex="961">
".L__X'%eax = 3\n\t" <br nodeIndex="962">
".L__X'%esi = 3\n\t" <br nodeIndex="963">
".L__X'%edi = 3\n\t" <br nodeIndex="964">
".L__X'%ebp = 3\n\t" <br nodeIndex="965">
".L__X'%esp = 3\n\t" <br nodeIndex="966">
".macro bpushl name reg\n\t" <br nodeIndex="967">
".if 1 - \\name\n\t" <br nodeIndex="968">
".if 2 - \\name\n\t" <br nodeIndex="969">
"pushl %ebx\n\t" <br nodeIndex="970">
".else\n\t" <br nodeIndex="971">
"xchgl \\reg, %ebx\n\t" <br nodeIndex="972">
".endif\n\t" <br nodeIndex="973">
".endif\n\t" <br nodeIndex="974">
".endm\n\t" <br nodeIndex="975">
".macro bpopl name reg\n\t" <br nodeIndex="976">
".if 1 - \\name\n\t" <br nodeIndex="977">
".if 2 - \\name\n\t" <br nodeIndex="978">
"popl %ebx\n\t" <br nodeIndex="979">
".else\n\t" <br nodeIndex="980">
"xchgl \\reg, %ebx\n\t" <br nodeIndex="981">
".endif\n\t" <br nodeIndex="982">
".endif\n\t" <br nodeIndex="983">
".endm\n\t" <br nodeIndex="984">
".macro bmovl name reg\n\t" <br nodeIndex="985">
".if 1 - \\name\n\t" <br nodeIndex="986">
".if 2 - \\name\n\t" <br nodeIndex="987">
"movl \\reg, %ebx\n\t" <br nodeIndex="988">
".endif\n\t" <br nodeIndex="989">
".endif\n\t" <br nodeIndex="990">
".endm\n\t");</p>
<p brd="1" nodeIndex="56">根据约束条件 <br nodeIndex="991">
%eax分配给resultvar <br nodeIndex="992">
%ecx分配给argv <br nodeIndex="993">
%edx分配给envp <br nodeIndex="994">
则约束条件"aCD"中,a(%eax)已分配,C无效,因此分配%edi给file</p>
<p brd="1" nodeIndex="57">手工展开 <br nodeIndex="995">
mov file,%edi <br nodeIndex="996">
mov argv,%ecx <br nodeIndex="997">
mov envp,%edx <br nodeIndex="998">
bpushl .L__X'%edi, %edi <br nodeIndex="999">
bmovl .L__X'·%edi, %%edi <br nodeIndex="1000">
movl 11, %%eax <br nodeIndex="1001">
int $0x80 <br nodeIndex="1002">
bpopl .L__X'%edi, %edi</p>
<p brd="1" nodeIndex="58">手工展开 <br nodeIndex="1003">
mov file,%edi <br nodeIndex="1004">
mov argv,%ecx <br nodeIndex="1005">
mov envp,%edx <br nodeIndex="1006">
.if 1 - .L_X'%edi <br nodeIndex="1007">
.if 2 - .L_X'%edi <br nodeIndex="1008">
pushl %ebx <br nodeIndex="1009">
.else <br nodeIndex="1010">
xchgl %edi, %ebx <br nodeIndex="1011">
.endif <br nodeIndex="1012">
.endif <br nodeIndex="1013">
.if 1 - .L_X'%edi <br nodeIndex="1014">
.if 2 - .L_X'%edi <br nodeIndex="1015">
movl %edi, %ebx <br nodeIndex="1016">
.endif <br nodeIndex="1017">
.endif <br nodeIndex="1018">
movl 11, %%eax <br nodeIndex="1019">
int $0x80 <br nodeIndex="1020">
.if 1 - .L_X'%edi <br nodeIndex="1021">
.if 2 - .L_X'%edi <br nodeIndex="1022">
popl %ebx <br nodeIndex="1023">
.else <br nodeIndex="1024">
xchgl %edi, %ebx <br nodeIndex="1025">
.endif <br nodeIndex="1026">
.endif</p>
<p brd="1" nodeIndex="59">由于L__X'%edi = 3,展开</p>
<p brd="1" nodeIndex="60">mov file,%edi <br nodeIndex="1027">
mov argv,%ecx <br nodeIndex="1028">
mov envp,%edx <br nodeIndex="1029">
.if 1 - 3 <br nodeIndex="1030">
.if 2 - 3 <br nodeIndex="1031">
pushl %ebx <br nodeIndex="1032">
.else <br nodeIndex="1033">
xchgl %edi, %ebx <br nodeIndex="1034">
.endif <br nodeIndex="1035">
.endif <br nodeIndex="1036">
.if 1 - 3 <br nodeIndex="1037">
.if 2 - 3 <br nodeIndex="1038">
movl %edi, %ebx <br nodeIndex="1039">
.endif <br nodeIndex="1040">
.endif <br nodeIndex="1041">
movl 11, %%eax <br nodeIndex="1042">
int $0x80 <br nodeIndex="1043">
.if 1 - 3 <br nodeIndex="1044">
.if 2 - 3 <br nodeIndex="1045">
popl %ebx <br nodeIndex="1046">
.else <br nodeIndex="1047">
xchgl %edi, %ebx <br nodeIndex="1048">
.endif <br nodeIndex="1049">
.endif</p>
<p brd="1" nodeIndex="61">.if为真的条件是不等于0,展开</p>
<p brd="1" nodeIndex="62">mov file,%edi <br nodeIndex="1050">
mov argv,%ecx <br nodeIndex="1051">
mov envp,%edx <br nodeIndex="1052">
pushl %ebx <br nodeIndex="1053">
movl %edi, %ebx <br nodeIndex="1054">
movl 11, %%eax <br nodeIndex="1055">
int $0x80 <br nodeIndex="1056">
popl %ebx</p>
<p brd="1" nodeIndex="63"> <br nodeIndex="1057">
最终编译结果是 <br nodeIndex="1058">
mov 0x8(%ebp),%edi <br nodeIndex="1059">
mov 0xc(%ebp),%ecx <br nodeIndex="1060">
mov 0x10(%ebp),%edx <br nodeIndex="1061">
push %ebx <br nodeIndex="1062">
mov %edi,%ebx <br nodeIndex="1063">
mov $0xb,%eax <br nodeIndex="1064">
int $0x80 <br nodeIndex="1065">
pop %ebx</p>
<p brd="1" nodeIndex="64">正好一致</p>
<p brd="1" nodeIndex="65">系统调用传参使用%ebx,%ecx,%edx,%esi,%edi这五个寄存器，因此最多只能传五个参数.</p>
<p brd="1" nodeIndex="66">4.返回值的处理 <br nodeIndex="1066">
# define __set_errno(val) (*__errno_location ()) = (val)</p>
<p brd="1" nodeIndex="67">if (resultvar >= 0xfffff001)//如果返回值>=0xfffff001,则出错 <br nodeIndex="1067">
{ <br nodeIndex="1068">
__set_errno (-resultvar);// 预处理时被替换成(*__errno_location ()) = (-resultvar);设置errno为-resultvar <br nodeIndex="1069">
resultvar = 0xffffffff; //-1 <br nodeIndex="1070">
}</p>
<p brd="1" nodeIndex="68"> <br nodeIndex="1071">
__errno_location的定义是 <br nodeIndex="1072">
sysdeps/generic/errno-loc.c</p>
<p brd="1" nodeIndex="69">int * __errno_location (void) <br nodeIndex="1073">
{ <br nodeIndex="1074">
return &errno; <br nodeIndex="1075">
}</p>
<p brd="1" nodeIndex="70"> <br nodeIndex="1076">
5.也可使用如下宏生成调用系统调用execve的代码 <br nodeIndex="1077">
linux/include/asm-i386/unistd.h</p>
<p brd="1" nodeIndex="71">#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \ <br nodeIndex="1078">
type name(type1 arg1,type2 arg2,type3 arg3) \ <br nodeIndex="1079">
{ \ <br nodeIndex="1080">
long __res; \ <br nodeIndex="1081">
__asm__ volatile ("int $0x80" \ <br nodeIndex="1082">
: "=a" (__res) \ <br nodeIndex="1083">
: "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)), \ <br nodeIndex="1084">
"d" ((long)(arg3))); \ <br nodeIndex="1085">
__syscall_return(type,__res); \ <br nodeIndex="1086">
}</p>
<p brd="1" nodeIndex="72">例如 <br nodeIndex="1087">
_syscall3(int,execve,const char *,file,char *const,argv[],char *const,envp[]) <br nodeIndex="1088">
能生成和glibc相似的代码</p>
<p brd="1" nodeIndex="73"> <br nodeIndex="1089">
6.sys_execve <br nodeIndex="1090">
linux/arch/i386/kernel/process.c</p>
<p brd="1" nodeIndex="74">/* <br nodeIndex="1091">
* sys_execve() executes a new program. <br nodeIndex="1092">
*/ <br nodeIndex="1093">
asmlinkage int sys_execve(struct pt_regs regs) <br nodeIndex="1094">
{ <br nodeIndex="1095">
int error; <br nodeIndex="1096">
char * filename;</p>
<p brd="1" nodeIndex="75">filename = getname((char *) regs.ebx); <br nodeIndex="1097">
error = PTR_ERR(filename); <br nodeIndex="1098">
if (IS_ERR(filename)) <br nodeIndex="1099">
goto out; <br nodeIndex="1100">
//do_execve成功替换掉执行影像后，在返回到用户空间时，执行权才交给新的影像 <br nodeIndex="1101">
error = do_execve(filename, (char **) regs.ecx, (char **) regs.edx, &regs); <br nodeIndex="1102">
if (error == 0) <br nodeIndex="1103">
current->ptrace &= ~PT_DTRACE;//取消单步跟踪 <br nodeIndex="1104">
putname(filename); <br nodeIndex="1105">
out: <br nodeIndex="1106">
return error; <br nodeIndex="1107">
}</p>
<p brd="1" nodeIndex="76">7.do_execve(sys_execve->do_execve) <br nodeIndex="1108">
fs/exec.c</p>
<p brd="1" nodeIndex="77">/* <br nodeIndex="1109">
* sys_execve() executes a new program. <br nodeIndex="1110">
*/ <br nodeIndex="1111">
int do_execve(char * filename, char ** argv, char ** envp, struct pt_regs * regs) <br nodeIndex="1112">
{ <br nodeIndex="1113">
struct linux_binprm bprm; <br nodeIndex="1114">
struct file *file; <br nodeIndex="1115">
int retval; <br nodeIndex="1116">
int i;</p>
<p brd="1" nodeIndex="78">file = open_exec(filename);</p>
<p brd="1" nodeIndex="79">retval = PTR_ERR(file); <br nodeIndex="1117">
if (IS_ERR(file)) <br nodeIndex="1118">
return retval;</p>
<p brd="1" nodeIndex="80">bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);//参数最多占32个页面,最后一个字存放NULL <br nodeIndex="1119">
memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));//清空页指针</p>
<p brd="1" nodeIndex="81">bprm.file = file; <br nodeIndex="1120">
bprm.filename = filename; <br nodeIndex="1121">
bprm.sh_bang = 0; <br nodeIndex="1122">
bprm.loader = 0; <br nodeIndex="1123">
bprm.exec = 0; <br nodeIndex="1124">
//计算argv数组的长度,该数组是0结束 <br nodeIndex="1125">
if ((bprm.argc = count(argv, bprm.p / sizeof(void *))) < 0) { <br nodeIndex="1126">
allow_write_access(file); <br nodeIndex="1127">
fput(file); <br nodeIndex="1128">
return bprm.argc; <br nodeIndex="1129">
}</p>
<p brd="1" nodeIndex="82">//计算envp数组的长度 <br nodeIndex="1130">
if ((bprm.envc = count(envp, bprm.p / sizeof(void *))) < 0) { <br nodeIndex="1131">
allow_write_access(file); <br nodeIndex="1132">
fput(file); <br nodeIndex="1133">
return bprm.envc; <br nodeIndex="1134">
}</p>
<p brd="1" nodeIndex="83">retval = prepare_binprm(&bprm); <br nodeIndex="1135">
if (retval < 0) <br nodeIndex="1136">
goto out;</p>
<p brd="1" nodeIndex="84">retval = copy_strings_kernel(1, &bprm.filename, &bprm);//复制文件名 <br nodeIndex="1137">
if (retval < 0) <br nodeIndex="1138">
goto out;</p>
<p brd="1" nodeIndex="85">bprm.exec = bprm.p; <br nodeIndex="1139">
retval = copy_strings(bprm.envc, envp, &bprm);//复制envp <br nodeIndex="1140">
if (retval < 0) <br nodeIndex="1141">
goto out;</p>
<p brd="1" nodeIndex="86">retval = copy_strings(bprm.argc, argv, &bprm);//复制argv <br nodeIndex="1142">
if (retval < 0) <br nodeIndex="1143">
goto out;</p>
<p brd="1" nodeIndex="87">retval = search_binary_handler(&bprm,regs); <br nodeIndex="1144">
if (retval >= 0) <br nodeIndex="1145">
/* execve success */ <br nodeIndex="1146">
return retval;</p>
<p brd="1" nodeIndex="88">out: <br nodeIndex="1147">
/* Something went wrong, return the inode and free the argument pages*/ <br nodeIndex="1148">
allow_write_access(bprm.file); <br nodeIndex="1149">
if (bprm.file) <br nodeIndex="1150">
fput(bprm.file);</p>
<p brd="1" nodeIndex="89">for (i = 0 ; i < MAX_ARG_PAGES ; i++) { <br nodeIndex="1151">
struct page * page = bprm.page[i]; <br nodeIndex="1152">
if (page) <br nodeIndex="1153">
__free_page(page); <br nodeIndex="1154">
}</p>
<p brd="1" nodeIndex="90">return retval; <br nodeIndex="1155">
}</p>
<p brd="1" nodeIndex="91">8.copy_strings(sys_execve->do_execve->copy_strings) <br nodeIndex="1156">
fs/exec.c</p>
<p brd="1" nodeIndex="92">/* <br nodeIndex="1157">
* 'copy_strings()' copies argument/envelope strings from user <br nodeIndex="1158">
* memory to free pages in kernel mem. These are in a format ready <br nodeIndex="1159">
* to be put directly into the top of new user memory. <br nodeIndex="1160">
*/ <br nodeIndex="1161">
//从用户空间拷贝数据到空闲页 <br nodeIndex="1162">
int copy_strings(int argc,char ** argv, struct linux_binprm *bprm) <br nodeIndex="1163">
{ <br nodeIndex="1164">
while (argc-- > 0) {//argc-- <br nodeIndex="1165">
char *str; <br nodeIndex="1166">
int len; <br nodeIndex="1167">
unsigned long pos; <br nodeIndex="1168">
//上面argc-- <br nodeIndex="1169">
if (get_user(str, argv+argc) || !str || !(len = strnlen_user(str, bprm->p))) <br nodeIndex="1170">
return -EFAULT; <br nodeIndex="1171">
if (bprm->p < len) //空间不够 <br nodeIndex="1172">
return -E2BIG;</p>
<p brd="1" nodeIndex="93">bprm->p -= len;//从后往前考 <br nodeIndex="1173">
/* XXX: add architecture specific overflow check here. */</p>
<p brd="1" nodeIndex="94">pos = bprm->p; <br nodeIndex="1174">
while (len > 0) { <br nodeIndex="1175">
char *kaddr; <br nodeIndex="1176">
int i, new, err; <br nodeIndex="1177">
struct page *page; <br nodeIndex="1178">
int offset, bytes_to_copy;</p>
<p brd="1" nodeIndex="95">offset = pos % PAGE_SIZE;//页内偏移 <br nodeIndex="1179">
i = pos/PAGE_SIZE;//页号 <br nodeIndex="1180">
page = bprm->page[i]; <br nodeIndex="1181">
new = 0; <br nodeIndex="1182">
if (!page) { <br nodeIndex="1183">
page = alloc_page(GFP_HIGHUSER); <br nodeIndex="1184">
bprm->page[i] = page; <br nodeIndex="1185">
if (!page) <br nodeIndex="1186">
return -ENOMEM; <br nodeIndex="1187">
new = 1; <br nodeIndex="1188">
} <br nodeIndex="1189">
kaddr = kmap(page);</p>
<p brd="1" nodeIndex="96">if (new && offset)//是新页，offset>0,清[0,offset) <br nodeIndex="1190">
memset(kaddr, 0, offset); <br nodeIndex="1191">
bytes_to_copy = PAGE_SIZE - offset; <br nodeIndex="1192">
if (bytes_to_copy > len) { <br nodeIndex="1193">
bytes_to_copy = len; <br nodeIndex="1194">
if (new)//清[offset+len,PAGE_SIZE) <br nodeIndex="1195">
memset(kaddr+offset+len, 0, PAGE_SIZE-offset-len); <br nodeIndex="1196">
} <br nodeIndex="1197">
err = copy_from_user(kaddr + offset, str, bytes_to_copy); <br nodeIndex="1198">
kunmap(page);</p>
<p brd="1" nodeIndex="97">if (err) <br nodeIndex="1199">
return -EFAULT;</p>
<p brd="1" nodeIndex="98">pos += bytes_to_copy;//可能跨页 <br nodeIndex="1200">
str += bytes_to_copy; <br nodeIndex="1201">
len -= bytes_to_copy; <br nodeIndex="1202">
} <br nodeIndex="1203">
} <br nodeIndex="1204">
return 0; <br nodeIndex="1205">
}</p>
<p brd="1" nodeIndex="99">执行到这里bprm->p内存空间布局如下 <br nodeIndex="1206">
[ argument ASCIIZ strings ] >= 0 <br nodeIndex="1207">
[ environment ASCIIZ str. ] >= 0 <br nodeIndex="1208">
[filename] <br nodeIndex="1209">
(0xbffffffc) [ end marker ] 4 (= NULL)</p>
<p brd="1" nodeIndex="100">(0xc0000000) < top of stack > 0 (virtual)</p>
<p brd="1" nodeIndex="101">写一个程序验证一下 <br nodeIndex="1210">
系统redhat7.2 <br nodeIndex="1211">
[root@proxy ~]# uname -a <br nodeIndex="1212">
Linux proxy 2.4.7-10smp #1 SMP Thu Sep 6 17:09:31 EDT 2001 i686 unknown <br nodeIndex="1213">
[root@proxy ~]# <br nodeIndex="1214">
root@proxy ~]# cat 1.c <br nodeIndex="1215">
#include <stdio.h></p>
<p brd="1" nodeIndex="102">int main(int argc,char * argv[],char * envp[]) <br nodeIndex="1216">
{ <br nodeIndex="1217">
unsigned char * p; <br nodeIndex="1218">
printf("%d,%p,%p\n",argc,argv,envp); <br nodeIndex="1219">
p=(unsigned char *)argv; <br nodeIndex="1220">
for(;p<(unsigned char *)0xc0000000;p++) <br nodeIndex="1221">
if(isprint(*p)) <br nodeIndex="1222">
printf("%c",*p); <br nodeIndex="1223">
else <br nodeIndex="1224">
printf("\\%x",*p); <br nodeIndex="1225">
return 0; <br nodeIndex="1226">
}</p>
<p brd="1" nodeIndex="103">[root@proxy ~]# ./a.out <br nodeIndex="1227">
1,0xbffffb04,0xbffffb0c <br nodeIndex="1228">
\3\fc\ff\bf\0\0\0\0\b\fc\ff\bf\15\fc\ff\bf$\fc\ff\bf<\fc\ff\bf^\fc\ff\bfj\fc\ff\bft\fc\ff\bf7\fe\ff\bfV\fe\ff\bfp\fe\ff\bf\85\fe\ff\bf\9c\fe\ff\bf\a7\fe\ff\bf\b4\fe\ff\bf\bc\fe\ff\bf\cc\fe\ff\bf\da\fe\ff\bf\e8\fe\ff\bf\f9\fe\ff\bf\7\ff\ff\bf\12\ff\ff\bf\1d\ff\ff\bfI\ff\ff\bf|\ff\ff\bf\d7\ff\ff\bf\ea\ff\ff\bf\0\0\0\0\10\0\0\0\ff\fb\83\3\6\0\0\0\0\10\0\0\11\0\0\0d\0\0\0\3\0\0\04\80\4\8\4\0\0\0 \0\0\0\5\0\0\0\6\0\0\0\7\0\0\0\0\0\0@\8\0\0\0\0\0\0\0\9\0\0\0\90\83\4\8\b\0\0\0\0\0\0\0\c\0\0\0\0\0\0\0\d\0\0\0\0\0\0\0\e\0\0\0\0\0\0\0\f\0\0\0\fe\fb\ff\bf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0i686\0./a.out\0PWD=/root\0HOSTNAME=proxy\0QTDIR=/usr/lib/qt-2.3.1\0LESSOPEN=|/usr/bin/lesspipe.sh %s\0KDEDIR=/usr\0USER=root\0LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:\0MACHTYPE=i386-redhat-linux-gnu\0MAIL=/var/spool/mail/root\0INPUTRC=/etc/inputrc\0BASH_ENV=/root/.bashrc\0LANG=en_US\0LOGNAME=root\0SHLVL=1\0SHELL=/bin/bash\0USERNAME=root\0HOSTTYPE=i386\0OSTYPE=linux-gnu\0HISTSIZE=1000\0HOME=/root\0TERM=linux\0SSH_AUTH_SOCK=/tmp/ssh-XXi40Qtw/agent.23262\0SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass\0PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin\0SSH_TTY=/dev/pts/0\0_=./a.out\0./a.out\0\0\0\0\0</p>

<p brd="1" nodeIndex="105">9.search_binary_handler(sys_execve->do_execve->search_binary_handler) <br nodeIndex="1229">
fs/exec.c</p>
<p brd="1" nodeIndex="106">/* <br nodeIndex="1230">
* cycle the list of binary formats handler, until one recognizes the image <br nodeIndex="1231">
*/ <br nodeIndex="1232">
int search_binary_handler(struct linux_binprm *bprm,struct pt_regs *regs) <br nodeIndex="1233">
{ <br nodeIndex="1234">
int try,retval=0; <br nodeIndex="1235">
struct linux_binfmt *fmt; <br nodeIndex="1236">
#ifdef __alpha__ <br nodeIndex="1237">
/* handle /sbin/loader.. */ <br nodeIndex="1238">
{ <br nodeIndex="1239">
struct exec * eh = (struct exec *) bprm->buf;</p>
<p brd="1" nodeIndex="107">if (!bprm->loader && eh->fh.f_magic == 0x183 && <br nodeIndex="1240">
(eh->fh.f_flags & 0x3000) == 0x3000) <br nodeIndex="1241">
{ <br nodeIndex="1242">
char * dynloader[] = { "/sbin/loader" }; <br nodeIndex="1243">
struct file * file; <br nodeIndex="1244">
unsigned long loader;</p>
<p brd="1" nodeIndex="108">allow_write_access(bprm->file); <br nodeIndex="1245">
fput(bprm->file); <br nodeIndex="1246">
bprm->file = NULL;</p>
<p brd="1" nodeIndex="109">loader = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);</p>
<p brd="1" nodeIndex="110">file = open_exec(dynloader[0]); <br nodeIndex="1247">
retval = PTR_ERR(file); <br nodeIndex="1248">
if (IS_ERR(file)) <br nodeIndex="1249">
return retval; <br nodeIndex="1250">
bprm->file = file; <br nodeIndex="1251">
bprm->loader = loader; <br nodeIndex="1252">
retval = prepare_binprm(bprm); <br nodeIndex="1253">
if (retval<0) <br nodeIndex="1254">
return retval; <br nodeIndex="1255">
/* should call search_binary_handler recursively here, <br nodeIndex="1256">
but it does not matter */ <br nodeIndex="1257">
} <br nodeIndex="1258">
} <br nodeIndex="1259">
#endif <br nodeIndex="1260">
for (try=0; try<2; try++) { <br nodeIndex="1261">
read_lock(&binfmt_lock); <br nodeIndex="1262">
for (fmt = formats ; fmt ; fmt = fmt->next) { <br nodeIndex="1263">
int (*fn)(struct linux_binprm *, struct pt_regs *) = fmt->load_binary; <br nodeIndex="1264">
if (!fn) <br nodeIndex="1265">
continue; <br nodeIndex="1266">
if (!try_inc_mod_count(fmt->module)) <br nodeIndex="1267">
continue; <br nodeIndex="1268">
read_unlock(&binfmt_lock); <br nodeIndex="1269">
retval = fn(bprm, regs);//调用该文件格式的load_binary <br nodeIndex="1270">
if (retval >= 0) {//成功 <br nodeIndex="1271">
put_binfmt(fmt); <br nodeIndex="1272">
allow_write_access(bprm->file);//allow write <br nodeIndex="1273">
if (bprm->file) <br nodeIndex="1274">
fput(bprm->file); <br nodeIndex="1275">
bprm->file = NULL; <br nodeIndex="1276">
current->did_exec = 1;//可以执行了 <br nodeIndex="1277">
return retval; <br nodeIndex="1278">
} <br nodeIndex="1279">
read_lock(&binfmt_lock); <br nodeIndex="1280">
put_binfmt(fmt); <br nodeIndex="1281">
if (retval != -ENOEXEC) <br nodeIndex="1282">
break; <br nodeIndex="1283">
if (!bprm->file) { <br nodeIndex="1284">
read_unlock(&binfmt_lock); <br nodeIndex="1285">
return retval; <br nodeIndex="1286">
} <br nodeIndex="1287">
} <br nodeIndex="1288">
read_unlock(&binfmt_lock); <br nodeIndex="1289">
if (retval != -ENOEXEC) { <br nodeIndex="1290">
break; <br nodeIndex="1291">
#ifdef CONFIG_KMOD <br nodeIndex="1292">
}else{ <br nodeIndex="1293">
#define printable(c) (((c)=='\t') || ((c)=='\n') || (0x20<=(c) && (c)<=0x7e)) <br nodeIndex="1294">
char modname[20]; <br nodeIndex="1295">
if (printable(bprm->buf[0]) && <br nodeIndex="1296">
printable(bprm->buf[1]) && <br nodeIndex="1297">
printable(bprm->buf[2]) && <br nodeIndex="1298">
printable(bprm->buf[3])) <br nodeIndex="1299">
break; /* -ENOEXEC 不允许都是可打印字符*/ <br nodeIndex="1300">
sprintf(modname, "binfmt-%04x", *(unsigned short *)(&bprm->buf[2])); <br nodeIndex="1301">
request_module(modname); <br nodeIndex="1302">
#endif <br nodeIndex="1303">
} <br nodeIndex="1304">
} <br nodeIndex="1305">
return retval; <br nodeIndex="1306">
}</p>
<p brd="1" nodeIndex="111">elf文件的相关处理结构在fs/binfmt_elf.c中</p>
<p brd="1" nodeIndex="112">static int __init init_elf_binfmt(void) <br nodeIndex="1307">
{ <br nodeIndex="1308">
return register_binfmt(&elf_format); <br nodeIndex="1309">
}</p>
<p brd="1" nodeIndex="113">static struct linux_binfmt elf_format = { <br nodeIndex="1310">
NULL, THIS_MODULE, load_elf_binary, load_elf_library, elf_core_dump, ELF_EXEC_PAGESIZE <br nodeIndex="1311">
};</p>
<p brd="1" nodeIndex="114">因此elf的load_binary函数是load_elf_binary</p>


<p nodeIndex="118">ld.so分析3</p>
<p brd="1" nodeIndex="119">内核中load_elf_binary如何执行</p>
<p brd="1" nodeIndex="120">1.load_elf_binary <br nodeIndex="1312">
fs/binfmt_elf.c</p>
<p brd="1" nodeIndex="121">/* <br nodeIndex="1313">
* These are the functions used to load ELF style executables and shared <br nodeIndex="1314">
* libraries. There is no binary dependent code anywhere else. <br nodeIndex="1315">
*/</p>
<p brd="1" nodeIndex="122">#define INTERPRETER_NONE 0 <br nodeIndex="1316">
#define INTERPRETER_AOUT 1 <br nodeIndex="1317">
#define INTERPRETER_ELF 2</p>
<p brd="1" nodeIndex="123"> <br nodeIndex="1318">
static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs) <br nodeIndex="1319">
{ <br nodeIndex="1320">
struct file *interpreter = NULL; /* to shut gcc up */ <br nodeIndex="1321">
unsigned long load_addr = 0, load_bias; <br nodeIndex="1322">
int load_addr_set = 0; <br nodeIndex="1323">
char * elf_interpreter = NULL; <br nodeIndex="1324">
unsigned int interpreter_type = INTERPRETER_NONE; <br nodeIndex="1325">
unsigned char ibcs2_interpreter = 0; <br nodeIndex="1326">
mm_segment_t old_fs; <br nodeIndex="1327">
unsigned long error; <br nodeIndex="1328">
struct elf_phdr * elf_ppnt, *elf_phdata; <br nodeIndex="1329">
unsigned long elf_bss, k, elf_brk; <br nodeIndex="1330">
int elf_exec_fileno; <br nodeIndex="1331">
int retval, size, i; <br nodeIndex="1332">
unsigned long elf_entry, interp_load_addr = 0; <br nodeIndex="1333">
unsigned long start_code, end_code, start_data, end_data; <br nodeIndex="1334">
struct elfhdr elf_ex; <br nodeIndex="1335">
struct elfhdr interp_elf_ex; <br nodeIndex="1336">
struct exec interp_ex; <br nodeIndex="1337">
char passed_fileno[6];</p>
<p brd="1" nodeIndex="124">/* Get the exec-header */ <br nodeIndex="1338">
elf_ex = *((struct elfhdr *) bprm->buf);</p>
<p brd="1" nodeIndex="125">retval = -ENOEXEC; <br nodeIndex="1339">
/* First of all, some simple consistency checks */ <br nodeIndex="1340">
//检查magic <br nodeIndex="1341">
if (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0) <br nodeIndex="1342">
goto out;</p>
<p brd="1" nodeIndex="126">//既非可执行文件又非动态链接库,动态链接库也可直接执行 <br nodeIndex="1343">
if (elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) <br nodeIndex="1344">
goto out; <br nodeIndex="1345">
if (!elf_check_arch(&elf_ex))//体系结构检查 <br nodeIndex="1346">
goto out; <br nodeIndex="1347">
if (!bprm->file->f_op||!bprm->file->f_op->mmap)//不能mmap,error <br nodeIndex="1348">
goto out;</p>
<p brd="1" nodeIndex="127">/* Now read in all of the header information */</p>
<p brd="1" nodeIndex="128">retval = -ENOMEM; <br nodeIndex="1349">
/* <br nodeIndex="1350">
typedef struct elf32_hdr{ <br nodeIndex="1351">
unsigned char e_ident[EI_NIDENT]; <br nodeIndex="1352">
Elf32_Half e_type; <br nodeIndex="1353">
Elf32_Half e_machine; <br nodeIndex="1354">
Elf32_Word e_version; <br nodeIndex="1355">
Elf32_Addr e_entry; <br nodeIndex="1356">
Elf32_Off e_phoff; <br nodeIndex="1357">
Elf32_Off e_shoff; <br nodeIndex="1358">
Elf32_Word e_flags; <br nodeIndex="1359">
Elf32_Half e_ehsize; <br nodeIndex="1360">
Elf32_Half e_phentsize; <br nodeIndex="1361">
Elf32_Half e_phnum; <br nodeIndex="1362">
Elf32_Half e_shentsize; <br nodeIndex="1363">
Elf32_Half e_shnum; <br nodeIndex="1364">
Elf32_Half e_shstrndx; <br nodeIndex="1365">
} Elf32_Ehdr; <br nodeIndex="1366">
*/ <br nodeIndex="1367">
//e_phentsize 该成员保存着在文件的程序头表（program header table） <br nodeIndex="1368">
//中一个入口的大小(以字节计数)。所有的入口都是同样的大小。 
//e_phnum 该成员保存着在程序头表中入口的个数。因此，e_phentsize和e_phnum <br nodeIndex="1371">
//的乘机就是表的大小(以字节计数).假如没有程序头表（program header table）， <br nodeIndex="1372">
//e_phnum变量为0。 <br nodeIndex="1373">
size = elf_ex.e_phentsize * elf_ex.e_phnum; <br nodeIndex="1374">
if (size > 65536) <br nodeIndex="1375">
goto out; <br nodeIndex="1376">
elf_phdata = (struct elf_phdr *) kmalloc(size, GFP_KERNEL); <br nodeIndex="1377">
if (!elf_phdata) <br nodeIndex="1378">
goto out;</p>
<p brd="1" nodeIndex="129">//读入 program headers <br nodeIndex="1379">
retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *) elf_phdata, size); <br nodeIndex="1380">
if (retval < 0) <br nodeIndex="1381">
goto out_free_ph;</p>
<p brd="1" nodeIndex="130">retval = get_unused_fd(); <br nodeIndex="1382">
if (retval < 0) <br nodeIndex="1383">
goto out_free_ph; <br nodeIndex="1384">
get_file(bprm->file); <br nodeIndex="1385">
//保存原始打开文件 <br nodeIndex="1386">
fd_install(elf_exec_fileno = retval, bprm->file);//flush old exec不会关闭</p>
<p brd="1" nodeIndex="131">elf_ppnt = elf_phdata;//program headers <br nodeIndex="1387">
elf_bss = 0; <br nodeIndex="1388">
elf_brk = 0;</p>
<p brd="1" nodeIndex="132">start_code = ~0UL;// -1 <br nodeIndex="1389">
end_code = 0; <br nodeIndex="1390">
start_data = 0; <br nodeIndex="1391">
end_data = 0;</p>
<p brd="1" nodeIndex="133">for (i = 0; i < elf_ex.e_phnum; i++) {//处理每一个program headers,寻找PT_INTERP <br nodeIndex="1392">
if (elf_ppnt->p_type == PT_INTERP) { <br nodeIndex="1393">
retval = -EINVAL; <br nodeIndex="1394">
if (elf_interpreter)//已经有interpreter <br nodeIndex="1395">
goto out_free_dentry;</p>
<p brd="1" nodeIndex="134">/* This is the program interpreter used for <br nodeIndex="1396">
* shared libraries - for now assume that this <br nodeIndex="1397">
* is an a.out format binary <br nodeIndex="1398">
*/ <br nodeIndex="1399">
/* <br nodeIndex="1400">
typedef struct elf32_phdr{ <br nodeIndex="1401">
Elf32_Word p_type; <br nodeIndex="1402">
Elf32_Off p_offset; <br nodeIndex="1403">
Elf32_Addr p_vaddr; <br nodeIndex="1404">
Elf32_Addr p_paddr; <br nodeIndex="1405">
Elf32_Word p_filesz; <br nodeIndex="1406">
Elf32_Word p_memsz; <br nodeIndex="1407">
Elf32_Word p_flags; <br nodeIndex="1408">
Elf32_Word p_align; <br nodeIndex="1409">
} Elf32_Phdr; <br nodeIndex="1410">
*/ <br nodeIndex="1411">
retval = -ENOMEM; <br nodeIndex="1412">
elf_interpreter = (char *) kmalloc(elf_ppnt->p_filesz, <br nodeIndex="1413">
GFP_KERNEL); <br nodeIndex="1414">
if (!elf_interpreter) <br nodeIndex="1415">
goto out_free_file;</p>
<p brd="1" nodeIndex="135">retval = kernel_read(bprm->file, elf_ppnt->p_offset, <br nodeIndex="1416">
elf_interpreter, <br nodeIndex="1417">
elf_ppnt->p_filesz);//读入interp <br nodeIndex="1418">
if (retval < 0) <br nodeIndex="1419">
goto out_free_interp; <br nodeIndex="1420">
/* If the program interpreter is one of these two, <br nodeIndex="1421">
* then assume an iBCS2 image. Otherwise assume <br nodeIndex="1422">
* a native linux image. <br nodeIndex="1423">
redhat 7.2 中是 /lib/ld-linux.so.2 <br nodeIndex="1424">
*/ <br nodeIndex="1425">
if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 || <br nodeIndex="1426">
strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0) <br nodeIndex="1427">
ibcs2_interpreter = 1; <br nodeIndex="1428">
#if 0 <br nodeIndex="1429">
printk("Using ELF interpreter %s\n", elf_interpreter); <br nodeIndex="1430">
#endif <br nodeIndex="1431">
#ifdef __sparc__ <br nodeIndex="1432">
if (ibcs2_interpreter) { <br nodeIndex="1433">
unsigned long old_pers = current->personality; <br nodeIndex="1434">
struct exec_domain *old_domain = current->exec_domain; <br nodeIndex="1435">
struct exec_domain *new_domain; <br nodeIndex="1436">
struct fs_struct *old_fs = current->fs, *new_fs; <br nodeIndex="1437">
get_exec_domain(old_domain); <br nodeIndex="1438">
atomic_inc(&old_fs->count);</p>
<p brd="1" nodeIndex="136">set_personality(PER_SVR4); <br nodeIndex="1439">
interpreter = open_exec(elf_interpreter);</p>
<p brd="1" nodeIndex="137">new_domain = current->exec_domain; <br nodeIndex="1440">
new_fs = current->fs; <br nodeIndex="1441">
current->personality = old_pers; <br nodeIndex="1442">
current->exec_domain = old_domain; <br nodeIndex="1443">
current->fs = old_fs; <br nodeIndex="1444">
put_exec_domain(new_domain); <br nodeIndex="1445">
put_fs_struct(new_fs); <br nodeIndex="1446">
} else <br nodeIndex="1447">
#endif <br nodeIndex="1448">
{ <br nodeIndex="1449">
interpreter = open_exec(elf_interpreter);//打开/lib/ld-linux.so.2 <br nodeIndex="1450">
} <br nodeIndex="1451">
retval = PTR_ERR(interpreter); <br nodeIndex="1452">
if (IS_ERR(interpreter)) <br nodeIndex="1453">
goto out_free_interp; <br nodeIndex="1454">
retval = kernel_read(interpreter, 0, bprm->buf, BINPRM_BUF_SIZE);//读入头部 <br nodeIndex="1455">
if (retval < 0) <br nodeIndex="1456">
goto out_free_dentry;</p>
<p brd="1" nodeIndex="138">/* Get the exec headers */ <br nodeIndex="1457">
interp_ex = *((struct exec *) bprm->buf);//可能是a.out <br nodeIndex="1458">
interp_elf_ex = *((struct elfhdr *) bprm->buf);//可能是elf <br nodeIndex="1459">
} <br nodeIndex="1460">
elf_ppnt++; <br nodeIndex="1461">
}</p>
<p brd="1" nodeIndex="139">/* Some simple consistency checks for the interpreter */ <br nodeIndex="1462">
if (elf_interpreter) {//有interp,执行/lib/ld-linux.so.2时，没有,或静态链接的可执行文件也没有 <br nodeIndex="1463">
interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;</p>
<p brd="1" nodeIndex="140">/* Now figure out which format our binary is */ <br nodeIndex="1464">
if ((N_MAGIC(interp_ex) != OMAGIC) && <br nodeIndex="1465">
(N_MAGIC(interp_ex) != ZMAGIC) && <br nodeIndex="1466">
(N_MAGIC(interp_ex) != QMAGIC)) <br nodeIndex="1467">
interpreter_type = INTERPRETER_ELF;//是interp elf</p>
<p brd="1" nodeIndex="141">if (memcmp(interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0) <br nodeIndex="1468">
interpreter_type &= ~INTERPRETER_ELF;//是interp aout</p>
<p brd="1" nodeIndex="142">retval = -ELIBBAD; <br nodeIndex="1469">
if (!interpreter_type) <br nodeIndex="1470">
goto out_free_dentry;</p>
<p brd="1" nodeIndex="143">/* Make sure only one type was selected */ <br nodeIndex="1471">
if ((interpreter_type & INTERPRETER_ELF) && <br nodeIndex="1472">
interpreter_type != INTERPRETER_ELF) { <br nodeIndex="1473">
printk(KERN_WARNING "ELF: Ambiguous type, using ELF\n"); <br nodeIndex="1474">
interpreter_type = INTERPRETER_ELF; <br nodeIndex="1475">
} <br nodeIndex="1476">
}</p>
<p brd="1" nodeIndex="144">/* OK, we are done with that, now set up the arg stuff, <br nodeIndex="1477">
and then start this sucker up */</p>
<p brd="1" nodeIndex="145">if (!bprm->sh_bang) { <br nodeIndex="1478">
char * passed_p;</p>
<p brd="1" nodeIndex="146">if (interpreter_type == INTERPRETER_AOUT) {//a.out <br nodeIndex="1479">
sprintf(passed_fileno, "%d", elf_exec_fileno);//原始打开文件号 <br nodeIndex="1480">
passed_p = passed_fileno;</p>
<p brd="1" nodeIndex="147">if (elf_interpreter) {//interp文件名 <br nodeIndex="1481">
retval = copy_strings_kernel(1,&passed_p,bprm); <br nodeIndex="1482">
if (retval) <br nodeIndex="1483">
goto out_free_dentry; <br nodeIndex="1484">
bprm->argc++;//打开文件号作为参数 <br nodeIndex="1485">
} <br nodeIndex="1486">
} <br nodeIndex="1487">
}</p>
<p brd="1" nodeIndex="148">/* Flush all traces of the currently running executable */ <br nodeIndex="1488">
retval = flush_old_exec(bprm);//清除旧的执行影像 <br nodeIndex="1489">
if (retval) <br nodeIndex="1490">
goto out_free_dentry;</p>
<p brd="1" nodeIndex="149">/* OK, This is the point of no return */ <br nodeIndex="1491">
current->mm->start_data = 0; <br nodeIndex="1492">
current->mm->end_data = 0; <br nodeIndex="1493">
current->mm->end_code = 0; <br nodeIndex="1494">
current->mm->mmap = NULL; <br nodeIndex="1495">
current->flags &= ~PF_FORKNOEXEC; <br nodeIndex="1496">
elf_entry = (unsigned long) elf_ex.e_entry;//原文件代码入口</p>
<p brd="1" nodeIndex="150">/* Do this immediately, since STACK_TOP as used in setup_arg_pages <br nodeIndex="1497">
may depend on the personality. */ <br nodeIndex="1498">
SET_PERSONALITY(elf_ex, ibcs2_interpreter);</p>
<p brd="1" nodeIndex="151">/* Do this so that we can load the interpreter, if need be. We will <br nodeIndex="1499">
change some of these later */ <br nodeIndex="1500">
current->mm->rss = 0; <br nodeIndex="1501">
setup_arg_pages(bprm); /* XXX: check error */</p>
<p brd="1" nodeIndex="152">2.setup_arg_pages <br nodeIndex="1502">
load_elf_binayr->setup_arg_page <br nodeIndex="1503">
fs/exec.c</p>
<p brd="1" nodeIndex="153">//把arg pages页和进程挂钩 <br nodeIndex="1504">
int setup_arg_pages(struct linux_binprm *bprm) <br nodeIndex="1505">
{ <br nodeIndex="1506">
unsigned long stack_base; <br nodeIndex="1507">
struct vm_area_struct *mpnt; <br nodeIndex="1508">
int i;</p>
<p brd="1" nodeIndex="154">stack_base = STACK_TOP - MAX_ARG_PAGES*PAGE_SIZE;//堆栈基址</p>
<p brd="1" nodeIndex="155">bprm->p += stack_base;//变换成地址 <br nodeIndex="1509">
if (bprm->loader) <br nodeIndex="1510">
bprm->loader += stack_base; <br nodeIndex="1511">
bprm->exec += stack_base;</p>
<p brd="1" nodeIndex="156">mpnt = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);//为堆栈段分配vm_area_struct结构 <br nodeIndex="1512">
if (!mpnt) <br nodeIndex="1513">
return -ENOMEM; 
down(&current->mm->mmap_sem); <br nodeIndex="1516">
{ <br nodeIndex="1517">
mpnt->vm_mm = current->mm; <br nodeIndex="1518">
mpnt->vm_start = PAGE_MASK & (unsigned long) bprm->p;//下对齐 <br nodeIndex="1519">
mpnt->vm_end = STACK_TOP; <br nodeIndex="1520">
mpnt->vm_page_prot = PAGE_COPY; <br nodeIndex="1521">
mpnt->vm_flags = VM_STACK_FLAGS; <br nodeIndex="1522">
mpnt->vm_ops = NULL; <br nodeIndex="1523">
mpnt->vm_pgoff = 0; <br nodeIndex="1524">
mpnt->vm_file = NULL; <br nodeIndex="1525">
mpnt->vm_private_data = (void *) 0; <br nodeIndex="1526">
insert_vm_struct(current->mm, mpnt); <br nodeIndex="1527">
current->mm->total_vm = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT; <br nodeIndex="1528">
}</p>
<p brd="1" nodeIndex="157">for (i = 0 ; i < MAX_ARG_PAGES ; i++) { <br nodeIndex="1529">
struct page *page = bprm->page[i]; <br nodeIndex="1530">
if (page) { <br nodeIndex="1531">
bprm->page[i] = NULL; <br nodeIndex="1532">
current->mm->rss++;//驻内页 <br nodeIndex="1533">
put_dirty_page(current,page,stack_base);//该页挂入进程空间 <br nodeIndex="1534">
} <br nodeIndex="1535">
stack_base += PAGE_SIZE; <br nodeIndex="1536">
} <br nodeIndex="1537">
up(&current->mm->mmap_sem); 
return 0; <br nodeIndex="1540">
}</p>
<p brd="1" nodeIndex="158"> <br nodeIndex="1541">
3.返回到load_elf_binary</p>
<p brd="1" nodeIndex="159">current->mm->start_stack = bprm->p;</p>
<p brd="1" nodeIndex="160">/* Try and get dynamic programs out of the way of the default mmap <br nodeIndex="1542">
base, as well as whatever program they might try to exec. This <br nodeIndex="1543">
is because the brk will follow the loader, and is not movable. */</p>
<p brd="1" nodeIndex="161">//普通可执行文件load_bias=0;动态链接库load_bias=0x8000 0000,即2G处(单独执行时,给ld-linux.so.2让路) <br nodeIndex="1544">
/* <br nodeIndex="1545">
例如/lib/ld-2.3.2.so执行时的maps如下 <br nodeIndex="1546">
[root@mail /proc/30019]# cat maps <br nodeIndex="1547">
80000000-80015000 r-xp 00000000 08:01 272070 /lib/ld-2.3.2.so <br nodeIndex="1548">
80015000-80016000 rw-p 00014000 08:01 272070 /lib/ld-2.3.2.so <br nodeIndex="1549">
bfffe000-c0000000 rwxp fffff000 00:00 0 <br nodeIndex="1550">
/lib/libc-2.3.2.so执行时的maps如下 <br nodeIndex="1551">
[root@mail /proc/30097]# cat /proc/14541/maps <br nodeIndex="1552">
40000000-40015000 r-xp 00000000 08:01 272070 /lib/ld-2.3.2.so <br nodeIndex="1553">
40015000-40016000 rw-p 00014000 08:01 272070 /lib/ld-2.3.2.so <br nodeIndex="1554">
80000000-80133000 r-xp 00000000 08:01 272077 /lib/libc-2.3.2.so <br nodeIndex="1555">
80133000-80137000 rw-p 00132000 08:01 272077 /lib/libc-2.3.2.so <br nodeIndex="1556">
80137000-80139000 rwxp 00000000 00:00 0 <br nodeIndex="1557">
bfffe000-c0000000 rwxp fffff000 00:00 0 <br nodeIndex="1558">
*/ <br nodeIndex="1559">
load_bias = ELF_PAGESTART(elf_ex.e_type==ET_DYN ? ELF_ET_DYN_BASE : 0);</p>
<p brd="1" nodeIndex="162">/* Now we do a little grungy work by mmaping the ELF image into <br nodeIndex="1560">
the correct location in memory. At this point, we assume that <br nodeIndex="1561">
the image should be loaded at fixed address, not at a variable <br nodeIndex="1562">
address. */</p>
<p brd="1" nodeIndex="163">old_fs = get_fs(); <br nodeIndex="1563">
set_fs(get_ds()); <br nodeIndex="1564">
for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) { <br nodeIndex="1565">
//处理每一个program headers <br nodeIndex="1566">
/* <br nodeIndex="1567">
typedef struct elf32_phdr{ <br nodeIndex="1568">
Elf32_Word p_type; <br nodeIndex="1569">
Elf32_Off p_offset;//该成员给出了该段的驻留位置相对于文件开始处的偏移。 <br nodeIndex="1570">
Elf32_Addr p_vaddr;//该成员给出了该段在内存中的首字节地址。(连接器推荐的加载基址) <br nodeIndex="1571">
Elf32_Addr p_paddr; <br nodeIndex="1572">
Elf32_Word p_filesz;//该成员给出了文件映像中该段的字节数；它可能是 0 。 <br nodeIndex="1573">
Elf32_Word p_memsz;//该成员给出了内存映像中该段的字节数；它可能是 0 。 <br nodeIndex="1574">
Elf32_Word p_flags;//该成员给出了和该段相关的标志。定义的标志值如下所述。 <br nodeIndex="1575">
Elf32_Word p_align; <br nodeIndex="1576">
} Elf32_Phdr; <br nodeIndex="1577">
*/ <br nodeIndex="1578">
int elf_prot = 0, elf_flags; <br nodeIndex="1579">
unsigned long vaddr;</p>
<p brd="1" nodeIndex="164">if (elf_ppnt->p_type != PT_LOAD)//必须是PT_LOAD <br nodeIndex="1580">
continue;</p>
<p brd="1" nodeIndex="165">if (elf_ppnt->p_flags & PF_R) elf_prot |= PROT_READ; <br nodeIndex="1581">
if (elf_ppnt->p_flags & PF_W) elf_prot |= PROT_WRITE; <br nodeIndex="1582">
if (elf_ppnt->p_flags & PF_X) elf_prot |= PROT_EXEC;</p>
<p brd="1" nodeIndex="166">elf_flags = MAP_PRIVATE|MAP_DENYWRITE|MAP_EXECUTABLE;</p>
<p brd="1" nodeIndex="167">vaddr = elf_ppnt->p_vaddr; <br nodeIndex="1583">
if (elf_ex.e_type == ET_EXEC || load_addr_set) { <br nodeIndex="1584">
//是可执行文件或者起始加载地址已设置 <br nodeIndex="1585">
elf_flags |= MAP_FIXED; <br nodeIndex="1586">
} <br nodeIndex="1587">
error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags); <br nodeIndex="1588">
//不判断出错 ??? <br nodeIndex="1589"></p>
<p brd="1" nodeIndex="168">/* <br nodeIndex="1590">
elf文件有两种视图，一种节表，是从程序编译连接的角度看。一种是程序头，是从程序执行的角度看。</p>
<p brd="1" nodeIndex="169">举例看看这两种视图的关系</p>
<p brd="1" nodeIndex="170">[root@mail /proc/30097]# readelf -l /bin/ls</p>
<p brd="1" nodeIndex="171">Elf file type is EXEC (Executable file) <br nodeIndex="1591">
Entry point 0x8049690 <br nodeIndex="1592">
There are 7 program headers, starting at offset 52</p>
<p brd="1" nodeIndex="172">Program Headers: <br nodeIndex="1593">
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align <br nodeIndex="1594">
PHDR 0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4 <br nodeIndex="1595">
INTERP 0x000114 0x08048114 0x08048114 0x00013 0x00013 R 0x1 <br nodeIndex="1596">
[Requesting program interpreter: /lib/ld-linux.so.2] <br nodeIndex="1597">
LOAD 0x000000 0x08048000 0x08048000 0x0fa98 0x0fa98 R E 0x1000 <br nodeIndex="1598">
LOAD 0x010000 0x08058000 0x08058000 0x00348 0x006c8 RW 0x1000 <br nodeIndex="1599">
DYNAMIC 0x010114 0x08058114 0x08058114 0x000d0 0x000d0 RW 0x4 <br nodeIndex="1600">
NOTE 0x000128 0x08048128 0x08048128 0x00020 0x00020 R 0x4 <br nodeIndex="1601">
GNU_EH_FRAME 0x00f960 0x08057960 0x08057960 0x0002c 0x0002c R 0x4</p>
<p brd="1" nodeIndex="173">Section to Segment mapping: <br nodeIndex="1602">
Segment Sections... <br nodeIndex="1603">
00 <br nodeIndex="1604">
01 .interp <br nodeIndex="1605">
02 .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata</p>
<p brd="1" nodeIndex="174">.eh_frame_hdr .eh_frame <br nodeIndex="1606">
03 .data .dynamic .ctors .dtors .jcr .got .bss <br nodeIndex="1607">
04 .dynamic <br nodeIndex="1608">
05 .note.ABI-tag <br nodeIndex="1609">
06 .eh_frame_hdr</p>
<p brd="1" nodeIndex="175">注意下面的Section to Segment mapping,说明了每个程序头包含了哪些节。我们关心的是代码段程序头和数据段程序头。 <br nodeIndex="1610">
LOAD 0x000000 0x08048000 0x08048000 0x0fa98 0x0fa98 R E 0x1000 <br nodeIndex="1611">
LOAD 0x010000 0x08058000 0x08058000 0x00348 0x006c8 RW 0x1000 <br nodeIndex="1612">
分别对应 <br nodeIndex="1613">
02 .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata</p>
<p brd="1" nodeIndex="176">.eh_frame_hdr .eh_frame <br nodeIndex="1614">
03 .data .dynamic .ctors .dtors .jcr .got .bss</p>
<p brd="1" nodeIndex="177">代码段开始文件地址是0,开始虚拟地址是0x8048000,文件大小是0xfa98，内存大小是0xfa98，flag是可读可执行，对齐大小是4k <br nodeIndex="1615">
数据段开始文件地址是0x10000,开始虚拟地址0x8058000,文件大小是0x348,内存大小是0x6c8，flag是可读可写，对齐大小是4</p>

<p brd="1" nodeIndex="179">下面列出节表 <br nodeIndex="1616">
[zws@mail /proc/1]$readelf -S /bin/ls <br nodeIndex="1617">
There are 26 section headers, starting at offset 0x10444:</p>
<p brd="1" nodeIndex="180">Section Headers: <br nodeIndex="1618">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="1619">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="1620">
[ 1] .interp PROGBITS 08048114 000114 000013 00 A 0 0 1 <br nodeIndex="1621">
[ 2] .note.ABI-tag NOTE 08048128 000128 000020 00 A 0 0 4 <br nodeIndex="1622">
[ 3] .hash HASH 08048148 000148 00028c 04 A 4 0 4 <br nodeIndex="1623">
[ 4] .dynsym DYNSYM 080483d4 0003d4 0005e0 10 A 5 1 4 <br nodeIndex="1624">
[ 5] .dynstr STRTAB 080489b4 0009b4 0003ea 00 A 0 0 1 <br nodeIndex="1625">
[ 6] .gnu.version VERSYM 08048d9e 000d9e 0000bc 02 A 4 0 2 <br nodeIndex="1626">
[ 7] .gnu.version_r VERNEED 08048e5c 000e5c 000070 00 A 5 1 4 <br nodeIndex="1627">
[ 8] .rel.dyn REL 08048ecc 000ecc 000028 08 A 4 0 4 <br nodeIndex="1628">
[ 9] .rel.plt REL 08048ef4 000ef4 000278 08 A 4 11 4 <br nodeIndex="1629">
[10] .init PROGBITS 0804916c 00116c 000017 00 AX 0 0 4 <br nodeIndex="1630">
[11] .plt PROGBITS 08049184 001184 000500 04 AX 0 0 4 <br nodeIndex="1631">
[12] .text PROGBITS 08049690 001690 00ab4c 00 AX 0 0 16 <br nodeIndex="1632">
[13] .fini PROGBITS 080541dc 00c1dc 00001b 00 AX 0 0 4 <br nodeIndex="1633">
[14] .rodata PROGBITS 08054200 00c200 003760 00 A 0 0 32 <br nodeIndex="1634">
[15] .eh_frame_hdr PROGBITS 08057960 00f960 00002c 00 A 0 0 4 <br nodeIndex="1635">
[16] .eh_frame PROGBITS 0805798c 00f98c 00010c 00 A 0 0 4 <br nodeIndex="1636">
[17] .data PROGBITS 08058000 010000 000114 00 WA 0 0 32 <br nodeIndex="1637">
[18] .dynamic DYNAMIC 08058114 010114 0000d0 08 WA 5 0 4 <br nodeIndex="1638">
[19] .ctors PROGBITS 080581e4 0101e4 000008 00 WA 0 0 4 <br nodeIndex="1639">
[20] .dtors PROGBITS 080581ec 0101ec 000008 00 WA 0 0 4 <br nodeIndex="1640">
[21] .jcr PROGBITS 080581f4 0101f4 000004 00 WA 0 0 4 <br nodeIndex="1641">
[22] .got PROGBITS 080581f8 0101f8 000150 04 WA 0 0 4 <br nodeIndex="1642">
[23] .bss NOBITS 08058360 010360 000368 00 WA 0 0 32 <br nodeIndex="1643">
[24] .gnu_debuglink PROGBITS 00000000 010360 000010 00 0 0 4 <br nodeIndex="1644">
[25] .shstrtab STRTAB 00000000 010370 0000d2 00 0 0 1 <br nodeIndex="1645">
Key to Flags: <br nodeIndex="1646">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="1647">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="1648">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="181">从开始文件地址和内存大小可看出 <br nodeIndex="1649">
代码段包含的节从[0]到[16],数据段包含的节从[17]到[23]，和前面的显示正好一致。</p>
<p brd="1" nodeIndex="182">由于内存映射以页为单位，映射起始地址向下对齐到页边界，映射大小向上对齐到页边界，因此在进行内存映射的时候, <br nodeIndex="1650">
代码段映射关系是虚拟地址[0x8048000,0x8048000+0x10000)->文件偏移[0,0x10000) <br nodeIndex="1651">
数据段映射关系是虚拟地址[0x8058000,0x1000)->文件偏移[0x10000,0x10000+0x1000)</p>
<p brd="1" nodeIndex="183">/bin/ls的文件大小是小于0x11000的,数据的映射超出了，不过没有关系，超出的部分会被当做零页分配。可见这个文件都被映</p>
<p brd="1" nodeIndex="184">射了。显然0x8048000就是这个文件镜像加载的起始地址，这个地址后面有用。</p>
<p brd="1" nodeIndex="185">我还注意到[23].bss节type是NOBITS，说明文件中没有对应内容，这从[24].gnu_debuglink的文件偏移和[23].bss的文件偏移相</p>
<p brd="1" nodeIndex="186">等侧面证明。但是它却是有大小的，0x368,Flag是WA,说明可写且需要分配。</p>
<p brd="1" nodeIndex="187">bss是未初始化节，程序中的未初始化变量都放在这个节中，由于未初始化变量的值默认都为0，因此也就不再文件中为其分配空</p>
<p brd="1" nodeIndex="188">间了。但是到了内存中就不同了，必须为其分配空间，且清0。这一点后面还会谈到。</p>
<p brd="1" nodeIndex="189">还有就是程序中的常量被放在.rodata节中，常量只能读，不能写，代码段是可读，可执行，因此.rodata节被插入在代码段中，没</p>
<p brd="1" nodeIndex="190">有创建额外的程序头了。</p>
<p brd="1" nodeIndex="191">可执行文件的一般从0x08000000(512M)开始编址,可执行文件加载时不重定位。 <br nodeIndex="1652">
动态链接库的一般从0开始编址.动态链接库加载时重定位，重定位地址从0x40000000(1G)开始。</p>
<p brd="1" nodeIndex="192">映射的时候，代码段只读映射该页，而数据段COW映射该页.因此虽然上面代码段和数据段是连续的，但是页属性是不同的。</p>
<p brd="1" nodeIndex="193"> <br nodeIndex="1653">
代码段和数据段在文件中的映射可能有重叠，例如 <br nodeIndex="1654">
[zws@mail ~]$ readelf -l /lib/libc-2.3.2.so</p>
<p brd="1" nodeIndex="194">Elf file type is DYN (Shared object file) <br nodeIndex="1655">
Entry point 0x159d0 <br nodeIndex="1656">
There are 7 program headers, starting at offset 52</p>
<p brd="1" nodeIndex="195">Program Headers: <br nodeIndex="1657">
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align <br nodeIndex="1658">
PHDR 0x000034 0x00000034 0x00000034 0x000e0 0x000e0 R E 0x4 <br nodeIndex="1659">
INTERP 0x1312f0 0x001312f0 0x001312f0 0x00013 0x00013 R 0x1 <br nodeIndex="1660">
[Requesting program interpreter: /lib/ld-linux.so.2] <br nodeIndex="1661">
LOAD 0x000000 0x00000000 0x00000000 0x132804 0x132804 R E 0x1000 <br nodeIndex="1662">
LOAD 0x132820 0x00133820 0x00133820 0x02c90 0x056c4 RW 0x1000 <br nodeIndex="1663">
DYNAMIC 0x1350d4 0x001360d4 0x001360d4 0x000d8 0x000d8 RW 0x4 <br nodeIndex="1664">
NOTE 0x000114 0x00000114 0x00000114 0x00020 0x00020 R 0x4 <br nodeIndex="1665">
GNU_EH_FRAME 0x131304 0x00131304 0x00131304 0x0032c 0x0032c R 0x4</p>
<p brd="1" nodeIndex="196">假设实际加载地址是x <br nodeIndex="1666">
代码段映射关系是虚拟地址[x+0,x+0+0x133000)->文件偏移[0,0x133000) <br nodeIndex="1667">
数据段映射关系是虚拟地址[x+0x133000,x+0x133000+0x6000)->文件偏移[0x132000,0x132000+0x3000)+零页[0x132000+</p>
<p brd="1" nodeIndex="197">0x3000,0x133000+0x6000)</p>
<p brd="1" nodeIndex="198">文件偏移有一页重叠，但这种重叠不会引起冲突和访问错误.</p>
<p brd="1" nodeIndex="199">总之，ELF文件的节和程序头关系紧密，其中暗藏玄机，值得细细揣摩。</p>

<p brd="1" nodeIndex="201">4.计算start_code,end_code等</p>
<p brd="1" nodeIndex="202"> <br nodeIndex="1668">
if (!load_addr_set) { <br nodeIndex="1669">
load_addr_set = 1; <br nodeIndex="1670">
//load_addr 计算整个镜像加载基址 <br nodeIndex="1671">
/* <br nodeIndex="1672">
load_bias load_addr <br nodeIndex="1673">
ET_EXEC 0x00000000 0x08048000 /bin/ls <br nodeIndex="1674">
ET_DYN 0x80000000 0x80000000 /lib/ld-linux.so.2 <br nodeIndex="1675">
*/ <br nodeIndex="1676">
load_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);//链接器推荐的镜像加载基址,对于可执</p>
<p brd="1" nodeIndex="203">行文件就是该地址，对于动态链接库，一般是0 <br nodeIndex="1677">
if (elf_ex.e_type == ET_DYN) {//load_bias是0x80000000 <br nodeIndex="1678">
load_bias += error -//动态链接库实际加载地址-内核推荐的加载地址=加载偏移(一般</p>
<p brd="1" nodeIndex="204">是0) <br nodeIndex="1679">
ELF_PAGESTART(load_bias + vaddr); <br nodeIndex="1680">
load_addr += error;//一般load_addr==error <br nodeIndex="1681">
} <br nodeIndex="1682">
} <br nodeIndex="1683">
k = elf_ppnt->p_vaddr;//通常代码段和数据段紧挨在一起，代码段在前，数据段在后 <br nodeIndex="1684">
if (k < start_code) start_code = k;//start_code 的初值为0xffffffff，定位代码段开始地址 <br nodeIndex="1685">
if (start_data < k) start_data = k;//start_data初值为0,定位数据段开始</p>
<p brd="1" nodeIndex="205">k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;//file size，不是mem size</p>
<p brd="1" nodeIndex="206">if (k > elf_bss)//elf_bss初值为0 <br nodeIndex="1686">
elf_bss = k;//计算bss起始地址 <br nodeIndex="1687">
if ((elf_ppnt->p_flags & PF_X) && end_code < k) <br nodeIndex="1688">
end_code = k;//代码段结束地址 <br nodeIndex="1689">
if (end_data < k) <br nodeIndex="1690">
end_data = k;//数据段结束地址 <br nodeIndex="1691">
k = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;//mem size <br nodeIndex="1692">
if (k > elf_brk) <br nodeIndex="1693">
elf_brk = k; <br nodeIndex="1694">
//[elf_bss,elf_brk)之间是bss section <br nodeIndex="1695">
} <br nodeIndex="1696">
set_fs(old_fs);</p>
<p brd="1" nodeIndex="207">//全部重定位 <br nodeIndex="1697">
elf_entry += load_bias; <br nodeIndex="1698">
elf_bss += load_bias;//bss为初始化段开始 <br nodeIndex="1699">
elf_brk += load_bias;//brk动态内存分配起始地址 <br nodeIndex="1700">
start_code += load_bias; <br nodeIndex="1701">
end_code += load_bias; <br nodeIndex="1702">
start_data += load_bias; <br nodeIndex="1703">
end_data += load_bias;</p>
<p brd="1" nodeIndex="208">if (elf_interpreter) { <br nodeIndex="1704">
//elf_entry被覆盖 <br nodeIndex="1705">
if (interpreter_type == INTERPRETER_AOUT) <br nodeIndex="1706">
elf_entry = load_aout_interp(&interp_ex, <br nodeIndex="1707">
interpreter); <br nodeIndex="1708">
else <br nodeIndex="1709">
elf_entry = load_elf_interp(&interp_elf_ex, <br nodeIndex="1710">
interpreter, <br nodeIndex="1711">
&interp_load_addr);</p>
<p brd="1" nodeIndex="209">5.load_elf_interp</p>
<p brd="1" nodeIndex="210"> <br nodeIndex="1712">
/* This is much more generalized than the library routine read function, <br nodeIndex="1713">
so we keep this separate. Technically the library read function <br nodeIndex="1714">
is only provided so that we can read a.out libraries that have <br nodeIndex="1715">
an ELF header */</p>
<p brd="1" nodeIndex="211">static unsigned long load_elf_interp(struct elfhdr * interp_elf_ex, <br nodeIndex="1716">
struct file * interpreter, <br nodeIndex="1717">
unsigned long *interp_load_addr) <br nodeIndex="1718">
{ <br nodeIndex="1719">
struct elf_phdr *elf_phdata; <br nodeIndex="1720">
struct elf_phdr *eppnt; <br nodeIndex="1721">
unsigned long load_addr = 0; <br nodeIndex="1722">
int load_addr_set = 0; <br nodeIndex="1723">
unsigned long last_bss = 0, elf_bss = 0; <br nodeIndex="1724">
unsigned long error = ~0UL; <br nodeIndex="1725">
int retval, i, size;</p>
<p brd="1" nodeIndex="212">/* First of all, some simple consistency checks */ <br nodeIndex="1726">
if (interp_elf_ex->e_type != ET_EXEC && <br nodeIndex="1727">
interp_elf_ex->e_type != ET_DYN) <br nodeIndex="1728">
goto out; <br nodeIndex="1729">
if (!elf_check_arch(interp_elf_ex)) <br nodeIndex="1730">
goto out; <br nodeIndex="1731">
if (!interpreter->f_op || !interpreter->f_op->mmap) <br nodeIndex="1732">
goto out;</p>
<p brd="1" nodeIndex="213">/* <br nodeIndex="1733">
* If the size of this structure has changed, then punt, since <br nodeIndex="1734">
* we will be doing the wrong thing. <br nodeIndex="1735">
*/ <br nodeIndex="1736">
if (interp_elf_ex->e_phentsize != sizeof(struct elf_phdr)) <br nodeIndex="1737">
goto out;</p>
<p brd="1" nodeIndex="214">/* Now read in all of the header information */</p>
<p brd="1" nodeIndex="215">size = sizeof(struct elf_phdr) * interp_elf_ex->e_phnum; <br nodeIndex="1738">
if (size > ELF_MIN_ALIGN) <br nodeIndex="1739">
goto out; <br nodeIndex="1740">
elf_phdata = (struct elf_phdr *) kmalloc(size, GFP_KERNEL); <br nodeIndex="1741">
if (!elf_phdata) <br nodeIndex="1742">
goto out;</p>
<p brd="1" nodeIndex="216">//读入interp的prgoram header <br nodeIndex="1743">
retval = kernel_read(interpreter,interp_elf_ex->e_phoff,(char *)elf_phdata,size); <br nodeIndex="1744">
error = retval; <br nodeIndex="1745">
if (retval < 0) <br nodeIndex="1746">
goto out_close;</p>
<p brd="1" nodeIndex="217">eppnt = elf_phdata; <br nodeIndex="1747">
for (i=0; i<interp_elf_ex->e_phnum; i++, eppnt++) { <br nodeIndex="1748">
if (eppnt->p_type == PT_LOAD) { <br nodeIndex="1749">
int elf_type = MAP_PRIVATE | MAP_DENYWRITE; <br nodeIndex="1750">
int elf_prot = 0; <br nodeIndex="1751">
unsigned long vaddr = 0; <br nodeIndex="1752">
unsigned long k, map_addr;</p>
<p brd="1" nodeIndex="218">if (eppnt->p_flags & PF_R) elf_prot = PROT_READ; <br nodeIndex="1753">
if (eppnt->p_flags & PF_W) elf_prot |= PROT_WRITE; <br nodeIndex="1754">
if (eppnt->p_flags & PF_X) elf_prot |= PROT_EXEC; <br nodeIndex="1755">
vaddr = eppnt->p_vaddr; <br nodeIndex="1756">
if (interp_elf_ex->e_type == ET_EXEC || load_addr_set) <br nodeIndex="1757">
elf_type |= MAP_FIXED; <br nodeIndex="1758">
/* <br nodeIndex="1759">
readelf -l /lib/ld-linux.so.2</p>
<p brd="1" nodeIndex="219">Program Headers: <br nodeIndex="1760">
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align <br nodeIndex="1761">
LOAD 0x000000 0x00000000 0x00000000 0x15229 0x15229 R E 0x1000 <br nodeIndex="1762">
LOAD 0x015240 0x00016240 0x00016240 0x00300 0x00758 RW 0x1000 <br nodeIndex="1763">
DYNAMIC 0x015490 0x00016490 0x00016490 0x000b0 0x000b0 RW 0x4</p>
<p brd="1" nodeIndex="220">load_addr + vaddr=0,mmap将从1G处开始处映射 <br nodeIndex="1764">
*/</p>
<p brd="1" nodeIndex="221">map_addr = elf_map(interpreter, load_addr + vaddr, eppnt, elf_prot, elf_type);</p>
<p brd="1" nodeIndex="222">if (!load_addr_set && interp_elf_ex->e_type == ET_DYN) { <br nodeIndex="1765">
//只计算ET_DYN <br nodeIndex="1766">
load_addr = map_addr - ELF_PAGESTART(vaddr); <br nodeIndex="1767">
load_addr_set = 1; <br nodeIndex="1768">
}</p>
<p brd="1" nodeIndex="223">/* <br nodeIndex="1769">
* Find the end of the file mapping for this phdr, and keep <br nodeIndex="1770">
* track of the largest address we see for this. <br nodeIndex="1771">
*/ <br nodeIndex="1772">
k = load_addr + eppnt->p_vaddr + eppnt->p_filesz; <br nodeIndex="1773">
if (k > elf_bss)//elf bss <br nodeIndex="1774">
elf_bss = k;</p>
<p brd="1" nodeIndex="224">/* <br nodeIndex="1775">
* Do the same thing for the memory mapping - between <br nodeIndex="1776">
* elf_bss and last_bss is the bss section. <br nodeIndex="1777">
[elf_bss,last_bss)是bss section <br nodeIndex="1778">
*/ <br nodeIndex="1779">
k = load_addr + eppnt->p_memsz + eppnt->p_vaddr; <br nodeIndex="1780">
if (k > last_bss)//last bss <br nodeIndex="1781">
last_bss = k; <br nodeIndex="1782">
} <br nodeIndex="1783">
}</p>
<p brd="1" nodeIndex="225">/* Now use mmap to map the library into memory. */</p>
<p brd="1" nodeIndex="226">/* <br nodeIndex="1784">
* Now fill out the bss section. First pad the last page up <br nodeIndex="1785">
* to the page boundary, and then perform a mmap to make sure <br nodeIndex="1786">
* that there are zero-mapped pages up to and including the <br nodeIndex="1787">
* last bss page. <br nodeIndex="1788">
*/ <br nodeIndex="1789">
padzero(elf_bss);//清bss <br nodeIndex="1790">
elf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1); /* What we have mapped so far */</p>
<p brd="1" nodeIndex="227">/* Map the last of the bss segment */ <br nodeIndex="1791">
if (last_bss > elf_bss)//未映射到文件的部分,分配0页 <br nodeIndex="1792">
do_brk(elf_bss, last_bss - elf_bss);//匿名映射[addr,addr+len)</p>
<p brd="1" nodeIndex="228">*interp_load_addr = load_addr;//镜像加载基址 <br nodeIndex="1793">
error = ((unsigned long) interp_elf_ex->e_entry) + load_addr;//入口地址</p>
<p brd="1" nodeIndex="229">out_close: <br nodeIndex="1794">
kfree(elf_phdata); <br nodeIndex="1795">
out: <br nodeIndex="1796">
return error; <br nodeIndex="1797">
}</p>
<p brd="1" nodeIndex="230"> <br nodeIndex="1798">
6.返回load_elf_binary</p>
<p brd="1" nodeIndex="231">allow_write_access(interpreter); <br nodeIndex="1799">
fput(interpreter); <br nodeIndex="1800">
kfree(elf_interpreter);</p>
<p brd="1" nodeIndex="232">if (elf_entry == ~0UL) { <br nodeIndex="1801">
printk(KERN_ERR "Unable to load interpreter\n"); <br nodeIndex="1802">
kfree(elf_phdata); <br nodeIndex="1803">
send_sig(SIGSEGV, current, 0); <br nodeIndex="1804">
return 0; <br nodeIndex="1805">
} <br nodeIndex="1806">
}</p>
<p brd="1" nodeIndex="233">kfree(elf_phdata);</p>
<p brd="1" nodeIndex="234">if (interpreter_type != INTERPRETER_AOUT) <br nodeIndex="1807">
sys_close(elf_exec_fileno);//ELF不需要</p>
<p brd="1" nodeIndex="235">set_binfmt(&elf_format);</p>
<p brd="1" nodeIndex="236">compute_creds(bprm); <br nodeIndex="1808">
current->flags &= ~PF_FORKNOEXEC; <br nodeIndex="1809">
//注意bprm->p被更新,指向argc地址 <br nodeIndex="1810">
bprm->p = (unsigned long) <br nodeIndex="1811">
create_elf_tables((char *)bprm->p, <br nodeIndex="1812">
bprm->argc, <br nodeIndex="1813">
bprm->envc, <br nodeIndex="1814">
(interpreter_type == INTERPRETER_ELF ? &elf_ex : NULL), <br nodeIndex="1815">
load_addr, load_bias, <br nodeIndex="1816">
interp_load_addr, <br nodeIndex="1817">
(interpreter_type == INTERPRETER_AOUT ? 0 : 1));</p>
<p brd="1" nodeIndex="237">7.create_elf_tables</p>
<p brd="1" nodeIndex="238"> <br nodeIndex="1818">
static elf_addr_t * <br nodeIndex="1819">
create_elf_tables(char *p, int argc, int envc, <br nodeIndex="1820">
struct elfhdr * exec, <br nodeIndex="1821">
unsigned long load_addr, <br nodeIndex="1822">
unsigned long load_bias, <br nodeIndex="1823">
unsigned long interp_load_addr, int ibcs) <br nodeIndex="1824">
{ <br nodeIndex="1825">
elf_caddr_t *argv; <br nodeIndex="1826">
elf_caddr_t *envp; <br nodeIndex="1827">
elf_addr_t *sp, *csp; <br nodeIndex="1828">
char *k_platform, *u_platform; <br nodeIndex="1829">
long hwcap; <br nodeIndex="1830">
size_t platform_len = 0;</p>
<p brd="1" nodeIndex="239">/* <br nodeIndex="1831">
* Get hold of platform and hardware capabilities masks for <br nodeIndex="1832">
* the machine we are running on. In some cases (Sparc), <br nodeIndex="1833">
* this info is impossible to get, in others (i386) it is <br nodeIndex="1834">
* merely difficult. <br nodeIndex="1835">
*/</p>
<p brd="1" nodeIndex="240">hwcap = ELF_HWCAP;//CPU特性描述字 <br nodeIndex="1836">
k_platform = ELF_PLATFORM;//CPU类型名 例如i686</p>
<p brd="1" nodeIndex="241">//p指向argv字符串首地址 即下面的0xbffffc07处 <br nodeIndex="1837">
/* <br nodeIndex="1838">
0xbffffc02: "i686" <br nodeIndex="1839">
0xbffffc07: "/root/3/88" <br nodeIndex="1840">
0xbffffc12: "PWD=/root" <br nodeIndex="1841">
0xbffffc1c: "HOSTNAME=proxy" <br nodeIndex="1842">
0xbffffc2b: "QTDIR=/usr/lib/qt-2.3.1" <br nodeIndex="1843">
0xbffffc43: "LESSOPEN=|/usr/bin/lesspipe.sh %s" <br nodeIndex="1844">
0xbffffc65: "KDEDIR=/usr" <br nodeIndex="1845">
*/ <br nodeIndex="1846">
if (k_platform) {//一般不为空 <br nodeIndex="1847">
platform_len = strlen(k_platform) + 1; <br nodeIndex="1848">
u_platform = p - platform_len; <br nodeIndex="1849">
__copy_to_user(u_platform, k_platform, platform_len);//i686 <br nodeIndex="1850">
} else <br nodeIndex="1851">
u_platform = p;</p>
<p brd="1" nodeIndex="242">/* <br nodeIndex="1852">
* Force 16 byte _final_ alignment here for generality. <br nodeIndex="1853">
* Leave an extra 16 bytes free so that on the PowerPC we <br nodeIndex="1854">
* can move the aux table up to start on a 16-byte boundary. <br nodeIndex="1855">
*/ <br nodeIndex="1856">
//向低地址方向对齐到16字节边界，再减16字节 <br nodeIndex="1857">
//较新的内核使用一个随机数，因此布局有所不同 <br nodeIndex="1858">
sp = (elf_addr_t *)((~15UL & (unsigned long)(u_platform)) - 16UL); <br nodeIndex="1859">
csp = sp; <br nodeIndex="1860">
//DLINFO -> 动态链接信息?? 这些信息是为ld.so准备的，ld.so需要用到 <br nodeIndex="1861">
csp -= ((exec ? DLINFO_ITEMS*2 : 4) + (k_platform ? 2 : 0));//DLINFO_ITEMS*2 + 2,DLINFO_ITEMS定义为13 <br nodeIndex="1862">
csp -= envc+1; <br nodeIndex="1863">
csp -= argc+1; <br nodeIndex="1864">
//ibcs 0->a.out 1->elf <br nodeIndex="1865">
csp -= (!ibcs ? 3 : 1);// 1-> argc /* argc itself */ <br nodeIndex="1866">
if ((unsigned long)csp & 15UL)//不与16字节边界对齐 <br nodeIndex="1867">
//下移sp,使argc对齐到16字节边界 <br nodeIndex="1868">
sp -= ((unsigned long)csp & 15UL) / sizeof(*sp); <br nodeIndex="1869">
/* <br nodeIndex="1870">
内存布局如下 <br nodeIndex="1871">
position content size (bytes) + comment <br nodeIndex="1872">
------------------------------------------------------------------------ <br nodeIndex="1873">
stack pointer -> [ argc = number of args ] 4 <br nodeIndex="1874">
[ argv[0] (pointer) ] 4 (program name) <br nodeIndex="1875">
[ argv[1] (pointer) ] 4 <br nodeIndex="1876">
[ argv[..] (pointer) ] 4 * x <br nodeIndex="1877">
[ argv[n - 1] (pointer) ] 4 <br nodeIndex="1878">
[ argv[n] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="243">[ envp[0] (pointer) ] 4 <br nodeIndex="1879">
[ envp[1] (pointer) ] 4 <br nodeIndex="1880">
[ envp[..] (pointer) ] 4 <br nodeIndex="1881">
[ envp[term] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="244">[ auxv[0] AT_PHDR (Elf32_auxv_t) ] 8 <br nodeIndex="1882">
[ auxv[1] AT_PHENT (Elf32_auxv_t) ] 8 <br nodeIndex="1883">
[ auxv[2] AT_PHNUM (Elf32_auxv_t) ] 8 <br nodeIndex="1884">
[ auxv[3] AT_BASE (Elf32_auxv_t) ] 8 <br nodeIndex="1885">
[ auxv[4] AT_FLAGS (Elf32_auxv_t) ] 8 <br nodeIndex="1886">
[ auxv[5] AT_ENTRY (Elf32_auxv_t) ] 8 <br nodeIndex="1887">
[ auxv[6] AT_UID (Elf32_auxv_t) ] 8 <br nodeIndex="1888">
[ auxv[7] AT_EUID (Elf32_auxv_t) ] 8 <br nodeIndex="1889">
[ auxv[8] AT_GID (Elf32_auxv_t) ] 8 <br nodeIndex="1890">
[ auxv[9] AT_EGID (Elf32_auxv_t) ] 8 <br nodeIndex="1891">
[ auxv[10] AT_HWCAP (Elf32_auxv_t) ] 8 <br nodeIndex="1892">
[ auxv[11] AT_PAGESZ (Elf32_auxv_t) ] 8 <br nodeIndex="1893">
[ auxv[12] AT_CLKTCK (Elf32_auxv_t) ] 8 <br nodeIndex="1894">
[ auxv[13] AT_PLATFORM (Elf32_auxv_t) ] 8 <br nodeIndex="1895">
[ auxv[14] (Elf32_auxv_t) ] 8 (= AT_NULL vector)</p>
<p brd="1" nodeIndex="245">[ padding ] 0 - 15 <br nodeIndex="1896">
[ padding ] 16 <br nodeIndex="1897">
[ padding ] 0 - 15</p>
<p brd="1" nodeIndex="246">[k_platform] 0 - 65 <br nodeIndex="1898">
[ argument ASCIIZ strings ] >= 0 <br nodeIndex="1899">
[ environment ASCIIZ str. ] >= 0 <br nodeIndex="1900">
[filename] >=0</p>
<p brd="1" nodeIndex="247">(0xbffffffc) [ end marker ] 4 (= NULL)</p>
<p brd="1" nodeIndex="248">(0xc0000000) < top of stack > 0 (virtual) <br nodeIndex="1901">
*/ <br nodeIndex="1902">
/* <br nodeIndex="1903">
* Put the ELF interpreter info on the stack <br nodeIndex="1904">
*/ <br nodeIndex="1905">
#define NEW_AUX_ENT(nr, id, val) \ <br nodeIndex="1906">
__put_user ((id), sp+(nr*2)); \ <br nodeIndex="1907">
__put_user ((val), sp+(nr*2+1)); \ <br nodeIndex="1908">
//开始存放辅助向量 <br nodeIndex="1909">
sp -= 2; <br nodeIndex="1910">
NEW_AUX_ENT(0, AT_NULL, 0);//end of vector <br nodeIndex="1911">
if (k_platform) { <br nodeIndex="1912">
sp -= 2; <br nodeIndex="1913">
NEW_AUX_ENT(0, AT_PLATFORM, (elf_addr_t)(unsigned long) u_platform); <br nodeIndex="1914">
} <br nodeIndex="1915">
sp -= 3*2; <br nodeIndex="1916">
NEW_AUX_ENT(0, AT_HWCAP, hwcap); <br nodeIndex="1917">
NEW_AUX_ENT(1, AT_PAGESZ, ELF_EXEC_PAGESIZE);// 4096 <br nodeIndex="1918">
NEW_AUX_ENT(2, AT_CLKTCK, CLOCKS_PER_SEC);// 100</p>
<p brd="1" nodeIndex="249">if (exec) {//elf interp <br nodeIndex="1919">
sp -= 10*2;</p>
<p brd="1" nodeIndex="250">NEW_AUX_ENT(0, AT_PHDR, load_addr + exec->e_phoff); <br nodeIndex="1920">
NEW_AUX_ENT(1, AT_PHENT, sizeof (struct elf_phdr)); <br nodeIndex="1921">
NEW_AUX_ENT(2, AT_PHNUM, exec->e_phnum); <br nodeIndex="1922">
NEW_AUX_ENT(3, AT_BASE, interp_load_addr);//interp加载基址,如果就是/lib/ld-linux.so.2或静态链</p>
<p brd="1" nodeIndex="251">接可执行文件，则为0 <br nodeIndex="1923">
NEW_AUX_ENT(4, AT_FLAGS, 0); <br nodeIndex="1924">
NEW_AUX_ENT(5, AT_ENTRY, load_bias + exec->e_entry);//原程序入口 <br nodeIndex="1925">
NEW_AUX_ENT(6, AT_UID, (elf_addr_t) current->uid); <br nodeIndex="1926">
NEW_AUX_ENT(7, AT_EUID, (elf_addr_t) current->euid); <br nodeIndex="1927">
NEW_AUX_ENT(8, AT_GID, (elf_addr_t) current->gid); <br nodeIndex="1928">
NEW_AUX_ENT(9, AT_EGID, (elf_addr_t) current->egid); <br nodeIndex="1929">
} <br nodeIndex="1930">
#undef NEW_AUX_ENT</p>
<p brd="1" nodeIndex="252">sp -= envc+1; <br nodeIndex="1931">
envp = (elf_caddr_t *) sp; <br nodeIndex="1932">
sp -= argc+1; <br nodeIndex="1933">
argv = (elf_caddr_t *) sp; <br nodeIndex="1934">
if (!ibcs) {//a.out <br nodeIndex="1935">
__put_user((elf_addr_t)(unsigned long) envp,--sp); <br nodeIndex="1936">
__put_user((elf_addr_t)(unsigned long) argv,--sp); <br nodeIndex="1937">
} <br nodeIndex="1938">
//处理argv数组 <br nodeIndex="1939">
__put_user((elf_addr_t)argc,--sp);//argc入栈 <br nodeIndex="1940">
current->mm->arg_start = (unsigned long) p;//arg_start <br nodeIndex="1941">
while (argc-->0) { <br nodeIndex="1942">
__put_user((elf_caddr_t)(unsigned long)p,argv++); <br nodeIndex="1943">
p += strlen_user(p);//计算下一个字符串的长度，更新p <br nodeIndex="1944">
} <br nodeIndex="1945">
__put_user(NULL, argv); <br nodeIndex="1946">
//处理envp数组 <br nodeIndex="1947">
current->mm->arg_end = current->mm->env_start = (unsigned long) p; <br nodeIndex="1948">
while (envc-->0) { <br nodeIndex="1949">
__put_user((elf_caddr_t)(unsigned long)p,envp++); <br nodeIndex="1950">
p += strlen_user(p); <br nodeIndex="1951">
} <br nodeIndex="1952">
__put_user(NULL, envp); <br nodeIndex="1953">
current->mm->env_end = (unsigned long) p; <br nodeIndex="1954">
return sp;//返回argc地址 <br nodeIndex="1955">
}</p>
<p brd="1" nodeIndex="253"> <br nodeIndex="1956">
8.返回load_elf_binary</p>
<p brd="1" nodeIndex="254">/* N.B. passed_fileno might not be initialized? */ <br nodeIndex="1957">
if (interpreter_type == INTERPRETER_AOUT) <br nodeIndex="1958">
current->mm->arg_start += strlen(passed_fileno) + 1;//多了passed_fileno参数 <br nodeIndex="1959">
current->mm->start_brk = current->mm->brk = elf_brk;//动态分配内存起始地址 <br nodeIndex="1960">
current->mm->end_code = end_code; <br nodeIndex="1961">
current->mm->start_code = start_code; <br nodeIndex="1962">
current->mm->start_data = start_data; <br nodeIndex="1963">
current->mm->end_data = end_data; <br nodeIndex="1964">
current->mm->start_stack = bprm->p;</p>
<p brd="1" nodeIndex="255">/* Calling set_brk effectively mmaps the pages that we need <br nodeIndex="1965">
* for the bss and break sections <br nodeIndex="1966">
*/ <br nodeIndex="1967">
set_brk(elf_bss, elf_brk);//elf_bss上取整</p>
<p brd="1" nodeIndex="256">9.set_brk</p>
<p brd="1" nodeIndex="257">static void set_brk(unsigned long start, unsigned long end) <br nodeIndex="1968">
{ <br nodeIndex="1969">
start = ELF_PAGEALIGN(start);//上取整到页边界 <br nodeIndex="1970">
end = ELF_PAGEALIGN(end); <br nodeIndex="1971">
if (end <= start) <br nodeIndex="1972">
return; <br nodeIndex="1973">
do_brk(start, end - start); <br nodeIndex="1974">
}</p>
<p brd="1" nodeIndex="258"> <br nodeIndex="1975">
10.返回load_elf_binary <br nodeIndex="1976">
padzero(elf_bss);//对最后一映射文件的页中的bss清零</p>
<p brd="1" nodeIndex="259">#if 0 <br nodeIndex="1977">
printk("(start_brk) %lx\n" , (long) current->mm->start_brk); <br nodeIndex="1978">
printk("(end_code) %lx\n" , (long) current->mm->end_code); <br nodeIndex="1979">
printk("(start_code) %lx\n" , (long) current->mm->start_code); <br nodeIndex="1980">
printk("(start_data) %lx\n" , (long) current->mm->start_data); <br nodeIndex="1981">
printk("(end_data) %lx\n" , (long) current->mm->end_data); <br nodeIndex="1982">
printk("(start_stack) %lx\n" , (long) current->mm->start_stack); <br nodeIndex="1983">
printk("(brk) %lx\n" , (long) current->mm->brk); <br nodeIndex="1984">
#endif</p>
<p brd="1" nodeIndex="260">if ( current->personality == PER_SVR4 ) <br nodeIndex="1985">
{ <br nodeIndex="1986">
/* Why this, you ask??? Well SVr4 maps page 0 as read-only, <br nodeIndex="1987">
and some applications "depend" upon this behavior. <br nodeIndex="1988">
Since we do not have the power to recompile these, we <br nodeIndex="1989">
emulate the SVr4 behavior. Sigh. */ <br nodeIndex="1990">
/* N.B. Shouldn't the size here be PAGE_SIZE?? */ <br nodeIndex="1991">
down(&current->mm->mmap_sem); <br nodeIndex="1992">
error = do_mmap(NULL, 0, 4096, PROT_READ | PROT_EXEC, <br nodeIndex="1993">
MAP_FIXED | MAP_PRIVATE, 0); <br nodeIndex="1994">
up(&current->mm->mmap_sem); <br nodeIndex="1995">
}</p>
<p brd="1" nodeIndex="261">#ifdef ELF_PLAT_INIT <br nodeIndex="1996">
/* <br nodeIndex="1997">
* The ABI may specify that certain registers be set up in special <br nodeIndex="1998">
* ways (on i386 %edx is the address of a DT_FINI function, for <br nodeIndex="1999">
* example. This macro performs whatever initialization to <br nodeIndex="2000">
* the regs structure is required. <br nodeIndex="2001">
*/ <br nodeIndex="2002">
ELF_PLAT_INIT(regs);//清空所有寄存器 <br nodeIndex="2003">
#endif <br nodeIndex="2004">
/* <br nodeIndex="2005">
#define ELF_PLAT_INIT(_r) do { \ <br nodeIndex="2006">
_r->ebx = 0; _r->ecx = 0; _r->edx = 0; \ <br nodeIndex="2007">
_r->esi = 0; _r->edi = 0; _r->ebp = 0; \ <br nodeIndex="2008">
_r->eax = 0; \ <br nodeIndex="2009">
} while (0) <br nodeIndex="2010">
*/</p>
<p brd="1" nodeIndex="262">start_thread(regs, elf_entry, bprm->p);//一般此处的elf_entry是interp的entry</p>
<p brd="1" nodeIndex="263">11.start_thread</p>
<p brd="1" nodeIndex="264">//清fs,gs <br nodeIndex="2011">
#define start_thread(regs, new_eip, new_esp) do { \ <br nodeIndex="2012">
__asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0)); \ <br nodeIndex="2013">
set_fs(USER_DS); \ <br nodeIndex="2014">
regs->xds = __USER_DS; \ <br nodeIndex="2015">
regs->xes = __USER_DS; \ <br nodeIndex="2016">
regs->xss = __USER_DS; \ <br nodeIndex="2017">
regs->xcs = __USER_CS; \ <br nodeIndex="2018">
regs->eip = new_eip;/*设置eip,一般指向ld-linux.so.2的入口*/ \ <br nodeIndex="2019">
regs->esp = new_esp;/*设置esp,指向argc地址*/ \ <br nodeIndex="2020">
} while (0)</p>
<p brd="1" nodeIndex="265">12.返回load_elf_binary</p>
<p brd="1" nodeIndex="266">if (current->ptrace & PT_PTRACED) <br nodeIndex="2021">
send_sig(SIGTRAP, current, 0);//如果进程被调试，通知父进程 <br nodeIndex="2022">
retval = 0; <br nodeIndex="2023">
out: <br nodeIndex="2024">
return retval;</p>
<p brd="1" nodeIndex="267">/* error cleanup */ <br nodeIndex="2025">
out_free_dentry: <br nodeIndex="2026">
allow_write_access(interpreter); <br nodeIndex="2027">
fput(interpreter); <br nodeIndex="2028">
out_free_interp: <br nodeIndex="2029">
if (elf_interpreter) <br nodeIndex="2030">
kfree(elf_interpreter); <br nodeIndex="2031">
out_free_file: <br nodeIndex="2032">
sys_close(elf_exec_fileno); <br nodeIndex="2033">
out_free_ph: <br nodeIndex="2034">
kfree(elf_phdata); <br nodeIndex="2035">
goto out; <br nodeIndex="2036">
}</p>
<p nodeIndex="268">ld.so分析4 PIC,GOT和PLT</p>
<p brd="1" nodeIndex="269">1.PIC</p>
<p brd="1" nodeIndex="270">PIC就是Position Independent Code(位置无关代码).那么何谓位置无关代码?</p>
<p brd="1" nodeIndex="271">如果代码不需要被重定位，那么这种代码就是位置无关的。</p>
<p brd="1" nodeIndex="272">我们要区分位置无关代码和可重入代码(Reentry Code)的不同，两者是无关的概念,不能混淆。</p>
<p brd="1" nodeIndex="273">例如 <br nodeIndex="2037">
int f() <br nodeIndex="2038">
{ <br nodeIndex="2039">
return 1; <br nodeIndex="2040">
}</p>
<p brd="1" nodeIndex="274">[zws@mail ~]$gcc -S x.c <br nodeIndex="2041">
[zws@mail ~]$cat x.s <br nodeIndex="2042">
.file "x.c" <br nodeIndex="2043">
.text <br nodeIndex="2044">
.globl f <br nodeIndex="2045">
.type f,@function <br nodeIndex="2046">
f: <br nodeIndex="2047">
pushl %ebp <br nodeIndex="2048">
movl %esp, %ebp <br nodeIndex="2049">
movl $1, %eax <br nodeIndex="2050">
leave <br nodeIndex="2051">
ret <br nodeIndex="2052">
.Lfe1: <br nodeIndex="2053">
.size f,.Lfe1-f <br nodeIndex="2054">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="275">这是PIC也是RC</p>
<p brd="1" nodeIndex="276">char * f() <br nodeIndex="2055">
{ <br nodeIndex="2056">
return "a"; <br nodeIndex="2057">
}</p>
<p brd="1" nodeIndex="277">[zws@mail ~]$gcc -S x.c <br nodeIndex="2058">
[zws@mail ~]$cat x.s <br nodeIndex="2059">
.file "x.c" <br nodeIndex="2060">
.section .rodata <br nodeIndex="2061">
.LC0: <br nodeIndex="2062">
.string "a" <br nodeIndex="2063">
.text <br nodeIndex="2064">
.globl f <br nodeIndex="2065">
.type f,@function <br nodeIndex="2066">
f: <br nodeIndex="2067">
pushl %ebp <br nodeIndex="2068">
movl %esp, %ebp <br nodeIndex="2069">
movl $.LC0, %eax <br nodeIndex="2070">
leave <br nodeIndex="2071">
ret <br nodeIndex="2072">
.Lfe1: <br nodeIndex="2073">
.size f,.Lfe1-f <br nodeIndex="2074">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="278">这不是PIC但是是RC</p>
<p brd="1" nodeIndex="279">int f() <br nodeIndex="2075">
{ <br nodeIndex="2076">
static int a=0; <br nodeIndex="2077">
a++; <br nodeIndex="2078">
return a; <br nodeIndex="2079">
} <br nodeIndex="2080">
[zws@mail ~]$gcc -S x.c <br nodeIndex="2081">
[zws@mail ~]$cat x.s <br nodeIndex="2082">
.file "x.c" <br nodeIndex="2083">
.data <br nodeIndex="2084">
.align 4 <br nodeIndex="2085">
.type a.0,@object <br nodeIndex="2086">
.size a.0,4 <br nodeIndex="2087">
a.0: <br nodeIndex="2088">
.long 0 <br nodeIndex="2089">
.text <br nodeIndex="2090">
.globl f <br nodeIndex="2091">
.type f,@function <br nodeIndex="2092">
f: <br nodeIndex="2093">
pushl %ebp <br nodeIndex="2094">
movl %esp, %ebp <br nodeIndex="2095">
incl a.0 <br nodeIndex="2096">
movl a.0, %eax <br nodeIndex="2097">
leave <br nodeIndex="2098">
ret <br nodeIndex="2099">
.Lfe1: <br nodeIndex="2100">
.size f,.Lfe1-f <br nodeIndex="2101">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="280">两者都不是</p>
<p brd="1" nodeIndex="281">将上面的汇编语言改成PIC</p>
<p brd="1" nodeIndex="282">[zws@mail ~]$cat x.s <br nodeIndex="2102">
.file "x.c" <br nodeIndex="2103">
.data <br nodeIndex="2104">
.align 4 <br nodeIndex="2105">
.type a.0,@object <br nodeIndex="2106">
.size a.0,4 <br nodeIndex="2107">
a.0: <br nodeIndex="2108">
.long 0 <br nodeIndex="2109">
.text <br nodeIndex="2110">
.globl f <br nodeIndex="2111">
.type f,@function <br nodeIndex="2112">
f: <br nodeIndex="2113">
pushl %ebp <br nodeIndex="2114">
movl %esp, %ebp <br nodeIndex="2115">
pushl %ebx <br nodeIndex="2116">
call .L2 <br nodeIndex="2117">
.L2: <br nodeIndex="2118">
popl %ebx// %ebx中为当前指令的地址 <br nodeIndex="2119">
subl $.L2-a.0, %ebx//该指令地址-相对a.0的偏移，即为a.0的地址,在%ebx中 <br nodeIndex="2120">
incl (%ebx) <br nodeIndex="2121">
movl (%ebx), %eax <br nodeIndex="2122">
popl %ebx <br nodeIndex="2123">
leave <br nodeIndex="2124">
ret <br nodeIndex="2125">
.Lfe1: <br nodeIndex="2126">
.size f,.Lfe1-f <br nodeIndex="2127">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="283">现在这个代码是PIC而不是RC</p>
<p brd="1" nodeIndex="284">综上,PIC代码中不能引用绝对地址,否则需要重定位.(上面的 subl .L2-a.0, %ebx不算引用，因为gas会计算偏移,最终形成的指令中存放的是数) <br nodeIndex="2128">
RC代码不能使用共享变量，否则需要锁。</p>
<p brd="1" nodeIndex="285">位置无关代码有什么优点？多个可执行程序运行这样的代码(例如动态链接库)时，虽然加载地址可能不一样，但是该代码不需要重定位，也就是不</p>
<p brd="1" nodeIndex="286">需要修改代码，那么多个可执行程序就能共享一个代码副本，从而节省内存。缺点是占用一个寄存器计算地址，代码长度增加一点，执行时间增加</p>
<p brd="1" nodeIndex="287">一点。</p>
<p brd="1" nodeIndex="288">2.GOT</p>
<p brd="1" nodeIndex="289">GOT是GLOBAL OFFSET TABLE(全局偏移表).</p>
<p brd="1" nodeIndex="290">我们称一个可执行文件或动态链接库为一个模块.</p>
<p brd="1" nodeIndex="291">一个模块中的数据或函数只允许被自己访问，称为本地局部数据或本地局部函数.例如static 类型的变量或函数就是这种类型. <br nodeIndex="2129">
一个模块中的数据或函数不但允许被自己访问，也允许外部访问，称为本地全局数据或本地全局函数.例如没有static修饰的变量或函数就是这种类</p>

<p brd="1" nodeIndex="293">相应地一个模块引用另一个模块中的数据或函数，则称为外部全局数据或外部全局函数.例如使用extern修饰的类型的变量或函数就是这种类型 <br nodeIndex="2130">
.</p>
<p brd="1" nodeIndex="294">局部肯定是本地的，外部一定是全局的。</p>
<p brd="1" nodeIndex="295">GOT有四种功能: <br nodeIndex="2131">
>>为本地访问本地局部数据（静态变量或常量）访问提供PIC支持。 <br nodeIndex="2132">
>>为本地访问本地全局数据访问提供PIC支持(配合.got节) <br nodeIndex="2133">
>>为本地访问外地全局数据访问提供PIC支持(配合.got节) <br nodeIndex="2134">
>>为本地访问本地全局函数访问提供PIC支持(配合.plt节和.got.plt节) <br nodeIndex="2135">
>>为本地访问外地全局函数调用提供PIC支持(配合.plt节和.got.plt节) <br nodeIndex="2136">
>>为动态链接提供支持(配合.rel.dyn节,rel.plt节,.got节,.got.plt节）</p>
<p brd="1" nodeIndex="296">由于函数调用使用的都是相对寻址，且本地局部函数地址已知，因此本地访问本地局部函数调用不需要GOT支持.</p>
<p brd="1" nodeIndex="297">(1)为本地访问本地局部数据（静态变量或常量）访问提供PIC支持。 <br nodeIndex="2137">
[zws@mail ~]$cat x.c <br nodeIndex="2138">
static int a=0;</p>
<p brd="1" nodeIndex="298">int f() <br nodeIndex="2139">
{ <br nodeIndex="2140">
a++; <br nodeIndex="2141">
return a; <br nodeIndex="2142">
}</p>
<p brd="1" nodeIndex="299"> <br nodeIndex="2143">
[zws@mail ~]$gcc -fPIC -S x.c <br nodeIndex="2144">
[zws@mail ~]$cat x.s <br nodeIndex="2145">
.file "x.c" <br nodeIndex="2146">
.data <br nodeIndex="2147">
.align 4 <br nodeIndex="2148">
.type a,@object <br nodeIndex="2149">
.size a,4 <br nodeIndex="2150">
a: <br nodeIndex="2151">
.long 0 <br nodeIndex="2152">
.text <br nodeIndex="2153">
.globl f <br nodeIndex="2154">
.type f,@function <br nodeIndex="2155">
f: <br nodeIndex="2156">
pushl %ebp <br nodeIndex="2157">
movl %esp, %ebp <br nodeIndex="2158">
pushl %ebx <br nodeIndex="2159">
call .L2 <br nodeIndex="2160">
.L2: <br nodeIndex="2161">
popl %ebx <br nodeIndex="2162">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L2], %ebx <br nodeIndex="2163">
incl a@GOTOFF(%ebx) <br nodeIndex="2164">
movl a@GOTOFF(%ebx), %eax <br nodeIndex="2165">
popl %ebx <br nodeIndex="2166">
leave <br nodeIndex="2167">
ret <br nodeIndex="2168">
.Lfe1: <br nodeIndex="2169">
.size f,.Lfe1-f <br nodeIndex="2170">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="300">[zws@mail ~]$readelf -a x.o <br nodeIndex="2171">
ELF Header: <br nodeIndex="2172">
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 <br nodeIndex="2173">
Class: ELF32 <br nodeIndex="2174">
Data: 2's complement, little endian <br nodeIndex="2175">
Version: 1 (current) <br nodeIndex="2176">
OS/ABI: UNIX - System V <br nodeIndex="2177">
ABI Version: 0 <br nodeIndex="2178">
Type: REL (Relocatable file) <br nodeIndex="2179">
Machine: Intel 80386 <br nodeIndex="2180">
Version: 0x1 <br nodeIndex="2181">
Entry point address: 0x0 <br nodeIndex="2182">
Start of program headers: 0 (bytes into file) <br nodeIndex="2183">
Start of section headers: 196 (bytes into file) <br nodeIndex="2184">
Flags: 0x0 <br nodeIndex="2185">
Size of this header: 52 (bytes) <br nodeIndex="2186">
Size of program headers: 0 (bytes) <br nodeIndex="2187">
Number of program headers: 0 <br nodeIndex="2188">
Size of section headers: 40 (bytes) <br nodeIndex="2189">
Number of section headers: 9 <br nodeIndex="2190">
Section header string table index: 6</p>
<p brd="1" nodeIndex="301">Section Headers: <br nodeIndex="2191">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="2192">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="2193">
[ 1] .text PROGBITS 00000000 000034 00001f 00 AX 0 0 4 <br nodeIndex="2194">
[ 2] .rel.text REL 00000000 0002dc 000018 08 7 1 4 <br nodeIndex="2195">
[ 3] .data PROGBITS 00000000 000054 000004 00 WA 0 0 4 <br nodeIndex="2196">
[ 4] .bss NOBITS 00000000 000058 000000 00 WA 0 0 4 <br nodeIndex="2197">
[ 5] .comment PROGBITS 00000000 000058 000033 00 0 0 1 <br nodeIndex="2198">
[ 6] .shstrtab STRTAB 00000000 00008b 000039 00 0 0 1 <br nodeIndex="2199">
[ 7] .symtab SYMTAB 00000000 00022c 000090 10 8 7 4 <br nodeIndex="2200">
[ 8] .strtab STRTAB 00000000 0002bc 00001f 00 0 0 1 <br nodeIndex="2201">
Key to Flags: <br nodeIndex="2202">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="2203">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="2204">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="302">There are no section groups in this file.</p>
<p brd="1" nodeIndex="303">There are no program headers in this file.</p>
<p brd="1" nodeIndex="304">Relocation section '.rel.text' at offset 0x2dc contains 3 entries: <br nodeIndex="2205">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2206">
0000000c 0000080a R_386_GOTPC 00000000 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="2207">
00000012 00000309 R_386_GOTOFF 00000000 .data <br nodeIndex="2208">
00000018 00000309 R_386_GOTOFF 00000000 .data</p>
<p brd="1" nodeIndex="305">There are no unwind sections in this file.</p>
<p brd="1" nodeIndex="306">Symbol table '.symtab' contains 9 entries: <br nodeIndex="2209">
Num: Value Size Type Bind Vis Ndx Name <br nodeIndex="2210">
0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br nodeIndex="2211">
1: 00000000 0 FILE LOCAL DEFAULT ABS x.c <br nodeIndex="2212">
2: 00000000 0 SECTION LOCAL DEFAULT 1 <br nodeIndex="2213">
3: 00000000 0 SECTION LOCAL DEFAULT 3 <br nodeIndex="2214">
4: 00000000 0 SECTION LOCAL DEFAULT 4 <br nodeIndex="2215">
5: 00000000 4 OBJECT LOCAL DEFAULT 3 a <br nodeIndex="2216">
6: 00000000 0 SECTION LOCAL DEFAULT 5 <br nodeIndex="2217">
7: 00000000 31 FUNC GLOBAL DEFAULT 1 f <br nodeIndex="2218">
8: 00000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_</p>
<p brd="1" nodeIndex="307">No version information found in this file.</p>
<p brd="1" nodeIndex="308">[zws@mail ~]$ objdump -d x.o</p>
<p brd="1" nodeIndex="309">x.o: file format elf32-i386</p>
<p brd="1" nodeIndex="310">Disassembly of section .text:</p>
<p brd="1" nodeIndex="311">00000000 <f>: <br nodeIndex="2219">
0: 55 push %ebp <br nodeIndex="2220">
1: 89 e5 mov %esp,%ebp <br nodeIndex="2221">
3: 53 push %ebx <br nodeIndex="2222">
4: e8 00 00 00 00 call 9 <f+0x9> <br nodeIndex="2223">
9: 5b pop %ebx <br nodeIndex="2224">
a: 81 c3 03 00 00 00 add $0x3,%ebx <br nodeIndex="2225">
10: ff 83 00 00 00 00 incl 0x0(%ebx) <br nodeIndex="2226">
16: 8b 83 00 00 00 00 mov 0x0(%ebx),%eax <br nodeIndex="2227">
1c: 5b pop %ebx <br nodeIndex="2228">
1d: c9 leave <br nodeIndex="2229">
1e: c3 ret <br nodeIndex="2230">
分析</p>
<p brd="1" nodeIndex="312">call .L2，将下一条指令地址压栈 <br nodeIndex="2231">
popl %ebx,将本指令地址弹出到%ebx寄存器 <br nodeIndex="2232">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L2], %ebx <br nodeIndex="2233">
$说明这个操作数是立即数,_GLOBAL_OFFSET_TABLE_,特殊符号,gas能够识别，并为改该操作数生成R_386_GOTPC重定位类型.例如上面的 <br nodeIndex="2234">
0000000c 0000080a R_386_GOTPC 00000000 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="2235">
地址0000000c指向指令 a: 81 c3 03 00 00 00 add $0x3,%ebx的源操作数部分[03 00 00 00] <br nodeIndex="2236">
ld链接时，检查重定位表，发现包含R_386_GOTPC重定位项，创建.got和.got.plt节,.got节存放全局数据地址，.got.plt存放全局函数地址,GOT地</p>
<p brd="1" nodeIndex="313">址是.got.plt的地址(ld也可以合并这两个节成一个.got节),并计算地址GOT和地址0000000c的差值,加入0000000c处的值并写入,这就是R_386_GO</p>
<p brd="1" nodeIndex="314">TPC重定位的内容。</p>
<p brd="1" nodeIndex="315">上面的[.-.L2]意思是计算当前指令地址和.L2地址之差，即popl %ebx指令长度,应该是1.但是为何最终的指令却是add $0x3,%ebx呢?操作数3是如</p>
<p brd="1" nodeIndex="316">何计算出来的呢？</p>
<p brd="1" nodeIndex="317">这是因为重定位R_386_GOTPC项时计算的是该操作数与GOT的差值,而不是该条指令与GOT的差值.因此需要计算该操作数的偏移,即指令 <br nodeIndex="2237">
a: 81 c3 03 00 00 00 add $0x3,%ebx <br nodeIndex="2238">
地址00000009加上81 c3这两字节操作码长度，形成最终地址0000000c. <br nodeIndex="2239">
相应的%ebx存放的应该是该操作数的加载地址，即(popl %ebx指令地址)+(popl %ebx指令长度)+(add</p>
<p brd="1" nodeIndex="318">$0x3,%ebx指令操作码长度)=%ebx+1+2=add $0x3,%ebx</p>
<p brd="1" nodeIndex="319">然而指令 <br nodeIndex="2240">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L2], %ebx <br nodeIndex="2241">
并没有明确指出再加上addl的操作码长度，其实这是gas替我们隐含计算了.gas分析该指令的操作数，碰到是立即数，且含有符号_GLOBAL_OFFS</p>
<p brd="1" nodeIndex="320">ET_TABLE_,会在形成最终的操作时，自动加上操作码长度，得到我们想要的结果。</p>
<p brd="1" nodeIndex="321">a++生成的指令是 incl a@GOTOFF(%ebx)生成的机器指令是 <br nodeIndex="2242">
10: ff 83 00 00 00 00 incl 0x0(%ebx) <br nodeIndex="2243">
重定位项是 <br nodeIndex="2244">
00000012 00000309 R_386_GOTOFF 00000000 .data <br nodeIndex="2245">
在连接时重定位类型R_386_GOTOFF执行的操作时计算计算该符号与GOT的偏移，并加入重定位处(GOTOFF即GOT OFFSET). <br nodeIndex="2246">
可见a@GOTOFF会指示gas生成R_386_GOTOFF重定位项，比较适合只被自己使用的变量。</p>
<p brd="1" nodeIndex="322">在符号表中 <br nodeIndex="2247">
5: 00000000 4 OBJECT LOCAL DEFAULT 3 a <br nodeIndex="2248">
a的bind类型是local.</p>
<p brd="1" nodeIndex="323">(2)为本地访问本地全局数据访问提供PIC支持(配合.got节) <br nodeIndex="2249">
[zws@mail ~]$cat x.c <br nodeIndex="2250">
int a=0;</p>
<p brd="1" nodeIndex="324">int f() <br nodeIndex="2251">
{ <br nodeIndex="2252">
a++; <br nodeIndex="2253">
return a; <br nodeIndex="2254">
} <br nodeIndex="2255">
[zws@mail ~]$cat x.s <br nodeIndex="2256">
.file "x.c" <br nodeIndex="2257">
.globl a <br nodeIndex="2258">
.data <br nodeIndex="2259">
.align 4 <br nodeIndex="2260">
.type a,@object <br nodeIndex="2261">
.size a,4 <br nodeIndex="2262">
a: <br nodeIndex="2263">
.long 0 <br nodeIndex="2264">
.text <br nodeIndex="2265">
.globl f <br nodeIndex="2266">
.type f,@function <br nodeIndex="2267">
f: <br nodeIndex="2268">
pushl %ebp <br nodeIndex="2269">
movl %esp, %ebp <br nodeIndex="2270">
pushl %ebx <br nodeIndex="2271">
call .L2 <br nodeIndex="2272">
.L2: <br nodeIndex="2273">
popl %ebx <br nodeIndex="2274">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L2], %ebx <br nodeIndex="2275">
movl a@GOT(%ebx), %eax <br nodeIndex="2276">
incl (%eax) <br nodeIndex="2277">
movl a@GOT(%ebx), %eax <br nodeIndex="2278">
movl (%eax), %eax <br nodeIndex="2279">
popl %ebx <br nodeIndex="2280">
leave <br nodeIndex="2281">
ret <br nodeIndex="2282">
.Lfe1: <br nodeIndex="2283">
.size f,.Lfe1-f <br nodeIndex="2284">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)" <br nodeIndex="2285">
[zws@mail ~]$readelf -a x.o <br nodeIndex="2286">
ELF Header: <br nodeIndex="2287">
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 <br nodeIndex="2288">
Class: ELF32 <br nodeIndex="2289">
Data: 2's complement, little endian <br nodeIndex="2290">
Version: 1 (current) <br nodeIndex="2291">
OS/ABI: UNIX - System V <br nodeIndex="2292">
ABI Version: 0 <br nodeIndex="2293">
Type: REL (Relocatable file) <br nodeIndex="2294">
Machine: Intel 80386 <br nodeIndex="2295">
Version: 0x1 <br nodeIndex="2296">
Entry point address: 0x0 <br nodeIndex="2297">
Start of program headers: 0 (bytes into file) <br nodeIndex="2298">
Start of section headers: 200 (bytes into file) <br nodeIndex="2299">
Flags: 0x0 <br nodeIndex="2300">
Size of this header: 52 (bytes) <br nodeIndex="2301">
Size of program headers: 0 (bytes) <br nodeIndex="2302">
Number of program headers: 0 <br nodeIndex="2303">
Size of section headers: 40 (bytes) <br nodeIndex="2304">
Number of section headers: 9 <br nodeIndex="2305">
Section header string table index: 6</p>
<p brd="1" nodeIndex="325">Section Headers: <br nodeIndex="2306">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="2307">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="2308">
[ 1] .text PROGBITS 00000000 000034 000023 00 AX 0 0 4 <br nodeIndex="2309">
[ 2] .rel.text REL 00000000 0002e0 000018 08 7 1 4 <br nodeIndex="2310">
[ 3] .data PROGBITS 00000000 000058 000004 00 WA 0 0 4 <br nodeIndex="2311">
[ 4] .bss NOBITS 00000000 00005c 000000 00 WA 0 0 4 <br nodeIndex="2312">
[ 5] .comment PROGBITS 00000000 00005c 000033 00 0 0 1 <br nodeIndex="2313">
[ 6] .shstrtab STRTAB 00000000 00008f 000039 00 0 0 1 <br nodeIndex="2314">
[ 7] .symtab SYMTAB 00000000 000230 000090 10 8 6 4 <br nodeIndex="2315">
[ 8] .strtab STRTAB 00000000 0002c0 00001f 00 0 0 1 <br nodeIndex="2316">
Key to Flags: <br nodeIndex="2317">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="2318">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="2319">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="326">There are no section groups in this file.</p>
<p brd="1" nodeIndex="327">There are no program headers in this file.</p>
<p brd="1" nodeIndex="328">Relocation section '.rel.text' at offset 0x2e0 contains 3 entries: <br nodeIndex="2320">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2321">
0000000c 0000080a R_386_GOTPC 00000000 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="2322">
00000012 00000603 R_386_GOT32 00000000 a <br nodeIndex="2323">
0000001a 00000603 R_386_GOT32 00000000 a</p>
<p brd="1" nodeIndex="329">There are no unwind sections in this file.</p>
<p brd="1" nodeIndex="330">Symbol table '.symtab' contains 9 entries: <br nodeIndex="2324">
Num: Value Size Type Bind Vis Ndx Name <br nodeIndex="2325">
0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br nodeIndex="2326">
1: 00000000 0 FILE LOCAL DEFAULT ABS x.c <br nodeIndex="2327">
2: 00000000 0 SECTION LOCAL DEFAULT 1 <br nodeIndex="2328">
3: 00000000 0 SECTION LOCAL DEFAULT 3 <br nodeIndex="2329">
4: 00000000 0 SECTION LOCAL DEFAULT 4 <br nodeIndex="2330">
5: 00000000 0 SECTION LOCAL DEFAULT 5 <br nodeIndex="2331">
6: 00000000 4 OBJECT GLOBAL DEFAULT 3 a <br nodeIndex="2332">
7: 00000000 35 FUNC GLOBAL DEFAULT 1 f <br nodeIndex="2333">
8: 00000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_</p>
<p brd="1" nodeIndex="331">No version information found in this file. <br nodeIndex="2334">
[zws@mail ~]$</p>
<p brd="1" nodeIndex="332">和前面的唯一差别就是对变量的访问方式.由a@GOTOFF变成a@GOT,重定位方式也从R_386_GOTOFF变成R_386_GOT32. <br nodeIndex="2335">
a@GOT的访问方式是，将变量a的地址值存入.got节,访问a时,先根据GOT计算存放变量a的地址值在.got中的地址，然后取该地址值,即为变量a的</p>
<p brd="1" nodeIndex="333">地址，用一条指令就能实现 <br nodeIndex="2336">
movl a@GOT(%ebx), %eax <br nodeIndex="2337">
然后就可以对该变量执行操作了 <br nodeIndex="2338">
例如a++生成的指令时 incl (%eax),对该地址处的值增一。</p>
<p brd="1" nodeIndex="334">在符号表中 <br nodeIndex="2339">
6: 00000000 4 OBJECT GLOBAL DEFAULT 3 a <br nodeIndex="2340">
a的bind类型是GLOBAL.</p>
<p brd="1" nodeIndex="335">再写一个y.c <br nodeIndex="2341">
[zws@mail ~]$cat y.c <br nodeIndex="2342">
void f();</p>
<p brd="1" nodeIndex="336">int main() <br nodeIndex="2343">
{ <br nodeIndex="2344">
f(); <br nodeIndex="2345">
return 0; <br nodeIndex="2346">
} <br nodeIndex="2347">
[zws@mail ~]$gcc y.c x.o</p>
<p brd="1" nodeIndex="337">分析生成的可执行文件a.out可发现</p>
<p brd="1" nodeIndex="338">ld在处理R_386_GOT32时，将该符号的地址x存入.got节,并记录其在.got</p>
<p brd="1" nodeIndex="339">节中的地址y,然后计算y相对于GOT偏移，存入该符号所有的R_386_GOT32类型重定位地址处。最后在目标文件中为该符号生成R_386_GLOB_D</p>
<p brd="1" nodeIndex="340">AT类型重定位项例如 <br nodeIndex="2348">
readelf -a a.out</p>
<p brd="1" nodeIndex="341">[20] .got PROGBITS 080494e0 0004e0 000008 04 WA 0 0 4 <br nodeIndex="2349">
[21] .got.plt PROGBITS 080494e8 0004e8 000010 04 WA 0 0 4</p>
<p brd="1" nodeIndex="342">080494e4 00000406 R_386_GLOB_DAT 08049504 a(显然地址080494e4在.got中)</p>
<p brd="1" nodeIndex="343">R_386_GLOB_DAT类型执行的操作是，将模块加载地址加入该重定位处.这样变量的地址就确定了，可以功过y来访问,而且不需要对代码重定位。</p>
<p brd="1" nodeIndex="344">如果该变量被其他模块访问(例如动态链接库中的变量被可执行文件访问或动态链接库中的变量被其他动态链接库库访问)，则执行动态链接时，只</p>
<p brd="1" nodeIndex="345">需要将该变量所在的地址x存入引用模块的.got节y处，就能实现共享且PIC.</p>
<p brd="1" nodeIndex="346">其实本地访问本地全局数据访问也可以使用GOTOFF方式(例如本例的x.c).想一想为什么不这样做？从指导ld的方面去想。</p>
<p brd="1" nodeIndex="347">(3)为本地访问外部全局数据访问提供PIC支持(配合.got节)</p>
<p brd="1" nodeIndex="348">[zws@mail ~]$cat x.c <br nodeIndex="2350">
extern int a;</p>
<p brd="1" nodeIndex="349">int f() <br nodeIndex="2351">
{ <br nodeIndex="2352">
a++; <br nodeIndex="2353">
return a; <br nodeIndex="2354">
} <br nodeIndex="2355">
[zws@mail ~]$gcc -fPIC -S x.c <br nodeIndex="2356">
[zws@mail ~]$cat x.s <br nodeIndex="2357">
.file "x.c" <br nodeIndex="2358">
.text <br nodeIndex="2359">
.globl f <br nodeIndex="2360">
.type f,@function <br nodeIndex="2361">
f: <br nodeIndex="2362">
pushl %ebp <br nodeIndex="2363">
movl %esp, %ebp <br nodeIndex="2364">
pushl %ebx <br nodeIndex="2365">
call .L2 <br nodeIndex="2366">
.L2: <br nodeIndex="2367">
popl %ebx <br nodeIndex="2368">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L2], %ebx <br nodeIndex="2369">
movl a@GOT(%ebx), %eax <br nodeIndex="2370">
incl (%eax) <br nodeIndex="2371">
movl a@GOT(%ebx), %eax <br nodeIndex="2372">
movl (%eax), %eax <br nodeIndex="2373">
popl %ebx <br nodeIndex="2374">
leave <br nodeIndex="2375">
ret <br nodeIndex="2376">
.Lfe1: <br nodeIndex="2377">
.size f,.Lfe1-f <br nodeIndex="2378">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)"</p>
<p brd="1" nodeIndex="350">[zws@mail ~]$gcc -shared x.s -o libx.so</p>
<p brd="1" nodeIndex="351">readelf 查看一下是否和上面分析的一致</p>
<p brd="1" nodeIndex="352">(4)为本地访问本地全局函数调用提供PIC支持(配合.plt节和.got.plt节) <br nodeIndex="2379">
[zws@mail ~]$cat x.c <br nodeIndex="2380">
void f() <br nodeIndex="2381">
{ <br nodeIndex="2382">
}</p>
<p brd="1" nodeIndex="353">void g() <br nodeIndex="2383">
{ <br nodeIndex="2384">
f(); <br nodeIndex="2385">
} <br nodeIndex="2386">
[zws@mail ~]$gcc -fPIC -S x.c <br nodeIndex="2387">
[zws@mail ~]$cat x.s <br nodeIndex="2388">
.file "x.c" <br nodeIndex="2389">
.text <br nodeIndex="2390">
.globl f <br nodeIndex="2391">
.type f,@function <br nodeIndex="2392">
f: <br nodeIndex="2393">
pushl %ebp <br nodeIndex="2394">
movl %esp, %ebp <br nodeIndex="2395">
leave <br nodeIndex="2396">
ret <br nodeIndex="2397">
.Lfe1: <br nodeIndex="2398">
.size f,.Lfe1-f <br nodeIndex="2399">
.globl g <br nodeIndex="2400">
.type g,@function <br nodeIndex="2401">
g: <br nodeIndex="2402">
pushl %ebp <br nodeIndex="2403">
movl %esp, %ebp <br nodeIndex="2404">
pushl %ebx <br nodeIndex="2405">
subl $4, %esp <br nodeIndex="2406">
call .L3 <br nodeIndex="2407">
.L3: <br nodeIndex="2408">
popl %ebx <br nodeIndex="2409">
addl $_GLOBAL_OFFSET_TABLE_+[.-.L3], %ebx <br nodeIndex="2410">
call f@PLT <br nodeIndex="2411">
addl $4, %esp <br nodeIndex="2412">
popl %ebx <br nodeIndex="2413">
leave <br nodeIndex="2414">
ret <br nodeIndex="2415">
.Lfe2: <br nodeIndex="2416">
.size g,.Lfe2-g <br nodeIndex="2417">
.ident "GCC: (GNU) 3.2.2 20030222 (Red Hat Linux 3.2.2-5)" <br nodeIndex="2418">
[zws@mail ~]$as x.s -o x.o <br nodeIndex="2419">
[zws@mail ~]$readelf -r x.o</p>
<p brd="1" nodeIndex="354">Relocation section '.rel.text' at offset 0x2dc contains 2 entries: <br nodeIndex="2420">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2421">
00000014 0000080a R_386_GOTPC 00000000 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="2422">
00000019 00000604 R_386_PLT32 00000000 f</p>
<p brd="1" nodeIndex="355">本地调用本地全局函数生成的代码是 call f@PLT <br nodeIndex="2423">
gas为call f@PLT生成的重定位项是R_386_PLT32 ,指导ld生成.plt节。 <br nodeIndex="2424">
[zws@mail ~]$gcc -shared x.o -o libx.so <br nodeIndex="2425">
[zws@mail ~]$readelf -r libx.so</p>
<p brd="1" nodeIndex="356">Relocation section '.rel.dyn' at offset 0x22c contains 5 entries: <br nodeIndex="2426">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2427">
00001500 00000008 R_386_RELATIVE <br nodeIndex="2428">
00001504 00000008 R_386_RELATIVE <br nodeIndex="2429">
000014dc 00000106 R_386_GLOB_DAT 00000000 __gmon_start__ <br nodeIndex="2430">
000014e0 00000206 R_386_GLOB_DAT 00000000 _Jv_RegisterClasses <br nodeIndex="2431">
000014e4 00000806 R_386_GLOB_DAT 00000000 __cxa_finalize</p>
<p brd="1" nodeIndex="357">Relocation section '.rel.plt' at offset 0x254 contains 3 entries: <br nodeIndex="2432">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2433">
000014f4 00000207 R_386_JUMP_SLOT 00000000 _Jv_RegisterClasses <br nodeIndex="2434">
000014f8 00000607 R_386_JUMP_SLOT 00000390 f <br nodeIndex="2435">
000014fc 00000807 R_386_JUMP_SLOT 00000000 __cxa_finalize</p>
<p brd="1" nodeIndex="358">[zws@mail ~]$objdump -d libx.so <br nodeIndex="2436">
Disassembly of section .plt:</p>
<p brd="1" nodeIndex="359">00000284 <_Jv_RegisterClasses@plt-0x10>: <br nodeIndex="2437">
284: ff b3 04 00 00 00 pushl 0x4(%ebx) <br nodeIndex="2438">
28a: ff a3 08 00 00 00 jmp *0x8(%ebx) <br nodeIndex="2439">
290: 00 00 add %al,(%eax) <br nodeIndex="2440">
...</p>
<p brd="1" nodeIndex="360">00000294 <_Jv_RegisterClasses@plt>: <br nodeIndex="2441">
294: ff a3 0c 00 00 00 jmp *0xc(%ebx) <br nodeIndex="2442">
29a: 68 00 00 00 00 push $0x0 <br nodeIndex="2443">
29f: e9 e0 ff ff ff jmp 284 <_init+0x18></p>
<p brd="1" nodeIndex="361">000002a4 <f@plt>: <br nodeIndex="2444">
2a4: ff a3 10 00 00 00 jmp *0x10(%ebx) <br nodeIndex="2445">
2aa: 68 08 00 00 00 push $0x8 <br nodeIndex="2446">
2af: e9 d0 ff ff ff jmp 284 <_init+0x18></p>
<p brd="1" nodeIndex="362">000002b4 <__cxa_finalize@plt>: <br nodeIndex="2447">
2b4: ff a3 14 00 00 00 jmp *0x14(%ebx) <br nodeIndex="2448">
2ba: 68 10 00 00 00 push $0x10 <br nodeIndex="2449">
2bf: e9 c0 ff ff ff jmp 284 <_init+0x18></p>
<p brd="1" nodeIndex="363">。。。。。。。。。。。。。 <br nodeIndex="2450">
00000390 <f>: <br nodeIndex="2451">
390: 55 push %ebp <br nodeIndex="2452">
391: 89 e5 mov %esp,%ebp <br nodeIndex="2453">
393: c9 leave <br nodeIndex="2454">
394: c3 ret</p>
<p brd="1" nodeIndex="364">00000395 <g>: <br nodeIndex="2455">
395: 55 push %ebp <br nodeIndex="2456">
396: 89 e5 mov %esp,%ebp <br nodeIndex="2457">
398: 53 push %ebx <br nodeIndex="2458">
399: 83 ec 04 sub $0x4,%esp <br nodeIndex="2459">
39c: e8 00 00 00 00 call 3a1 <g+0xc> <br nodeIndex="2460">
3a1: 5b pop %ebx <br nodeIndex="2461">
3a2: 81 c3 47 11 00 00 add $0x1147,%ebx <br nodeIndex="2462">
3a8: e8 f7 fe ff ff call 2a4 <f@plt> <br nodeIndex="2463">
3ad: 83 c4 04 add $0x4,%esp <br nodeIndex="2464">
3b0: 5b pop %ebx <br nodeIndex="2465">
3b1: c9 leave <br nodeIndex="2466">
3b2: c3 ret <br nodeIndex="2467">
3b3: 90 nop</p>
<p brd="1" nodeIndex="365">至于这里的涉及到的原理看下面,这里的%ebx存放的是本模块的GOT地址</p>
<p brd="1" nodeIndex="366">(5)为本地访问外部全局函数调用提供PIC支持(配合.plt节和.got.plt节) <br nodeIndex="2468">
[zws@mail ~]$cat x.c <br nodeIndex="2469">
int a=0;</p>
<p brd="1" nodeIndex="367">int f() <br nodeIndex="2470">
{ <br nodeIndex="2471">
a++; <br nodeIndex="2472">
return a; <br nodeIndex="2473">
} <br nodeIndex="2474">
[zws@mail ~]$gcc -fPIC -shared x.c -o x.o <br nodeIndex="2475">
[zws@mail ~]$cat y.c <br nodeIndex="2476">
void f();</p>
<p brd="1" nodeIndex="368">int main() <br nodeIndex="2477">
{ <br nodeIndex="2478">
f(); <br nodeIndex="2479">
return 0; <br nodeIndex="2480">
} <br nodeIndex="2481">
[zws@mail ~]$gcc y.c libx.so <br nodeIndex="2482">
[zws@mail ~]objdump -d a.out <br nodeIndex="2483">
看看外部全局函数调用使用什么方式</p>
<p brd="1" nodeIndex="369">080483e8 <main>: <br nodeIndex="2484">
80483e8: 55 push %ebp <br nodeIndex="2485">
80483e9: 89 e5 mov %esp,%ebp <br nodeIndex="2486">
80483eb: 83 ec 08 sub $0x8,%esp <br nodeIndex="2487">
80483ee: 83 e4 f0 and $0xfffffff0,%esp <br nodeIndex="2488">
80483f1: b8 00 00 00 00 mov $0x0,%eax <br nodeIndex="2489">
80483f6: 29 c4 sub %eax,%esp <br nodeIndex="2490">
80483f8: e8 2b ff ff ff call 8048328 <f@plt> <br nodeIndex="2491">
80483fd: b8 00 00 00 00 mov $0x0,%eax <br nodeIndex="2492">
8048402: c9 leave <br nodeIndex="2493">
8048403: c3 ret</p>
<p brd="1" nodeIndex="370">call 8048328,这个地址在.plt节中 <br nodeIndex="2494">
Disassembly of section .plt:</p>
<p brd="1" nodeIndex="371">08048308 <__libc_start_main@plt-0x10>: <br nodeIndex="2495">
8048308: ff 35 a0 95 04 08 pushl 0x80495a0 <br nodeIndex="2496">
804830e: ff 25 a4 95 04 08 jmp *0x80495a4 <br nodeIndex="2497">
8048314: 00 00 add %al,(%eax) <br nodeIndex="2498">
...</p>
<p brd="1" nodeIndex="372">08048318 <__libc_start_main@plt>: <br nodeIndex="2499">
8048318: ff 25 a8 95 04 08 jmp *0x80495a8 <br nodeIndex="2500">
804831e: 68 00 00 00 00 push $0x0 <br nodeIndex="2501">
8048323: e9 e0 ff ff ff jmp 8048308 <_init+0x18></p>
<p brd="1" nodeIndex="373">08048328 <f@plt>: <br nodeIndex="2502">
8048328: ff 25 ac 95 04 08 jmp *0x80495ac <br nodeIndex="2503">
804832e: 68 08 00 00 00 push $0x8 <br nodeIndex="2504">
8048333: e9 d0 ff ff ff jmp 8048308 <_init+0x18></p>
<p brd="1" nodeIndex="374">jmp *0x80495ac,这个地址在.got.plt节中 <br nodeIndex="2505">
[zws@mail ~]$objdump -sj .got.plt a.out</p>
<p brd="1" nodeIndex="375">a.out: file format elf32-i386</p>
<p brd="1" nodeIndex="376">Contents of section .got.plt: <br nodeIndex="2506">
804959c c8940408 00000000 00000000 1e830408 ................ <br nodeIndex="2507">
80495ac 2e830408 ....</p>
<p brd="1" nodeIndex="377">该地址处的值是0804832e,就是前面jmp *0x80495ac的下一条指令地址 <br nodeIndex="2508">
push $0x8,压入立即数8,其实是f的重定位项的在.rel.plt节中偏移(一个重定位项占8字节) <br nodeIndex="2509">
Relocation section '.rel.plt' at offset 0x2e0 contains 2 entries: <br nodeIndex="2510">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2511">
080495a8 00000407 R_386_JUMP_SLOT 00000000 __libc_start_main <br nodeIndex="2512">
080495ac 00000807 R_386_JUMP_SLOT 00000000 f <br nodeIndex="2513">
该f符号的重定位偏移是080495ac(就是在前面的.got.plt节中),类型是R_386_JUMP_SLOT.这样动态连接时，查找到f的地址后，写入080495ac处. <br nodeIndex="2514">
这样下次调用f时，就会直接跳到f的真实地址。</p>
<p brd="1" nodeIndex="378">push $0x8的下一条指令时jmp 8048308,8048308处的指令时 <br nodeIndex="2515">
8048308: ff 35 a0 95 04 08 pushl 0x80495a0 <br nodeIndex="2516">
804830e: ff 25 a4 95 04 08 jmp *0x80495a4</p>
<p brd="1" nodeIndex="379">第一条pushl 0x80495a0,将0x80495a0地址处的值压栈。0x80495a0在.got.plt中 <br nodeIndex="2517">
[zws@mail ~]$objdump -sj .got.plt a.out</p>
<p brd="1" nodeIndex="380">a.out: file format elf32-i386</p>
<p brd="1" nodeIndex="381">Contents of section .got.plt: <br nodeIndex="2518">
804959c c8940408 00000000 00000000 1e830408 ................ <br nodeIndex="2519">
80495ac 2e830408 ....</p>
<p brd="1" nodeIndex="382">.got.plt的前三项是有特殊意义的,他们都是地址,在执行动态连接时要用到.第0项080494c8是.dynamic节地址.第1项是本模块的link_map地址，这</p>
<p brd="1" nodeIndex="383">里是0，动态连接时会存入真实地址，第2项是_dl_runtime_resolve的地址，动态链接时存入.</p>
<p brd="1" nodeIndex="384">将本模块的link_map地址压栈后，jmp *0x80495a4, 显然是跳到_dl_runtime_resolve中，执行链接f任务,_dl_runtime_resolve解析到f地址后，</p>
<p brd="1" nodeIndex="385">会存入80495ac处，并将该地址替换栈上的返回地址，这样,_dl_runtime_resolve返回时，直接返回到f中，并执行f.而下次再执行f时就不需要这么</p>
<p brd="1" nodeIndex="386">麻烦了。</p>
<p brd="1" nodeIndex="387">这种在需要执行时才进行符号链接是所谓的lazy方式动态链接，还有一种就是模块加载时一次性为所有的符号进行链接，无论用不用得到，所谓的</p>
<p brd="1" nodeIndex="388">now方式动态链接。</p>
<p brd="1" nodeIndex="389">综上.got节存放的都是被本地引用的本地全局数据(没有被本地引用的不会出现)和外部全局数据,.got.plt前三项特殊,后面都是被本地引用的本地全</p>
<p brd="1" nodeIndex="390">局函数(没有被本地引用的不会出现)和外部全局函数地址..plt存放过程链接信息(procedure link</p>
<p brd="1" nodeIndex="391">table)..rel.dyn重定位.got(类型为R_386_GLOB_DAT的项),.rel.plt重定位.got.plt.</p>

<p brd="1" nodeIndex="393"> <br nodeIndex="2520">
ld.so分析5 _dl_start</p>
<p brd="1" nodeIndex="394">对于不关心的地方，我们都//或/**/注释掉</p>
<p brd="1" nodeIndex="395">1._dl_start中的变量声明</p>
<p brd="1" nodeIndex="396">static Elf32_Addr //我们假设是i386 32位平台,ElfW(Addr)被宏扩展为Elf32_Addr <br nodeIndex="2521">
//ElfW(Addr) <br nodeIndex="2522">
//__attribute_used__ internal_function <br nodeIndex="2523">
//__attribute__ ((__used__)) __attribute__ ((regparm (3), stdcall)) <br nodeIndex="2524">
_dl_start (void *arg)//arg参数值argc地址 <br nodeIndex="2525">
{ <br nodeIndex="2526">
//#ifdef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="2527">
# define bootstrap_map GL(dl_rtld_map) <br nodeIndex="2528">
//#else <br nodeIndex="2529">
// struct dl_start_final_info info; <br nodeIndex="2530">
//# define bootstrap_map info.l <br nodeIndex="2531">
//#endif <br nodeIndex="2532">
//#if USE_TLS || (!DONT_USE_BOOTSTRAP_MAP && !HAVE_BUILTIN_MEMSET) <br nodeIndex="2533">
// size_t cnt; <br nodeIndex="2534">
//#endif <br nodeIndex="2535">
//#ifdef USE_TLS <br nodeIndex="2536">
// ElfW(Ehdr) *ehdr; <br nodeIndex="2537">
// ElfW(Phdr) *phdr; <br nodeIndex="2538">
// dtv_t initdtv[3]; <br nodeIndex="2539">
//#endif</p>
<p brd="1" nodeIndex="397"> <br nodeIndex="2540">
宏GL定义如下</p>
<p brd="1" nodeIndex="398"># define GL(name) _rtld_local._##name</p>

<p brd="1" nodeIndex="400">#define bootstrap_map _rtld_local._dl_rtld_map</p>
<p brd="1" nodeIndex="401">_rtld_local是什么呢？</p>
<p brd="1" nodeIndex="402">查看rtld.c的预处理文件可发现如下定义</p>
<p brd="1" nodeIndex="403"> <br nodeIndex="2541">
struct rtld_global _rtld_global = <br nodeIndex="2542">
{ <br nodeIndex="2543">
# 1 "../sysdeps/unix/sysv/linux/i386/dl-procinfo.c" 1 <br nodeIndex="2544">
# 47 "../sysdeps/unix/sysv/linux/i386/dl-procinfo.c" <br nodeIndex="2545">
._dl_x86_cap_flags <br nodeIndex="2546">
= { <br nodeIndex="2547">
"fpu", "vme", "de", "pse", "tsc", "msr", "pae", "mce", <br nodeIndex="2548">
"cx8", "apic", "10", "sep", "mtrr", "pge", "mca", "cmov", <br nodeIndex="2549">
"pat", "pse36", "pn", "clflush", "20", "dts", "acpi", "mmx", <br nodeIndex="2550">
"fxsr", "sse", "sse2", "ss", "ht", "tm", "ia64", "amd3d" <br nodeIndex="2551">
} <br nodeIndex="2552">
, <br nodeIndex="2553">
._dl_x86_platforms <br nodeIndex="2554">
= { <br nodeIndex="2555">
"i386", "i486", "i586", "i686" <br nodeIndex="2556">
} <br nodeIndex="2557">
, <br nodeIndex="2558">
# 92 "rtld.c" 2 <br nodeIndex="2559">
._dl_debug_fd = 2, <br nodeIndex="2560">
._dl_dynamic_weak = 1, <br nodeIndex="2561">
._dl_lazy = 1, <br nodeIndex="2562">
._dl_fpu_control = 0x037f, <br nodeIndex="2563">
._dl_correct_cache_id = 3, <br nodeIndex="2564">
._dl_hwcap_mask = HWCAP_IMPORTANT, <br nodeIndex="2565">
._dl_load_lock = {{0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, { 0, 0 }}} <br nodeIndex="2566">
};</p>
<p brd="1" nodeIndex="404">extern struct rtld_global _rtld_local __attribute__ ((visibility ("hidden"))); <br nodeIndex="2567">
extern __typeof (_rtld_global) _rtld_local __attribute__ ((alias ("_rtld_global")));;</p>
<p brd="1" nodeIndex="405">结构rtld_global的内容就不贴出来了，大家自己查吧 <br nodeIndex="2568">
这里指出,_rtld_local是_rtld_global的别名.查看ld.so的符号表也能例证 <br nodeIndex="2569">
[zws@mail ~/glibc-2.3/build/elf]$readelf -s ld.so|grep _rtld <br nodeIndex="2570">
332: 00012140 980 OBJECT LOCAL HIDDEN 14 _rtld_local <br nodeIndex="2571">
462: 00012140 980 OBJECT GLOBAL DEFAULT 14 _rtld_global</p>
<p brd="1" nodeIndex="406">_rtld_local._dl_rtld_map的类型是struct link_map.这个类型非常重要，是动态链接的核心数据结构 <br nodeIndex="2572">
注意这里的HIDDEN属性，这个属性保证访问_rtld_local使用_rtld_local@GOTOFF而不是_rtld_local@GOT, <br nodeIndex="2573">
从而_rtld_local不需要重定位,这个一定很重要</p>
<p brd="1" nodeIndex="407"> <br nodeIndex="2574">
2._dl_start中的动态链接内联函数</p>
<p brd="1" nodeIndex="408">/* This #define produces dynamic linking inline functions for <br nodeIndex="2575">
bootstrap relocation instead of general-purpose relocation. */ <br nodeIndex="2576">
#define RTLD_BOOTSTRAP <br nodeIndex="2577">
#define RESOLVE_MAP(sym, version, flags) \ <br nodeIndex="2578">
((*(sym))->st_shndx == SHN_UNDEF ? 0 : &bootstrap_map) <br nodeIndex="2579">
#define RESOLVE(sym, version, flags) \ <br nodeIndex="2580">
((*(sym))->st_shndx == SHN_UNDEF ? 0 : bootstrap_map.l_addr) <br nodeIndex="2581">
#include "dynamic-link.h"</p>
<p brd="1" nodeIndex="409">这里先定义了三个宏，然后包含dynamic-link.h头文件，里面定义了几个动态链接需要用到的宏或函数。 <br nodeIndex="2582">
这些宏或函数用到了前面定义的三个宏，因此，根据这三个宏定义的不同，动态链接宏或函数的功能会有所不同， <br nodeIndex="2583">
前面的注释也说明了这一点。至于有这些动态链接宏或函数的功能，后面涉及到的时候再分析。</p>
<p brd="1" nodeIndex="410">3.获取ld.so的加载基址</p>
<p brd="1" nodeIndex="411">if (HP_TIMING_INLINE && HP_TIMING_AVAIL) <br nodeIndex="2584">
//#ifdef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="2585">
HP_TIMING_NOW (start_time);//获得开始时间 <br nodeIndex="2586">
//#else <br nodeIndex="2587">
// HP_TIMING_NOW (info.start_time); <br nodeIndex="2588">
//#endif</p>
<p brd="1" nodeIndex="412">/* Partly clean the `bootstrap_map' structure up. 部分清空bootstrap_map结构. Don't use <br nodeIndex="2589">
`memset' since it might not be built in or inlined and we cannot <br nodeIndex="2590">
不使用memset是因为它不是内建的或内联函数，我们现在还不能调用. <br nodeIndex="2591">
make function calls at this point. Use '__builtin_memset' if we <br nodeIndex="2592">
如果有效的话，使用__builtin_memset <br nodeIndex="2593">
know it is available. We do not have to clear the memory if we <br nodeIndex="2594">
如果不必使用临时bootstrap_map则不需要清0 <br nodeIndex="2595">
do not have to use the temporary bootstrap_map. Global variables <br nodeIndex="2596">
全局变量缺省初始化为0 <br nodeIndex="2597">
are initialized to zero by default. */ <br nodeIndex="2598">
/* <br nodeIndex="2599">
#ifndef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="2600">
# ifdef HAVE_BUILTIN_MEMSET <br nodeIndex="2601">
__builtin_memset (bootstrap_map.l_info, '\0', sizeof (bootstrap_map.l_info)); <br nodeIndex="2602">
# else <br nodeIndex="2603">
for (cnt = 0; <br nodeIndex="2604">
cnt < sizeof (bootstrap_map.l_info) / sizeof (bootstrap_map.l_info[0]); <br nodeIndex="2605">
++cnt) <br nodeIndex="2606">
bootstrap_map.l_info[cnt] = 0; <br nodeIndex="2607">
# endif <br nodeIndex="2608">
#endif <br nodeIndex="2609">
*/ <br nodeIndex="2610">
/* Figure out the run-time load address of the dynamic linker itself. */ <br nodeIndex="2611">
bootstrap_map.l_addr = elf_machine_load_address ();// 加载地址 _rtld_local._dl_rtld_map.l_addr = elf_machine_load_address ();</p>
<p brd="1" nodeIndex="413">/* Read our own dynamic section and fill in the info array. */ <br nodeIndex="2612">
bootstrap_map.l_ld = (void *) bootstrap_map.l_addr + elf_machine_dynamic ();//动态节地址 <br nodeIndex="2613">
elf_get_dynamic_info (&bootstrap_map);//取动态信息</p>
<p brd="1" nodeIndex="414">4.elf_machine_dynamic和elf_machine_load_address (sysdeps/i386/dl-machine.h)</p>
<p brd="1" nodeIndex="415">/* Return the link-time address of _DYNAMIC. Conveniently, this is the <br nodeIndex="2614">
first element of the GOT, a special entry that is never relocated. */ <br nodeIndex="2615">
static inline Elf32_Addr //__attribute__ ((unused, const)) <br nodeIndex="2616">
elf_machine_dynamic (void) <br nodeIndex="2617">
{ <br nodeIndex="2618">
/* This produces a GOTOFF reloc that resolves to zero at link time, so in <br nodeIndex="2619">
fact just loads from the GOT register directly. By doing it without <br nodeIndex="2620">
an asm we can let the compiler choose any register. */ <br nodeIndex="2621">
extern const Elf32_Addr _GLOBAL_OFFSET_TABLE_[] attribute_hidden; <br nodeIndex="2622">
return _GLOBAL_OFFSET_TABLE_[0]; <br nodeIndex="2623">
}</p>
<p brd="1" nodeIndex="416"> <br nodeIndex="2624">
/* Return the run-time load address of the shared object. */ <br nodeIndex="2625">
static inline Elf32_Addr //__attribute__ ((unused)) <br nodeIndex="2626">
elf_machine_load_address (void) <br nodeIndex="2627">
{ <br nodeIndex="2628">
/* Compute the difference between the runtime address of _DYNAMIC as seen <br nodeIndex="2629">
by a GOTOFF reference, and the link-time address found in the special <br nodeIndex="2630">
unrelocated first GOT entry. */ <br nodeIndex="2631">
extern Elf32_Dyn bygotoff[] asm ("_DYNAMIC");// attribute_hidden; <br nodeIndex="2632">
return (Elf32_Addr) &bygotoff - elf_machine_dynamic (); <br nodeIndex="2633">
} <br nodeIndex="2634">
有点晦涩难懂，看看汇编代码</p>
<p brd="1" nodeIndex="417">bootstrap_map.l_addr = elf_machine_load_address (); <br nodeIndex="2635">
生成的汇编代码如下 <br nodeIndex="2636">
movl _GLOBAL_OFFSET_TABLE_@GOTOFF(%ebx), %edx//取GOT[0],即ld.so的dynamic节被ld静态链接时安排的地址 <br nodeIndex="2637">
leal _DYNAMIC@GOTOFF(%ebx), %eax//取dynamic节运行时加载到内存中的地址 <br nodeIndex="2638">
subl %edx, %eax//dynamic的地址-got[0],即得镜像加载基址 <br nodeIndex="2639">
movl %eax, 456+_rtld_local@GOTOFF(%ebx)//该地址存入l_addr</p>
<p brd="1" nodeIndex="418">C代码和汇编代码对照着看，就能明白一二。</p>
<p brd="1" nodeIndex="419">5.elf_get_dynamic_info (dynamic-link.h) <br nodeIndex="2640">
/* Read the dynamic section at DYN and fill in INFO with indices DT_*. */</p>
<p brd="1" nodeIndex="420">static inline void //__attribute__ ((unused, always_inline)) <br nodeIndex="2641">
elf_get_dynamic_info (struct link_map *l) <br nodeIndex="2642">
{ <br nodeIndex="2643">
ElfW(Dyn) *dyn = l->l_ld; <br nodeIndex="2644">
ElfW(Dyn) **info;</p>
<p brd="1" nodeIndex="421">//#ifndef RTLD_BOOTSTRAP <br nodeIndex="2645">
if (dyn == NULL) <br nodeIndex="2646">
return; <br nodeIndex="2647">
//#endif <br nodeIndex="2648">
/* <br nodeIndex="2649">
[zws@mail elf]$ readelf -d ld.so</p>
<p brd="1" nodeIndex="422">Dynamic section at offset 0x12000 contains 18 entries: <br nodeIndex="2650">
Tag Type Name/Value <br nodeIndex="2651">
0x0000000e (SONAME) Library soname: [ld-linux.so.2] <br nodeIndex="2652">
0x00000004 (HASH) 0x94 <br nodeIndex="2653">
0x00000005 (STRTAB) 0x48c <br nodeIndex="2654">
0x00000006 (SYMTAB) 0x1dc <br nodeIndex="2655">
0x0000000a (STRSZ) 719 (bytes) <br nodeIndex="2656">
0x0000000b (SYMENT) 16 (bytes) <br nodeIndex="2657">
0x00000003 (PLTGOT) 0x120e8 <br nodeIndex="2658">
0x00000002 (PLTRELSZ) 72 (bytes) <br nodeIndex="2659">
0x00000014 (PLTREL) REL <br nodeIndex="2660">
0x00000017 (JMPREL) 0x8c8 <br nodeIndex="2661">
0x00000011 (REL) 0x858 <br nodeIndex="2662">
0x00000012 (RELSZ) 112 (bytes) <br nodeIndex="2663">
0x00000013 (RELENT) 8 (bytes) <br nodeIndex="2664">
0x6ffffffc (VERDEF) 0x7b4 <br nodeIndex="2665">
0x6ffffffd (VERDEFNUM) 5 <br nodeIndex="2666">
0x6ffffff0 (VERSYM) 0x75c <br nodeIndex="2667">
0x6ffffffa (RELCOUNT) 5 <br nodeIndex="2668">
0x00000000 (NULL) 0x0 <br nodeIndex="2669">
[zws@mail elf]$ readelf -x 11 ld.so</p>
<p brd="1" nodeIndex="423">Hex dump of section '.dynamic': <br nodeIndex="2670">
0x00012000 0e000000 95020000 04000000 94000000 ................ <br nodeIndex="2671">
0x00012010 05000000 8c040000 06000000 dc010000 ................ <br nodeIndex="2672">
0x00012020 0a000000 cf020000 0b000000 10000000 ................ <br nodeIndex="2673">
0x00012030 03000000 e8200100 02000000 48000000 ..... ......H... <br nodeIndex="2674">
0x00012040 14000000 11000000 17000000 c8080000 ................ <br nodeIndex="2675">
0x00012050 11000000 58080000 12000000 70000000 ....X.......p... <br nodeIndex="2676">
0x00012060 13000000 08000000 fcffff6f b4070000 ...........o.... <br nodeIndex="2677">
0x00012070 fdffff6f 05000000 f0ffff6f 5c070000 ...o.......o\... <br nodeIndex="2678">
0x00012080 faffff6f 05000000 00000000 00000000 ...o............ <br nodeIndex="2679">
0x00012090 00000000 00000000 00000000 00000000 ................ <br nodeIndex="2680">
0x000120a0 00000000 00000000 00000000 00000000 ................ <br nodeIndex="2681">
*/ <br nodeIndex="2682">
info = l->l_info;//取保存dynamic信息的数据结构</p>
<p brd="1" nodeIndex="424">while (dyn->d_tag != DT_NULL)//遍历 <br nodeIndex="2683">
{ <br nodeIndex="2684">
if (dyn->d_tag < DT_NUM)//长度34,索引范围 [0,33] <br nodeIndex="2685">
info[dyn->d_tag] = dyn; <br nodeIndex="2686">
else if (dyn->d_tag >= DT_LOPROC && <br nodeIndex="2687">
dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)//0,(0x70000000,0x70000000) <br nodeIndex="2688">
info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn; <br nodeIndex="2689">
else if ((Elf32_Word) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)// 16,[0x6ffffff0,0x6fffffff]->[49,34] <br nodeIndex="2690">
info[VERSYMIDX (dyn->d_tag)] = dyn; <br nodeIndex="2691">
else if ((Elf32_Word) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)// 3,[0x7fffffffd,0x7fffffff] <br nodeIndex="2692">
info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM <br nodeIndex="2693">
+ DT_VERSIONTAGNUM] = dyn; <br nodeIndex="2694">
else if ((Elf32_Word) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)// 12,[0x6ffffdf4,0x6ffffdff] <br nodeIndex="2695">
info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM <br nodeIndex="2696">
+ DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn; <br nodeIndex="2697">
else if ((Elf32_Word) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)// 10 ,[0x6ffffef6,0x6ffffeff] <br nodeIndex="2698">
info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM <br nodeIndex="2699">
+ DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn; <br nodeIndex="2700">
++dyn; <br nodeIndex="2701">
} <br nodeIndex="2702">
//#ifndef DL_RO_DYN_SECTION <br nodeIndex="2703">
/* Don't adjust .dynamic unnecessarily. */ <br nodeIndex="2704">
if (l->l_addr != 0)//加载地址 <br nodeIndex="2705">
{ <br nodeIndex="2706">
//调整地址 <br nodeIndex="2707">
ElfW(Addr) l_addr = l->l_addr;</p>
<p brd="1" nodeIndex="425">if (info[DT_HASH] != NULL) <br nodeIndex="2708">
info[DT_HASH]->d_un.d_ptr += l_addr; <br nodeIndex="2709">
if (info[DT_PLTGOT] != NULL) <br nodeIndex="2710">
info[DT_PLTGOT]->d_un.d_ptr += l_addr; <br nodeIndex="2711">
if (info[DT_STRTAB] != NULL) <br nodeIndex="2712">
info[DT_STRTAB]->d_un.d_ptr += l_addr; <br nodeIndex="2713">
if (info[DT_SYMTAB] != NULL) <br nodeIndex="2714">
info[DT_SYMTAB]->d_un.d_ptr += l_addr; <br nodeIndex="2715">
//# if ! ELF_MACHINE_NO_RELA <br nodeIndex="2716">
if (info[DT_RELA] != NULL) <br nodeIndex="2717">
info[DT_RELA]->d_un.d_ptr += l_addr; <br nodeIndex="2718">
//# endif <br nodeIndex="2719">
//# if ! ELF_MACHINE_NO_REL <br nodeIndex="2720">
if (info[DT_REL] != NULL) <br nodeIndex="2721">
info[DT_REL]->d_un.d_ptr += l_addr; <br nodeIndex="2722">
//# endif <br nodeIndex="2723">
if (info[DT_JMPREL] != NULL) <br nodeIndex="2724">
info[DT_JMPREL]->d_un.d_ptr += l_addr; <br nodeIndex="2725">
if (info[VERSYMIDX (DT_VERSYM)] != NULL) <br nodeIndex="2726">
info[VERSYMIDX (DT_VERSYM)]->d_un.d_ptr += l_addr; <br nodeIndex="2727">
} <br nodeIndex="2728">
//#endif <br nodeIndex="2729">
if (info[DT_PLTREL] != NULL) <br nodeIndex="2730">
{ <br nodeIndex="2731">
//#if ELF_MACHINE_NO_RELA <br nodeIndex="2732">
// assert (info[DT_PLTREL]->d_un.d_val == DT_REL); <br nodeIndex="2733">
//#elif ELF_MACHINE_NO_REL <br nodeIndex="2734">
// assert (info[DT_PLTREL]->d_un.d_val == DT_RELA); <br nodeIndex="2735">
//#else <br nodeIndex="2736">
assert (info[DT_PLTREL]->d_un.d_val == DT_REL <br nodeIndex="2737">
|| info[DT_PLTREL]->d_un.d_val == DT_RELA); <br nodeIndex="2738">
//#endif <br nodeIndex="2739">
} <br nodeIndex="2740">
//#if ! ELF_MACHINE_NO_RELA <br nodeIndex="2741">
if (info[DT_RELA] != NULL) <br nodeIndex="2742">
assert (info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))); <br nodeIndex="2743">
//# endif <br nodeIndex="2744">
//# if ! ELF_MACHINE_NO_REL <br nodeIndex="2745">
if (info[DT_REL] != NULL) <br nodeIndex="2746">
assert (info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel))); <br nodeIndex="2747">
//#endif <br nodeIndex="2748">
if (info[DT_FLAGS] != NULL) <br nodeIndex="2749">
{ <br nodeIndex="2750">
/* Flags are used. Translate to the old form where available. <br nodeIndex="2751">
Since these l_info entries are only tested for NULL pointers it <br nodeIndex="2752">
is ok if they point to the DT_FLAGS entry. */ <br nodeIndex="2753">
l->l_flags = info[DT_FLAGS]->d_un.d_val; <br nodeIndex="2754">
//#ifdef RTLD_BOOTSTRAP <br nodeIndex="2755">
/* These three flags must not be set for ld.so. */ <br nodeIndex="2756">
// assert ((l->l_flags & (DF_SYMBOLIC | DF_TEXTREL | DF_BIND_NOW)) == 0); <br nodeIndex="2757">
//#else <br nodeIndex="2758">
if (l->l_flags & DF_SYMBOLIC) <br nodeIndex="2759">
info[DT_SYMBOLIC] = info[DT_FLAGS]; <br nodeIndex="2760">
if (l->l_flags & DF_TEXTREL) <br nodeIndex="2761">
info[DT_TEXTREL] = info[DT_FLAGS]; <br nodeIndex="2762">
if (l->l_flags & DF_BIND_NOW) <br nodeIndex="2763">
info[DT_BIND_NOW] = info[DT_FLAGS]; <br nodeIndex="2764">
//#endif <br nodeIndex="2765">
} <br nodeIndex="2766">
if (info[VERSYMIDX (DT_FLAGS_1)] != NULL) <br nodeIndex="2767">
l->l_flags_1 = info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val; <br nodeIndex="2768">
//#ifdef RTLD_BOOTSTRAP <br nodeIndex="2769">
/* The dynamic linker should have none of these set. */ <br nodeIndex="2770">
// assert (info[DT_RUNPATH] == NULL); <br nodeIndex="2771">
// assert (info[DT_RPATH] == NULL); <br nodeIndex="2772">
//#else <br nodeIndex="2773">
if (info[DT_RUNPATH] != NULL) <br nodeIndex="2774">
/* If both RUNPATH and RPATH are given, the latter is ignored. */ <br nodeIndex="2775">
info[DT_RPATH] = NULL; <br nodeIndex="2776">
//#endif <br nodeIndex="2777">
}</p>
<p brd="1" nodeIndex="426"> <br nodeIndex="2778">
6._dl_start执行自我重定位</p>
<p brd="1" nodeIndex="427">/* <br nodeIndex="2779">
#if USE_TLS <br nodeIndex="2780">
# if !defined HAVE___THREAD && !defined DONT_USE_BOOTSTRAP_MAP <br nodeIndex="2781">
/* Signal that we have not found TLS data so far. * / <br nodeIndex="2782">
bootstrap_map.l_tls_modid = 0; <br nodeIndex="2783">
# endif</p>
<p brd="1" nodeIndex="428">/* Get the dynamic linker's own program header. First we need the ELF <br nodeIndex="2784">
file header. The `_begin' symbol created by the linker script points <br nodeIndex="2785">
to it. When we have something like GOTOFF relocs, we can use a plain <br nodeIndex="2786">
reference to find the runtime address. Without that, we have to rely <br nodeIndex="2787">
on the `l_addr' value, which is not the value we want when prelinked. * / <br nodeIndex="2788">
#ifdef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="2789">
ehdr = (ElfW(Ehdr) *) &_begin; <br nodeIndex="2790">
#else <br nodeIndex="2791">
ehdr = (ElfW(Ehdr) *) bootstrap_map.l_addr; <br nodeIndex="2792">
#endif <br nodeIndex="2793">
phdr = (ElfW(Phdr) *) ((ElfW(Addr)) ehdr + ehdr->e_phoff); <br nodeIndex="2794">
for (cnt = 0; cnt < ehdr->e_phnum; ++cnt) <br nodeIndex="2795">
if (phdr[cnt].p_type == PT_TLS) <br nodeIndex="2796">
{ <br nodeIndex="2797">
void *tlsblock; <br nodeIndex="2798">
size_t max_align = MAX (TLS_INIT_TCB_ALIGN, phdr[cnt].p_align); <br nodeIndex="2799">
char *p;</p>
<p brd="1" nodeIndex="429">bootstrap_map.l_tls_blocksize = phdr[cnt].p_memsz; <br nodeIndex="2800">
bootstrap_map.l_tls_align = phdr[cnt].p_align; <br nodeIndex="2801">
assert (bootstrap_map.l_tls_blocksize != 0); <br nodeIndex="2802">
bootstrap_map.l_tls_initimage_size = phdr[cnt].p_filesz; <br nodeIndex="2803">
bootstrap_map.l_tls_initimage = (void *) (bootstrap_map.l_addr <br nodeIndex="2804">
+ phdr[cnt].p_vaddr);</p>
<p brd="1" nodeIndex="430">/* We can now allocate the initial TLS block. This can happen <br nodeIndex="2805">
on the stack. We'll get the final memory later when we <br nodeIndex="2806">
know all about the various objects loaded at startup <br nodeIndex="2807">
time. * / <br nodeIndex="2808">
# if TLS_TCB_AT_TP <br nodeIndex="2809">
tlsblock = alloca (roundup (bootstrap_map.l_tls_blocksize, <br nodeIndex="2810">
TLS_INIT_TCB_ALIGN) <br nodeIndex="2811">
+ TLS_INIT_TCB_SIZE <br nodeIndex="2812">
+ max_align); <br nodeIndex="2813">
# elif TLS_DTV_AT_TP <br nodeIndex="2814">
tlsblock = alloca (roundup (TLS_INIT_TCB_SIZE, <br nodeIndex="2815">
bootstrap_map.l_tls_align) <br nodeIndex="2816">
+ bootstrap_map.l_tls_blocksize <br nodeIndex="2817">
+ max_align); <br nodeIndex="2818">
# else <br nodeIndex="2819">
/* In case a model with a different layout for the TCB and DTV <br nodeIndex="2820">
is defined add another #elif here and in the following #ifs. * / <br nodeIndex="2821">
# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined" <br nodeIndex="2822">
# endif <br nodeIndex="2823">
/* Align the TLS block. * / <br nodeIndex="2824">
tlsblock = (void *) (((uintptr_t) tlsblock + max_align - 1) <br nodeIndex="2825">
& ~(max_align - 1));</p>
<p brd="1" nodeIndex="431">/* Initialize the dtv. [0] is the length, [1] the generation <br nodeIndex="2826">
counter. * / <br nodeIndex="2827">
initdtv[0].counter = 1; <br nodeIndex="2828">
initdtv[1].counter = 0;</p>
<p brd="1" nodeIndex="432">/* Initialize the TLS block. * / <br nodeIndex="2829">
# if TLS_TCB_AT_TP <br nodeIndex="2830">
initdtv[2].pointer = tlsblock; <br nodeIndex="2831">
# elif TLS_DTV_AT_TP <br nodeIndex="2832">
bootstrap_map.l_tls_offset = roundup (TLS_INIT_TCB_SIZE, <br nodeIndex="2833">
bootstrap_map.l_tls_align); <br nodeIndex="2834">
initdtv[2].pointer = (char *) tlsblock + bootstrap_map.l_tls_offset; <br nodeIndex="2835">
# else <br nodeIndex="2836">
# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined" <br nodeIndex="2837">
# endif <br nodeIndex="2838">
p = __mempcpy (initdtv[2].pointer, bootstrap_map.l_tls_initimage, <br nodeIndex="2839">
bootstrap_map.l_tls_initimage_size); <br nodeIndex="2840">
# ifdef HAVE_BUILTIN_MEMSET <br nodeIndex="2841">
__builtin_memset (p, '\0', (bootstrap_map.l_tls_blocksize <br nodeIndex="2842">
- bootstrap_map.l_tls_initimage_size)); <br nodeIndex="2843">
# else <br nodeIndex="2844">
{ <br nodeIndex="2845">
size_t remaining = (bootstrap_map.l_tls_blocksize <br nodeIndex="2846">
- bootstrap_map.l_tls_initimage_size); <br nodeIndex="2847">
while (remaining-- > 0) <br nodeIndex="2848">
*p++ = '\0'; <br nodeIndex="2849">
} <br nodeIndex="2850">
#endif</p>
<p brd="1" nodeIndex="433">/* Install the pointer to the dtv. * /</p>
<p brd="1" nodeIndex="434">/* Initialize the thread pointer. * / <br nodeIndex="2851">
# if TLS_TCB_AT_TP <br nodeIndex="2852">
bootstrap_map.l_tls_offset <br nodeIndex="2853">
= roundup (bootstrap_map.l_tls_blocksize, TLS_INIT_TCB_ALIGN);</p>
<p brd="1" nodeIndex="435">INSTALL_DTV ((char *) tlsblock + bootstrap_map.l_tls_offset, <br nodeIndex="2854">
initdtv);</p>
<p brd="1" nodeIndex="436">if (TLS_INIT_TP ((char *) tlsblock + bootstrap_map.l_tls_offset, 0) <br nodeIndex="2855">
!= 0) <br nodeIndex="2856">
_dl_fatal_printf ("cannot setup thread-local storage\n"); <br nodeIndex="2857">
# elif TLS_DTV_AT_TP <br nodeIndex="2858">
INSTALL_DTV (tlsblock, initdtv); <br nodeIndex="2859">
if (TLS_INIT_TP (tlsblock, 0) != 0) <br nodeIndex="2860">
_dl_fatal_printf ("cannot setup thread-local storage\n"); <br nodeIndex="2861">
# else <br nodeIndex="2862">
# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined" <br nodeIndex="2863">
# endif</p>
<p brd="1" nodeIndex="437">/* So far this is module number one. * / <br nodeIndex="2864">
bootstrap_map.l_tls_modid = 1; <br nodeIndex="2865">
/* The TP got initialized. * / <br nodeIndex="2866">
bootstrap_map.l_tls_tp_initialized = 1;</p>
<p brd="1" nodeIndex="438">/* There can only be one PT_TLS entry. * / <br nodeIndex="2867">
break; <br nodeIndex="2868">
} <br nodeIndex="2869">
#endif /* use TLS * / <br nodeIndex="2870">
*/</p>
<p brd="1" nodeIndex="439">//#ifdef ELF_MACHINE_BEFORE_RTLD_RELOC <br nodeIndex="2871">
// ELF_MACHINE_BEFORE_RTLD_RELOC (bootstrap_map.l_info); <br nodeIndex="2872">
//#endif</p>
<p brd="1" nodeIndex="440">if (bootstrap_map.l_addr || ! bootstrap_map.l_info[VALIDX(DT_GNU_PRELINKED)]) <br nodeIndex="2873">
{ <br nodeIndex="2874">
/* Relocate ourselves so we can do normal function calls and 自我重定位，以便能够使用GOT调用函数和访问数据 <br nodeIndex="2875">
data access using the global offset table. */</p>
<p brd="1" nodeIndex="441">ELF_DYNAMIC_RELOCATE (&bootstrap_map, 0, 0); <br nodeIndex="2876">
}</p>
<p brd="1" nodeIndex="442">7._dl_start->ELF_DYNAMIC_RELOCATE (dynamic-link.h)</p>
<p brd="1" nodeIndex="443"> <br nodeIndex="2877">
/* This can't just be an inline function because GCC is too dumb <br nodeIndex="2878">
to inline functions containing inlines themselves. */ <br nodeIndex="2879">
# define ELF_DYNAMIC_RELOCATE(map, lazy, consider_profile) \ <br nodeIndex="2880">
do { \ <br nodeIndex="2881">
int edr_lazy = elf_machine_runtime_setup ((map), (lazy), \ <br nodeIndex="2882">
(consider_profile)); \ <br nodeIndex="2883">
ELF_DYNAMIC_DO_REL ((map), edr_lazy); \ <br nodeIndex="2884">
ELF_DYNAMIC_DO_RELA ((map), edr_lazy); \ <br nodeIndex="2885">
} while (0)</p>
<p brd="1" nodeIndex="444">8._dl_start->ELF_DYNAMIC_RELOCATE ->elf_machine_runtime_setup(sysdeps/i386/dl-machine.h)</p>
<p brd="1" nodeIndex="445">/* Set up the loaded object described by L so its unrelocated PLT <br nodeIndex="2886">
entries will jump to the on-demand fixup code in dl-runtime.c. */</p>
<p brd="1" nodeIndex="446">static inline int //__attribute__ ((unused)) <br nodeIndex="2887">
elf_machine_runtime_setup (struct link_map *l, int lazy, int profile) <br nodeIndex="2888">
{ <br nodeIndex="2889">
Elf32_Addr *got; <br nodeIndex="2890">
extern void _dl_runtime_resolve (Elf32_Word);// attribute_hidden; <br nodeIndex="2891">
extern void _dl_runtime_profile (Elf32_Word);// attribute_hidden;</p>
<p brd="1" nodeIndex="447">if (l->l_info[DT_JMPREL] && lazy)//有JMPREL且lazy <br nodeIndex="2892">
{ <br nodeIndex="2893">
/* The GOT entries for functions in the PLT have not yet been filled <br nodeIndex="2894">
in. Their initial contents will arrange when called to push an <br nodeIndex="2895">
offset into the .rel.plt section, push _GLOBAL_OFFSET_TABLE_[1], <br nodeIndex="2896">
and then jump to _GLOBAL_OFFSET_TABLE[2]. */ <br nodeIndex="2897">
got = (Elf32_Addr *) D_PTR (l, l_info[DT_PLTGOT]);//取PLTGOT地址 <br nodeIndex="2898">
/* If a library is prelinked but we have to relocate anyway, <br nodeIndex="2899">
we have to be able to undo the prelinking of .got.plt. <br nodeIndex="2900">
The prelinker saved us here address of .plt + 0x16. */ <br nodeIndex="2901">
/* <br nodeIndex="2902">
[zws@mail elf]$ readelf -x 21 a.out</p>
<p brd="1" nodeIndex="448">Hex dump of section '.got.plt': <br nodeIndex="2903">
0x080494e8 1c940408 00000000 00000000 5e820408 ............^... <br nodeIndex="2904">
0x080494f8 6e820408 n...</p>
<p brd="1" nodeIndex="449">第一个存放.dynamic节的地址 <br nodeIndex="2905">
第二个存放link_map地址 <br nodeIndex="2906">
第三个存放_dl_runtime_resolve地址 <br nodeIndex="2907">
*/ <br nodeIndex="2908">
if (got[1]) <br nodeIndex="2909">
{ <br nodeIndex="2910">
l->l_mach.plt = got[1] + l->l_addr; <br nodeIndex="2911">
l->l_mach.gotplt = (Elf32_Addr) &got[3]; <br nodeIndex="2912">
} <br nodeIndex="2913">
got[1] = (Elf32_Addr) l; /* Identify this shared object.存放本模块的link_map */</p>
<p brd="1" nodeIndex="450">/* The got[2] entry contains the address of a function which gets <br nodeIndex="2914">
called to get the address of a so far unresolved function and <br nodeIndex="2915">
jump to it. The profiling extension of the dynamic linker allows <br nodeIndex="2916">
to intercept the calls to collect information. In this case we <br nodeIndex="2917">
don't store the address in the GOT so that all future calls also <br nodeIndex="2918">
end in this function. */ <br nodeIndex="2919">
if (__builtin_expect (profile, 0)) <br nodeIndex="2920">
{ <br nodeIndex="2921">
got[2] = (Elf32_Addr) &_dl_runtime_profile;</p>
<p brd="1" nodeIndex="451">if (_dl_name_match_p (GL(dl_profile), l)) <br nodeIndex="2922">
/* This is the object we are looking for. Say that we really <br nodeIndex="2923">
want profiling and the timers are started. */ <br nodeIndex="2924">
GL(dl_profile_map) = l; <br nodeIndex="2925">
} <br nodeIndex="2926">
else <br nodeIndex="2927">
/* This function will get called to fix up the GOT entry indicated by <br nodeIndex="2928">
the offset on the stack, and then jump to the resolved address. */ <br nodeIndex="2929">
got[2] = (Elf32_Addr) &_dl_runtime_resolve;//存放解析函数 <br nodeIndex="2930">
}</p>
<p brd="1" nodeIndex="452">return lazy; <br nodeIndex="2931">
}</p>
<p brd="1" nodeIndex="453">前面传给lazy参数值为0,因此直接返回0，接下来的两个宏定义如下,注意lazy==0</p>
<p brd="1" nodeIndex="454">#define ELF_DYNAMIC_DO_REL(map,lazy) _ELF_DYNAMIC_DO_RELOC (REL, rel, map, lazy, _ELF_CHECK_REL) <br nodeIndex="2932">
#define ELF_DYNAMIC_DO_RELA(map,lazy)</p>
<p brd="1" nodeIndex="455">9._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC(elf/dynamic-link.h) <br nodeIndex="2933">
处理.rel.dyn和.rel.plt重定位节</p>
<p brd="1" nodeIndex="456"># define _ELF_DYNAMIC_DO_RELOC(RELOC, reloc, map, do_lazy, test_rel) \ <br nodeIndex="2934">
do { \ <br nodeIndex="2935">
struct { ElfW(Addr) start, size; int lazy; } ranges[2]; \ <br nodeIndex="2936">
ranges[0].lazy = 0; \ <br nodeIndex="2937">
ranges[0].size = ranges[1].size = 0; \ <br nodeIndex="2938">
ranges[0].start = 0; \ <br nodeIndex="2939">
\ <br nodeIndex="2940">
if ((map)->l_info[DT_##RELOC]) /* DT_REL,是否有.rel.dyn节,0x00000011 (REL) 0x858*/ \ <br nodeIndex="2941">
{ \ <br nodeIndex="2942">
ranges[0].start = D_PTR ((map), l_info[DT_##RELOC]);/*节地址，节长*/ \ <br nodeIndex="2943">
ranges[0].size = (map)->l_info[DT_##RELOC##SZ]->d_un.d_val;/* 0x00000012 (RELSZ) 112 (bytes)*/ \ <br nodeIndex="2944">
} \ <br nodeIndex="2945">
if ((map)->l_info[DT_PLTREL]/*是否有.rel.plt <br nodeIndex="2946">
节， 0x00000014 (PLTREL) REL*/ \ <br nodeIndex="2947">
&& (!test_rel/*test_rel==0*/ || (map)->l_info[DT_PLTREL]->d_un.d_val == DT_##RELOC/*值是否为DT_REL*/)) \ <br nodeIndex="2948">
{ \ <br nodeIndex="2949">
ElfW(Addr) start = D_PTR ((map), l_info[DT_JMPREL]); /*.rel.plt节地址, 0x00000017 (JMPREL) 0x8c8*/ \ <br nodeIndex="2950">
\ <br nodeIndex="2951">
if (! ELF_DURING_STARTUP /*该宏定位为1*/ \ <br nodeIndex="2952">
&& ((do_lazy)/*do_lazy==0*/ \ <br nodeIndex="2953">
/* This test does not only detect whether the relocation \ <br nodeIndex="2954">
sections are in the right order, it also checks whether \ <br nodeIndex="2955">
there is a DT_REL/DT_RELA section. */ \ <br nodeIndex="2956">
|| ranges[0].start + ranges[0].size != start))/*.rel.dyn节和.rel.plt节不连续*/ \ <br nodeIndex="2957">
{ \ <br nodeIndex="2958">
ranges[1].start = start; \ <br nodeIndex="2959">
ranges[1].size = (map)->l_info[DT_PLTRELSZ]->d_un.d_val; \ <br nodeIndex="2960">
ranges[1].lazy = (do_lazy); \ <br nodeIndex="2961">
} \ <br nodeIndex="2962">
else \ <br nodeIndex="2963">
{ \ <br nodeIndex="2964">
/* Combine processing the sections.显然应该走这里 */ \ <br nodeIndex="2965">
assert (ranges[0].start + ranges[0].size == start); /*地址连续*/ \ <br nodeIndex="2966">
ranges[0].size += (map)->l_info[DT_PLTRELSZ]->d_un.d_val;/*合并大小, 0x00000002 (PLTRELSZ) 72 (bytes)*/ \ <br nodeIndex="2967">
} \ <br nodeIndex="2968">
} \ <br nodeIndex="2969">
\ <br nodeIndex="2970">
if (ELF_DURING_STARTUP) /*1*/ \ <br nodeIndex="2971">
elf_dynamic_do_##reloc ((map), ranges[0].start, ranges[0].size, 0); /*调用elf_dynamic_do_rel */ \ <br nodeIndex="2972">
else \ <br nodeIndex="2973">
{ \ <br nodeIndex="2974">
int ranges_index; \ <br nodeIndex="2975">
for (ranges_index = 0; ranges_index < 2; ++ranges_index) \ <br nodeIndex="2976">
elf_dynamic_do_##reloc ((map), \ <br nodeIndex="2977">
ranges[ranges_index].start, \ <br nodeIndex="2978">
ranges[ranges_index].size, \ <br nodeIndex="2979">
ranges[ranges_index].lazy); \ <br nodeIndex="2980">
} \ <br nodeIndex="2981">
} while (0)</p>
<p brd="1" nodeIndex="457">看看ld.so的重定位信息 <br nodeIndex="2982">
[zws@mail ~/glibc-2.3/build/elf]$readelf -r ld.so</p>
<p brd="1" nodeIndex="458">Relocation section '.rel.dyn' at offset 0x858 contains 14 entries: <br nodeIndex="2983">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2984">
000120c0 00000008 R_386_RELATIVE <br nodeIndex="2985">
000120c8 00000008 R_386_RELATIVE <br nodeIndex="2986">
000120d8 00000008 R_386_RELATIVE <br nodeIndex="2987">
000120dc 00000008 R_386_RELATIVE <br nodeIndex="2988">
000120e0 00000008 R_386_RELATIVE <br nodeIndex="2989">
000120b0 00000106 R_386_GLOB_DAT 000126d0 __libc_internal_tsd_se <br nodeIndex="2990">
000120b4 00000206 R_386_GLOB_DAT 00012140 _rtld_global <br nodeIndex="2991">
000120b8 00000606 R_386_GLOB_DAT 00000000 __pthread_mutex_lock <br nodeIndex="2992">
000120bc 00000706 R_386_GLOB_DAT 000126d4 __libc_stack_end <br nodeIndex="2993">
000120c4 00000a06 R_386_GLOB_DAT 00000000 __pthread_mutex_init <br nodeIndex="2994">
000120cc 00001106 R_386_GLOB_DAT 000126e4 __libc_internal_tsd_ge <br nodeIndex="2995">
000120d0 00001306 R_386_GLOB_DAT 00000000 __pthread_mutex_unlock <br nodeIndex="2996">
000120d4 00001806 R_386_GLOB_DAT 00000000 __pthread_mutex_destro <br nodeIndex="2997">
000120e4 00002606 R_386_GLOB_DAT 000126f8 _r_debug</p>
<p brd="1" nodeIndex="459">Relocation section '.rel.plt' at offset 0x8c8 contains 9 entries: <br nodeIndex="2998">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="2999">
000120f4 00000607 R_386_JUMP_SLOT 00000000 __pthread_mutex_lock <br nodeIndex="3000">
000120f8 00000907 R_386_JUMP_SLOT 0000bdc4 __libc_memalign <br nodeIndex="3001">
000120fc 00000a07 R_386_JUMP_SLOT 00000000 __pthread_mutex_init <br nodeIndex="3002">
00012100 00000b07 R_386_JUMP_SLOT 0000bea0 malloc <br nodeIndex="3003">
00012104 00001207 R_386_JUMP_SLOT 0000bec2 calloc <br nodeIndex="3004">
00012108 00001307 R_386_JUMP_SLOT 00000000 __pthread_mutex_unlock <br nodeIndex="3005">
0001210c 00001807 R_386_JUMP_SLOT 00000000 __pthread_mutex_destro <br nodeIndex="3006">
00012110 00001b07 R_386_JUMP_SLOT 0000bf25 realloc <br nodeIndex="3007">
00012114 00002907 R_386_JUMP_SLOT 0000beff free <br nodeIndex="3008">
[zws@mail ~/glibc-2.3/build/elf]$</p>
<p brd="1" nodeIndex="460">10._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC->elf_dynamic_do_rel(elf/dynamic-link.h) <br nodeIndex="3009">
执行实质的重定位操作</p>
<p brd="1" nodeIndex="461">/* Perform the relocations in MAP on the running program image as specified <br nodeIndex="3010">
by RELTAG, SZTAG. If LAZY is nonzero, this is the first pass on PLT <br nodeIndex="3011">
relocations; they should be set up to call _dl_runtime_resolve, rather <br nodeIndex="3012">
than fully resolved now. */</p>
<p brd="1" nodeIndex="462">static inline void <br nodeIndex="3013">
elf_dynamic_do_rel (struct link_map *map, <br nodeIndex="3014">
ElfW(Addr) reladdr, ElfW(Addr) relsize, <br nodeIndex="3015">
int lazy) <br nodeIndex="3016">
{ <br nodeIndex="3017">
const ElfW(Rel) *r = (const void *) reladdr; <br nodeIndex="3018">
const ElfW(Rel) *end = (const void *) (reladdr + relsize); <br nodeIndex="3019">
ElfW(Addr) l_addr = map->l_addr; <br nodeIndex="3020">
/* <br nodeIndex="3021">
#if (!defined DO_RELA || !defined ELF_MACHINE_PLT_REL) && !defined RTLD_BOOTSTRAP <br nodeIndex="3022">
/* We never bind lazily during ld.so bootstrap. Unfortunately gcc is <br nodeIndex="3023">
not clever enough to see through all the function calls to realize <br nodeIndex="3024">
that. * / <br nodeIndex="3025">
if (lazy) <br nodeIndex="3026">
{ <br nodeIndex="3027">
/* Doing lazy PLT relocations; they need very little info. * / <br nodeIndex="3028">
for (; r < end; ++r) <br nodeIndex="3029">
elf_machine_lazy_rel (map, l_addr, r); <br nodeIndex="3030">
} <br nodeIndex="3031">
else <br nodeIndex="3032">
#endif <br nodeIndex="3033">
*/ <br nodeIndex="3034">
{ <br nodeIndex="3035">
const ElfW(Sym) *const symtab = <br nodeIndex="3036">
(const void *) D_PTR (map, l_info[DT_SYMTAB]);//取符号表 <br nodeIndex="3037">
ElfW(Word) nrelative = (map->l_info[RELCOUNT_IDX] == NULL <br nodeIndex="3038">
? 0 : map->l_info[RELCOUNT_IDX]->d_un.d_val);//R_386_RELATIVE重定位项个数 0x6ffffffa (RELCOUNT) 5 <br nodeIndex="3039">
const ElfW(Rel) *relative = r;// 0x00000011 (REL) 0x858 <br nodeIndex="3040">
r = r + MIN (nrelative, relsize / sizeof (ElfW(Rel))); <br nodeIndex="3041">
/* <br nodeIndex="3042">
#ifndef RTLD_BOOTSTRAP <br nodeIndex="3043">
/* This is defined in rtld.c, but nowhere in the static libc.a; make <br nodeIndex="3044">
the reference weak so static programs can still link. This <br nodeIndex="3045">
declaration cannot be done when compiling rtld.c (i.e. #ifdef <br nodeIndex="3046">
RTLD_BOOTSTRAP) because rtld.c contains the common defn for <br nodeIndex="3047">
_dl_rtld_map, which is incompatible with a weak decl in the same <br nodeIndex="3048">
file. * / <br nodeIndex="3049">
# ifndef SHARED <br nodeIndex="3050">
weak_extern (GL(dl_rtld_map)); <br nodeIndex="3051">
# endif <br nodeIndex="3052">
if (map != &GL(dl_rtld_map)) /* Already done in rtld itself. * / <br nodeIndex="3053">
# if !defined DO_RELA || defined ELF_MACHINE_REL_RELATIVE <br nodeIndex="3054">
/* Rela platforms get the offset from r_addend and this must <br nodeIndex="3055">
be copied in the relocation address. Therefore we can skip <br nodeIndex="3056">
the relative relocations only if this is for rel <br nodeIndex="3057">
relocations or rela relocations if they are computed as <br nodeIndex="3058">
memory_loc += l_addr... * / <br nodeIndex="3059">
if (l_addr != 0) <br nodeIndex="3060">
# else <br nodeIndex="3061">
/* ...or we know the object has been prelinked. * / <br nodeIndex="3062">
if (l_addr != 0 || ! map->l_info[VALIDX(DT_GNU_PRELINKED)]) <br nodeIndex="3063">
# endif <br nodeIndex="3064">
#endif <br nodeIndex="3065">
*/ <br nodeIndex="3066">
for (; relative < r; ++relative) <br nodeIndex="3067">
DO_ELF_MACHINE_REL_RELATIVE (map, l_addr, relative);//先处理前面的相对重定位</p>
<p brd="1" nodeIndex="463">11._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC->elf_dynamic_do_rel->DO_ELF_MACHINE_REL_RELATIVE (elf/do-rel.h) <br nodeIndex="3068">
重定位R_386_RELATIVE重定位项</p>
<p brd="1" nodeIndex="464"># define DO_ELF_MACHINE_REL_RELATIVE(map, l_addr, relative) \ <br nodeIndex="3069">
elf_machine_rel_relative (l_addr, relative, \ <br nodeIndex="3070">
(void *) (l_addr + relative->r_offset))</p>
<p brd="1" nodeIndex="465">11._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC->elf_dynamic_do_rel->DO_ELF_MACHINE_REL_RELATIVE-> elf_machine_rel_relative (sysdeps/i386/dl-machine.h)</p>
<p brd="1" nodeIndex="466">static inline void <br nodeIndex="3071">
elf_machine_rel_relative (Elf32_Addr l_addr, const Elf32_Rel *reloc, <br nodeIndex="3072">
Elf32_Addr *const reloc_addr) <br nodeIndex="3073">
{ <br nodeIndex="3074">
assert (ELF32_R_TYPE (reloc->r_info) == R_386_RELATIVE);//肯定是R_386_RELATIVE重定位类型 <br nodeIndex="3075">
*reloc_addr += l_addr;//原地址加上模块加载地址 <br nodeIndex="3076">
}</p>
<p brd="1" nodeIndex="467">12._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC->elf_dynamic_do_rel(elf/dynamic-link.h)</p>
<p brd="1" nodeIndex="468"> <br nodeIndex="3077">
//#ifdef RTLD_BOOTSTRAP <br nodeIndex="3078">
/* The dynamic linker always uses versioning. */ <br nodeIndex="3079">
assert (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL);//动态链接器总是使用版本信息 <br nodeIndex="3080">
//#else <br nodeIndex="3081">
// if (map->l_info[VERSYMIDX (DT_VERSYM)]) <br nodeIndex="3082">
//#endif <br nodeIndex="3083">
{ <br nodeIndex="3084">
const ElfW(Half) *const version = <br nodeIndex="3085">
(const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);//0x6ffffff0 (VERSYM) 0x75c</p>
<p brd="1" nodeIndex="469">for (; r < end; ++r) <br nodeIndex="3086">
{ <br nodeIndex="3087">
ElfW(Half) ndx = version[ELFW(R_SYM) (r->r_info)] & 0x7fff; <br nodeIndex="3088">
elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)], <br nodeIndex="3089">
&map->l_versions[ndx], <br nodeIndex="3090">
(void *) (l_addr + r->r_offset)); <br nodeIndex="3091">
/*等价于 <br nodeIndex="3092">
Elf32_Half ndx = version[((r->r_info) >> 8)] & 0x7fff; <br nodeIndex="3093">
elf_machine_rel (map, r, &symtab[((r->r_info) >> 8)], <br nodeIndex="3094">
&map->l_versions[ndx], <br nodeIndex="3095">
(void *) (l_addr + r->r_offset));</p>
<p brd="1" nodeIndex="470">*/ <br nodeIndex="3096">
} <br nodeIndex="3097">
} <br nodeIndex="3098">
/* <br nodeIndex="3099">
#ifndef RTLD_BOOTSTRAP <br nodeIndex="3100">
else <br nodeIndex="3101">
for (; r < end; ++r) <br nodeIndex="3102">
elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)], NULL, <br nodeIndex="3103">
(void *) (l_addr + r->r_offset)); <br nodeIndex="3104">
#endif <br nodeIndex="3105">
*/ <br nodeIndex="3106">
} <br nodeIndex="3107">
}</p>
<p brd="1" nodeIndex="471"> <br nodeIndex="3108">
ld.so的版本符号表是 <br nodeIndex="3109">
[zws@mail ~/glibc-2.3/build/elf]$objdump -sj .gnu.version ld.so</p>
<p brd="1" nodeIndex="472">ld.so: file format elf32-i386</p>
<p brd="1" nodeIndex="473">Contents of section .gnu.version: <br nodeIndex="3110">
075c 00000500 05000500 05000500 00000500 ................ <br nodeIndex="3111">
076c 05000200 00000200 05000300 05000500 ................ <br nodeIndex="3112">
077c 05000500 02000000 05000500 05000500 ................ <br nodeIndex="3113">
078c 00000200 05000200 05000500 05000500 ................ <br nodeIndex="3114">
079c 05000500 05000300 05000500 02000500 ................ <br nodeIndex="3115">
07ac 04000200 0500 ......</p>
<p brd="1" nodeIndex="474">typedef uint16_t Elf32_Half;</p>
<p brd="1" nodeIndex="475">map->l_versions其实为空，不过elf_machine_rel 中没有用到</p>
<p brd="1" nodeIndex="476">11._dl_start->ELF_DYNAMIC_RELOCATE ->_ELF_DYNAMIC_DO_RELOC->elf_dynamic_do_rel->DO_ELF_MACHINE_REL_RELATIVE-> elf_machine_relmap->l_versions其实为空，不过elf_machine_rel (sysdeps/i386/dl-machine.h)</p>
<p brd="1" nodeIndex="477">/* Perform the relocation specified by RELOC and SYM (which is fully resolved). <br nodeIndex="3116">
MAP is the object containing the reloc. */</p>
<p brd="1" nodeIndex="478">static inline void <br nodeIndex="3117">
elf_machine_rel (struct link_map *map, const Elf32_Rel *reloc, <br nodeIndex="3118">
const Elf32_Sym *sym, const struct r_found_version *version, <br nodeIndex="3119">
Elf32_Addr *const reloc_addr) <br nodeIndex="3120">
{ <br nodeIndex="3121">
const unsigned int r_type = ELF32_R_TYPE (reloc->r_info); <br nodeIndex="3122">
/* <br nodeIndex="3123">
#if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC <br nodeIndex="3124">
if (__builtin_expect (r_type == R_386_RELATIVE, 0)) <br nodeIndex="3125">
{ <br nodeIndex="3126">
# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC <br nodeIndex="3127">
/* This is defined in rtld.c, but nowhere in the static libc.a; <br nodeIndex="3128">
make the reference weak so static programs can still link. <br nodeIndex="3129">
This declaration cannot be done when compiling rtld.c <br nodeIndex="3130">
(i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the <br nodeIndex="3131">
common defn for _dl_rtld_map, which is incompatible with a <br nodeIndex="3132">
weak decl in the same file. * / <br nodeIndex="3133">
# ifndef SHARED <br nodeIndex="3134">
weak_extern (_dl_rtld_map); <br nodeIndex="3135">
# endif <br nodeIndex="3136">
if (map != &GL(dl_rtld_map)) /* Already done in rtld itself. * / <br nodeIndex="3137">
# endif <br nodeIndex="3138">
*reloc_addr += map->l_addr; <br nodeIndex="3139">
} <br nodeIndex="3140">
# ifndef RTLD_BOOTSTRAP <br nodeIndex="3141">
else if (__builtin_expect (r_type == R_386_NONE, 0)) <br nodeIndex="3142">
return; <br nodeIndex="3143">
# endif <br nodeIndex="3144">
else <br nodeIndex="3145">
#endif <br nodeIndex="3146">
*/ <br nodeIndex="3147">
{ <br nodeIndex="3148">
const Elf32_Sym *const refsym = sym; <br nodeIndex="3149">
//#if defined USE_TLS && !defined RTLD_BOOTSTRAP <br nodeIndex="3150">
// struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type); <br nodeIndex="3151">
// Elf32_Addr value = sym == NULL ? 0 : sym_map->l_addr + sym->st_value; <br nodeIndex="3152">
//#else <br nodeIndex="3153">
Elf32_Addr value = RESOLVE (&sym, version, r_type);//等价于Elf32_Addr value = ((*(&sym))->st_shndx == 0 ? 0 : _rtld_local._dl_rtld_map.l_addr);</p>
<p brd="1" nodeIndex="479">//# ifndef RTLD_BOOTSTRAP <br nodeIndex="3154">
// if (sym != NULL) <br nodeIndex="3155">
//# endif <br nodeIndex="3156">
value += sym->st_value;//加上sym->st_value中的值 <br nodeIndex="3157">
//#endif</p>
<p brd="1" nodeIndex="480">switch (r_type) <br nodeIndex="3158">
{ <br nodeIndex="3159">
case R_386_GLOB_DAT: //ld.so中只有这两个 <br nodeIndex="3160">
case R_386_JMP_SLOT: <br nodeIndex="3161">
*reloc_addr = value; <br nodeIndex="3162">
break;</p>

<p brd="1" nodeIndex="482"> <br nodeIndex="3163">
一路返回到_dl_start中,就完成重定位了。 <br nodeIndex="3164">
大家想一想如何保证到现在还没有用到重定位的数据? <br nodeIndex="3165">
通过全部使用inline函数或宏,且只使用_rtld_local(vis为hidden)和局部变量来保证.</p>
<p brd="1" nodeIndex="483">12.返回_dl_start，完成动态链接</p>
<p brd="1" nodeIndex="484">/* Please note that we don't allow profiling of this object and <br nodeIndex="3166">
therefore need not test whether we have to allocate the array <br nodeIndex="3167">
for the relocation results (as done in dl-reloc.c). */</p>
<p brd="1" nodeIndex="485">/* Now life is sane; we can call functions and access global data. <br nodeIndex="3168">
Set up to use the operating system facilities, and find out from <br nodeIndex="3169">
the operating system's program loader where to find the program <br nodeIndex="3170">
header table in core. Put the rest of _dl_start into a separate <br nodeIndex="3171">
将_dl_start中剩下的工作放在独立的函数中，这样编译器就不会将需要 <br nodeIndex="3172">
function, that way the compiler cannot put accesses to the GOT <br nodeIndex="3173">
访问GOT的操作放在ELF_DYNAMIC_RELOCATE之前 <br nodeIndex="3174">
before ELF_DYNAMIC_RELOCATE. */ <br nodeIndex="3175">
{ <br nodeIndex="3176">
//#ifdef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="3177">
ElfW(Addr) entry = _dl_start_final (arg);//完成动态链接，返回可执行文件入口 <br nodeIndex="3178">
//#else <br nodeIndex="3179">
// ElfW(Addr) entry = _dl_start_final (arg, &info); <br nodeIndex="3180">
//#endif</p>
<p brd="1" nodeIndex="486">//#ifndef ELF_MACHINE_START_ADDRESS <br nodeIndex="3181">
# define ELF_MACHINE_START_ADDRESS(map, start) (start) <br nodeIndex="3182">
//#endif</p>
<p brd="1" nodeIndex="487">return ELF_MACHINE_START_ADDRESS (GL(dl_loaded), entry);//等价于return entry; <br nodeIndex="3183">
} <br nodeIndex="3184">
} <br nodeIndex="3185">
ld.so 分析之6 _dl_start_final</p>
<p brd="1" nodeIndex="488">1.setup hash</p>
<p brd="1" nodeIndex="489">/* This is the second half of _dl_start (below). It can be inlined safely <br nodeIndex="3186">
这是_dl_start的第二部分. <br nodeIndex="3187">
under DONT_USE_BOOTSTRAP_MAP, where it is careful not to make any GOT <br nodeIndex="3188">
在DONT_USE_BOOTSTRAP_MAP下它能被安全内联,在DONT_USE_BOOTSTRAP_MAP下不允许引用GOT <br nodeIndex="3189">
references. When the tools don't permit us to avoid using a GOT entry <br nodeIndex="3190">
for _dl_rtld_global (no attribute_hidden support), we must make sure <br nodeIndex="3191">
this function is not inlined (see below). <br nodeIndex="3192">
当编译器允许我们使用GOT访问_dl_rtld_global,我们必须让f该函数不内联 <br nodeIndex="3193">
*/</p>
<p brd="1" nodeIndex="490">//#ifdef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="3194">
static inline Elf32_Addr// <br nodeIndex="3195">
//ElfW(Addr) __attribute__ ((always_inline)) 总是内联 <br nodeIndex="3196">
_dl_start_final (void *arg) <br nodeIndex="3197">
//#else <br nodeIndex="3198">
//static ElfW(Addr) __attribute__ ((noinline)) <br nodeIndex="3199">
//_dl_start_final (void *arg, struct dl_start_final_info *info) <br nodeIndex="3200">
//#endif <br nodeIndex="3201">
{ <br nodeIndex="3202">
ElfW(Addr) start_addr;</p>
<p brd="1" nodeIndex="491">if (HP_TIMING_AVAIL)// 1 <br nodeIndex="3203">
{ <br nodeIndex="3204">
/* If it hasn't happen yet record the startup time. */ <br nodeIndex="3205">
// if (! HP_TIMING_INLINE)// 1 <br nodeIndex="3206">
// HP_TIMING_NOW (start_time); <br nodeIndex="3207">
//#if !defined DONT_USE_BOOTSTRAP_MAP && !defined HP_TIMING_NONAVAIL <br nodeIndex="3208">
// else <br nodeIndex="3209">
// start_time = info->start_time; <br nodeIndex="3210">
//#endif</p>
<p brd="1" nodeIndex="492">/* Initialize the timing functions. */ <br nodeIndex="3211">
HP_TIMING_DIFF_INIT (); <br nodeIndex="3212">
}</p>
<p brd="1" nodeIndex="493">/* Transfer data about ourselves to the permanent link_map structure. */ <br nodeIndex="3213">
/* <br nodeIndex="3214">
#ifndef DONT_USE_BOOTSTRAP_MAP <br nodeIndex="3215">
GL(dl_rtld_map).l_addr = info->l.l_addr; <br nodeIndex="3216">
GL(dl_rtld_map).l_ld = info->l.l_ld; <br nodeIndex="3217">
memcpy (GL(dl_rtld_map).l_info, info->l.l_info, <br nodeIndex="3218">
sizeof GL(dl_rtld_map).l_info); <br nodeIndex="3219">
GL(dl_rtld_map).l_mach = info->l.l_mach; <br nodeIndex="3220">
#endif <br nodeIndex="3221">
*/ <br nodeIndex="3222">
_dl_setup_hash (&GL(dl_rtld_map));// _dl_setup_hash (&_rtld_local._dl_rtld_map); <br nodeIndex="3223">
GL(dl_rtld_map).l_opencount = 1;</p>
<p brd="1" nodeIndex="494">2._dl_start_final->_dl_setup_hash</p>
<p brd="1" nodeIndex="495">/* Cache the location of MAP's hash table. */</p>
<p brd="1" nodeIndex="496">void <br nodeIndex="3224">
//internal_function <br nodeIndex="3225">
_dl_setup_hash (struct link_map *map) <br nodeIndex="3226">
{ <br nodeIndex="3227">
Elf_Symndx *hash;//typedef uint32_t Elf_Symndx; <br nodeIndex="3228">
Elf_Symndx nchain;</p>
<p brd="1" nodeIndex="497">if (!map->l_info[DT_HASH])// 例如ld.so的0x00000004 (HASH) 0x94 <br nodeIndex="3229">
return; <br nodeIndex="3230">
hash = (void *) D_PTR (map, l_info[DT_HASH]);//map->l_info[DT_HASH]->d_un.d_ptr,取hash表地址</p>
<p brd="1" nodeIndex="498">map->l_nbuckets = *hash++; <br nodeIndex="3231">
nchain = *hash++; <br nodeIndex="3232">
map->l_buckets = hash; <br nodeIndex="3233">
hash += map->l_nbuckets; <br nodeIndex="3234">
map->l_chain = hash; <br nodeIndex="3235">
}</p>
<p brd="1" nodeIndex="499">ld.so hash表的内容是 <br nodeIndex="3236">
[zws@mail ~/glibc-2.3/build/elf]$ objdump -sj .hash ld.so</p>
<p brd="1" nodeIndex="500">ld.so: file format elf32-i386</p>
<p brd="1" nodeIndex="501">Contents of section .hash: <br nodeIndex="3237">
0094 25000000 2b000000 0d000000 21000000 %...+.......!... <br nodeIndex="3238">
00a4 28000000 00000000 06000000 22000000 (..........."... <br nodeIndex="3239">
00b4 00000000 00000000 00000000 08000000 ................ <br nodeIndex="3240">
00c4 1e000000 00000000 1a000000 23000000 ............#... <br nodeIndex="3241">
00d4 26000000 0e000000 1d000000 17000000 &............... <br nodeIndex="3242">
00e4 25000000 24000000 00000000 13000000 %...$........... <br nodeIndex="3243">
00f4 00000000 0b000000 18000000 14000000 ................ <br nodeIndex="3244">
0104 27000000 1b000000 00000000 15000000 '............... <br nodeIndex="3245">
0114 00000000 29000000 1c000000 00000000 ....)........... <br nodeIndex="3246">
0124 0c000000 2a000000 19000000 00000000 ....*........... <br nodeIndex="3247">
0134 00000000 00000000 00000000 00000000 ................ <br nodeIndex="3248">
0144 00000000 00000000 00000000 00000000 ................ <br nodeIndex="3249">
0154 00000000 00000000 00000000 00000000 ................ <br nodeIndex="3250">
0164 05000000 02000000 03000000 07000000 ................ <br nodeIndex="3251">
0174 00000000 10000000 00000000 00000000 ................ <br nodeIndex="3252">
0184 00000000 00000000 00000000 00000000 ................ <br nodeIndex="3253">
0194 00000000 00000000 00000000 11000000 ................ <br nodeIndex="3254">
01a4 01000000 0a000000 00000000 0f000000 ................ <br nodeIndex="3255">
01b4 00000000 09000000 20000000 04000000 ........ ....... <br nodeIndex="3256">
01c4 00000000 16000000 12000000 00000000 ................ <br nodeIndex="3257">
01d4 00000000 1f000000 ........</p>
<p brd="1" nodeIndex="502"> <br nodeIndex="3258">
hash表的作用是加快链接速度。当在动态链接库中查找是否有需要被外部链接的函数时， <br nodeIndex="3259">
如果直接线性搜索库的动态符号表且表比较大，速度很慢。采用散列的方法查找就比较好。</p>
<p brd="1" nodeIndex="503">这里l_nbuckets值为0x25=37,nchain 值为0x2b=43,l_buckets存放散列表入口,l_chain用于将散列值相同的符号连接成单链表。 <br nodeIndex="3260">
nchain其实就是动态符号数。该链表中第一个符号索引值A存在l_buckets中，下一个符号的索引值B存放在索引值A在l_chain中的偏移处等等。</p>
<p brd="1" nodeIndex="504">问题1.hash表大小是如何计算的？</p>
<p brd="1" nodeIndex="505">由binutils 1.18 的bfd/elflink.c文件中compute_bucket_count 计算</p>
<p brd="1" nodeIndex="506">/* Array used to determine the number of hash table buckets to use <br nodeIndex="3261">
based on the number of symbols there are. If there are fewer than <br nodeIndex="3262">
定义一个数组用于根据符号数来计算hash表大小 <br nodeIndex="3263">
3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets, <br nodeIndex="3264">
少于3个符号使用一个桶，少于17个符号使用3个桶 <br nodeIndex="3265">
fewer than 37 we use 17 buckets, and so forth. We never use more <br nodeIndex="3266">
少于37个符号使用17个桶,等等 <br nodeIndex="3267">
than 32771 buckets. <br nodeIndex="3268">
我们从不使用超过32771个桶的hash <br nodeIndex="3269">
*/</p>
<p brd="1" nodeIndex="507">static const size_t elf_buckets[] = <br nodeIndex="3270">
{ <br nodeIndex="3271">
1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209, <br nodeIndex="3272">
16411, 32771, 0 <br nodeIndex="3273">
};</p>
<p brd="1" nodeIndex="508">/* Compute bucket count for hashing table. We do not use a static set <br nodeIndex="3274">
of possible tables sizes anymore. Instead we determine for all <br nodeIndex="3275">
possible reasonable sizes of the table the outcome (i.e., the <br nodeIndex="3276">
number of collisions etc) and choose the best solution. The <br nodeIndex="3277">
weighting functions are not too simple to allow the table to grow <br nodeIndex="3278">
without bounds. Instead one of the weighting factors is the size. <br nodeIndex="3279">
Therefore the result is always a good payoff between few collisions <br nodeIndex="3280">
(= short chain lengths) and table size. */ <br nodeIndex="3281">
static size_t <br nodeIndex="3282">
compute_bucket_count (struct bfd_link_info *info, unsigned long int *hashcodes, <br nodeIndex="3283">
unsigned long int nsyms, int gnu_hash) <br nodeIndex="3284">
{ <br nodeIndex="3285">
size_t dynsymcount = elf_hash_table (info)->dynsymcount; <br nodeIndex="3286">
size_t best_size = 0; <br nodeIndex="3287">
unsigned long int i; <br nodeIndex="3288">
bfd_size_type amt;</p>
<p brd="1" nodeIndex="509">/* We have a problem here. The following code to optimize the table <br nodeIndex="3289">
size requires an integer type with more the 32 bits. If <br nodeIndex="3290">
BFD_HOST_U_64_BIT is set we know about such a type. */</p>
<p brd="1" nodeIndex="510">#ifdef BFD_HOST_U_64_BIT <br nodeIndex="3291">
。。。忽略64位系统 <br nodeIndex="3292">
#endif /* defined (BFD_HOST_U_64_BIT) * /</p>
<p brd="1" nodeIndex="511">{ <br nodeIndex="3293">
/* This is the fallback solution if no 64bit type is available or if we <br nodeIndex="3294">
are not supposed to spend much time on optimizations. We select the <br nodeIndex="3295">
bucket count using a fixed set of numbers. */ <br nodeIndex="3296">
for (i = 0; elf_buckets[i] != 0; i++)//循环查找elf_buckets数组 <br nodeIndex="3297">
{ <br nodeIndex="3298">
best_size = elf_buckets[i];//取桶大小 <br nodeIndex="3299">
if (nsyms < elf_buckets[i + 1])//如果符号数小于适用的符号数 <br nodeIndex="3300">
break;//找到 <br nodeIndex="3301">
} <br nodeIndex="3302">
if (gnu_hash && best_size < 2) <br nodeIndex="3303">
best_size = 2; <br nodeIndex="3304">
}</p>
<p brd="1" nodeIndex="512">return best_size; <br nodeIndex="3305">
}</p>
<p brd="1" nodeIndex="513">由于本例中符号数是43，根据计算得桶大小是37,和前面的桶值相等。</p>
<p brd="1" nodeIndex="514"> <br nodeIndex="3306">
问题2:符号的hash值如何计算?</p>
<p brd="1" nodeIndex="515">同样在elflink.c中，由bfd_elf_hash计算</p>
<p brd="1" nodeIndex="516">/* Standard ELF hash function. Do not change this function; you will <br nodeIndex="3307">
cause invalid hash tables to be generated. */</p>
<p brd="1" nodeIndex="517">unsigned long <br nodeIndex="3308">
bfd_elf_hash (const char *namearg) <br nodeIndex="3309">
{ <br nodeIndex="3310">
const unsigned char *name = (const unsigned char *) namearg; <br nodeIndex="3311">
unsigned long h = 0; <br nodeIndex="3312">
unsigned long g; <br nodeIndex="3313">
int ch;</p>
<p brd="1" nodeIndex="518">while ((ch = *name++) != '\0') <br nodeIndex="3314">
{ <br nodeIndex="3315">
h = (h << 4) + ch; <br nodeIndex="3316">
if ((g = (h & 0xf0000000)) != 0) <br nodeIndex="3317">
{ <br nodeIndex="3318">
h ^= g >> 24; <br nodeIndex="3319">
/* The ELF ABI says `h &= ~g', but this is equivalent in <br nodeIndex="3320">
this case and on some machines one insn instead of two. */ <br nodeIndex="3321">
h ^= g; <br nodeIndex="3322">
} <br nodeIndex="3323">
} <br nodeIndex="3324">
return h & 0xffffffff; <br nodeIndex="3325">
}</p>
<p brd="1" nodeIndex="519">一个符号的hash值%桶大小即得其在hash表中的索引.</p>
<p brd="1" nodeIndex="520">问题3.动态符号表的内容是什么？</p>
<p brd="1" nodeIndex="521">动态符号表中存放的是全局符号，包括本地和外地。 <br nodeIndex="3326">
本地提供给其他模块使用，本地符号的Ndx是数，指出该符号所在的节。外地符号的Ndx是UND，需要动态链接。</p>
<p brd="1" nodeIndex="522">例如 <br nodeIndex="3327">
readelf -s ld.so</p>
<p brd="1" nodeIndex="523">Symbol table '.dynsym' contains 43 entries: <br nodeIndex="3328">
Num: Value Size Type Bind Vis Ndx Name <br nodeIndex="3329">
0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br nodeIndex="3330">
1: 000126d0 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_set@@GLIBC_PRIVATE <br nodeIndex="3331">
2: 00012140 980 OBJECT GLOBAL DEFAULT 14 _rtld_global@@GLIBC_PRIVATE <br nodeIndex="3332">
3: 00009f6b 44 FUNC GLOBAL DEFAULT 9 _dl_debug_printf@@GLIBC_PRIVATE <br nodeIndex="3333">
4: 0000a372 1066 FUNC GLOBAL DEFAULT 9 _dl_check_map_versions@@GLIBC_PRIVATE <br nodeIndex="3334">
5: 00006808 757 FUNC GLOBAL DEFAULT 9 _dl_lookup_versioned_symb@@GLIBC_PRIVATE <br nodeIndex="3335">
6: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_lock <br nodeIndex="3336">
7: 000126d4 4 OBJECT GLOBAL DEFAULT 15 __libc_stack_end@@GLIBC_PRIVATE <br nodeIndex="3337">
8: 000096e0 307 FUNC GLOBAL DEFAULT 9 _dl_init@@GLIBC_PRIVATE <br nodeIndex="3338">
9: 0000bdc4 220 FUNC WEAK DEFAULT 9 __libc_memalign@@GLIBC_2.0 <br nodeIndex="3339">
10: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_init <br nodeIndex="3340">
11: 0000bea0 34 FUNC WEAK DEFAULT 9 malloc@@GLIBC_2.0 <br nodeIndex="3341">
12: 00006189 605 FUNC GLOBAL DEFAULT 9 _dl_lookup_symbol_skip@@GLIBC_PRIVATE <br nodeIndex="3342">
13: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.1 <br nodeIndex="3343">
14: 000063e6 1058 FUNC GLOBAL DEFAULT 9 _dl_lookup_versioned_symb@@GLIBC_PRIVATE <br nodeIndex="3344">
15: 00012514 4 OBJECT GLOBAL DEFAULT 14 __libc_enable_secure@@GLIBC_PRIVATE <br nodeIndex="3345">
16: 00005ec4 709 FUNC GLOBAL DEFAULT 9 _dl_lookup_symbol@@GLIBC_PRIVATE <br nodeIndex="3346">
17: 000126e4 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_get@@GLIBC_PRIVATE <br nodeIndex="3347">
18: 0000bec2 61 FUNC WEAK DEFAULT 9 calloc@@GLIBC_2.0 <br nodeIndex="3348">
19: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_unlock <br nodeIndex="3349">
20: 000126ec 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_addre@@GLIBC_PRIVATE <br nodeIndex="3350">
21: 00009b86 5 FUNC GLOBAL DEFAULT 9 _dl_debug_state@@GLIBC_PRIVATE <br nodeIndex="3351">
22: 00012120 4 OBJECT GLOBAL DEFAULT 14 _dl_argv@@GLIBC_PRIVATE <br nodeIndex="3352">
23: 000030db 272 FUNC GLOBAL DEFAULT 9 _dl_dst_substitute@@GLIBC_PRIVATE <br nodeIndex="3353">
24: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_destroy <br nodeIndex="3354">
25: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.0 <br nodeIndex="3355">
26: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_PRIVATE <br nodeIndex="3356">
27: 0000bf25 139 FUNC WEAK DEFAULT 9 realloc@@GLIBC_2.0 <br nodeIndex="3357">
28: 0000b43c 373 FUNC GLOBAL DEFAULT 9 _dl_get_origin@@GLIBC_PRIVATE <br nodeIndex="3358">
29: 0000a868 1981 FUNC GLOBAL DEFAULT 9 _dl_start_profile@@GLIBC_PRIVATE <br nodeIndex="3359">
30: 00007ca0 1072 FUNC GLOBAL DEFAULT 9 _dl_relocate_object@@GLIBC_PRIVATE <br nodeIndex="3360">
31: 00003056 133 FUNC GLOBAL DEFAULT 9 _dl_dst_count@@GLIBC_PRIVATE <br nodeIndex="3361">
32: 00012124 4 OBJECT GLOBAL DEFAULT 14 _dl_starting_up@@GLIBC_PRIVATE <br nodeIndex="3362">
33: 00005b89 75 FUNC GLOBAL DEFAULT 9 _dl_unload_cache@@GLIBC_PRIVATE <br nodeIndex="3363">
34: 0000f460 14 OBJECT GLOBAL DEFAULT 10 _dl_out_of_memory@@GLIBC_PRIVATE <br nodeIndex="3364">
35: 0000b025 562 FUNC GLOBAL DEFAULT 9 _dl_mcount@@GLIBC_2.1 <br nodeIndex="3365">
36: 00004b84 1917 FUNC GLOBAL DEFAULT 9 _dl_map_object@@GLIBC_PRIVATE <br nodeIndex="3366">
37: 000091cc 433 FUNC GLOBAL DEFAULT 9 _dl_signal_error@@GLIBC_PRIVATE <br nodeIndex="3367">
38: 000126f8 20 OBJECT GLOBAL DEFAULT 15 _r_debug@@GLIBC_2.0 <br nodeIndex="3368">
39: 0000940d 318 FUNC GLOBAL DEFAULT 9 _dl_catch_error@@GLIBC_PRIVATE <br nodeIndex="3369">
40: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.3 <br nodeIndex="3370">
41: 0000beff 38 FUNC WEAK DEFAULT 9 free@@GLIBC_2.0 <br nodeIndex="3371">
42: 00008255 3291 FUNC GLOBAL DEFAULT 9 _dl_map_object_deps@@GLIBC_PRIVATE</p>
<p brd="1" nodeIndex="524">符号表的第一个符号总是被保留的.因此实际可用的符号数是42</p>
<p brd="1" nodeIndex="525">上面是通过节表来显示动态符号表的,我们也可以通过动态节来显示动态符号表</p>
<p brd="1" nodeIndex="526">[zws@mail ~/glibc-2.3/build/elf]$readelf -Ds ld.so</p>
<p brd="1" nodeIndex="527">Symbol table for image: <br nodeIndex="3372">
Num Buc: Value Size Type Bind Vis Ndx Name <br nodeIndex="3373">
13 0: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.1 <br nodeIndex="3374">
5 0: 00006808 757 FUNC GLOBAL DEFAULT 9 _dl_lookup_versioned_symbol_skip <br nodeIndex="3375">
33 1: 00005b89 75 FUNC GLOBAL DEFAULT 9 _dl_unload_cache <br nodeIndex="3376">
40 2: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.3 <br nodeIndex="3377">
6 4: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_lock <br nodeIndex="3378">
34 5: 0000f460 14 OBJECT GLOBAL DEFAULT 10 _dl_out_of_memory <br nodeIndex="3379">
9 5: 0000bdc4 220 FUNC WEAK DEFAULT 9 __libc_memalign <br nodeIndex="3380">
8 9: 000096e0 307 FUNC GLOBAL DEFAULT 9 _dl_init <br nodeIndex="3381">
30 10: 00007ca0 1072 FUNC GLOBAL DEFAULT 9 _dl_relocate_object <br nodeIndex="3382">
10 10: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_init <br nodeIndex="3383">
26 12: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_PRIVATE <br nodeIndex="3384">
35 13: 0000b025 562 FUNC GLOBAL DEFAULT 9 _dl_mcount <br nodeIndex="3385">
32 13: 00012124 4 OBJECT GLOBAL DEFAULT 14 _dl_starting_up <br nodeIndex="3386">
15 13: 00012514 4 OBJECT GLOBAL DEFAULT 14 __libc_enable_secure <br nodeIndex="3387">
3 13: 00009f6b 44 FUNC GLOBAL DEFAULT 9 _dl_debug_printf <br nodeIndex="3388">
38 14: 000126f8 20 OBJECT GLOBAL DEFAULT 15 _r_debug <br nodeIndex="3389">
22 14: 00012120 4 OBJECT GLOBAL DEFAULT 14 _dl_argv <br nodeIndex="3390">
14 15: 000063e6 1058 FUNC GLOBAL DEFAULT 9 _dl_lookup_versioned_symbol <br nodeIndex="3391">
2 15: 00012140 980 OBJECT GLOBAL DEFAULT 14 _rtld_global <br nodeIndex="3392">
29 16: 0000a868 1981 FUNC GLOBAL DEFAULT 9 _dl_start_profile <br nodeIndex="3393">
1 16: 000126d0 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_set <br nodeIndex="3394">
23 17: 000030db 272 FUNC GLOBAL DEFAULT 9 _dl_dst_substitute <br nodeIndex="3395">
37 18: 000091cc 433 FUNC GLOBAL DEFAULT 9 _dl_signal_error <br nodeIndex="3396">
36 19: 00004b84 1917 FUNC GLOBAL DEFAULT 9 _dl_map_object <br nodeIndex="3397">
4 19: 0000a372 1066 FUNC GLOBAL DEFAULT 9 _dl_check_map_versions <br nodeIndex="3398">
19 21: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_unlock <br nodeIndex="3399">
11 23: 0000bea0 34 FUNC WEAK DEFAULT 9 malloc <br nodeIndex="3400">
24 24: 00000000 0 NOTYPE WEAK DEFAULT UND __pthread_mutex_destroy <br nodeIndex="3401">
20 25: 000126ec 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_address <br nodeIndex="3402">
39 26: 0000940d 318 FUNC GLOBAL DEFAULT 9 _dl_catch_error <br nodeIndex="3403">
18 26: 0000bec2 61 FUNC WEAK DEFAULT 9 calloc <br nodeIndex="3404">
16 26: 00005ec4 709 FUNC GLOBAL DEFAULT 9 _dl_lookup_symbol <br nodeIndex="3405">
7 26: 000126d4 4 OBJECT GLOBAL DEFAULT 15 __libc_stack_end <br nodeIndex="3406">
27 27: 0000bf25 139 FUNC WEAK DEFAULT 9 realloc <br nodeIndex="3407">
21 29: 00009b86 5 FUNC GLOBAL DEFAULT 9 _dl_debug_state <br nodeIndex="3408">
41 31: 0000beff 38 FUNC WEAK DEFAULT 9 free <br nodeIndex="3409">
28 32: 0000b43c 373 FUNC GLOBAL DEFAULT 9 _dl_get_origin <br nodeIndex="3410">
17 32: 000126e4 4 OBJECT GLOBAL DEFAULT 15 __libc_internal_tsd_get <br nodeIndex="3411">
12 34: 00006189 605 FUNC GLOBAL DEFAULT 9 _dl_lookup_symbol_skip <br nodeIndex="3412">
42 35: 00008255 3291 FUNC GLOBAL DEFAULT 9 _dl_map_object_deps <br nodeIndex="3413">
31 35: 00003056 133 FUNC GLOBAL DEFAULT 9 _dl_dst_count <br nodeIndex="3414">
25 36: 00000000 0 OBJECT GLOBAL DEFAULT ABS GLIBC_2.0</p>
<p brd="1" nodeIndex="528">这里Num列显示该符号在符号表中的索引,Buc列显示该符号在Hash表中的索引,索引值相同的符号按照选后顺序显示. <br nodeIndex="3415">
可见索引为0的保留符号是不进入hash表的</p>
<p brd="1" nodeIndex="529">可用如下命令显示各种长度桶的直方图，用于分析散列效果.</p>
<p brd="1" nodeIndex="530">[zws@mail ~/glibc-2.3/build/elf]$readelf -I ld.so</p>
<p brd="1" nodeIndex="531">Histogram for bucket list length (total of 37 buckets): <br nodeIndex="3416">
Length Number % of total Coverage <br nodeIndex="3417">
0 10 ( 27.0%) //长度为0的桶占总桶的27% <br nodeIndex="3418">
1 16 ( 43.2%) 38.1% //长度为1的桶占总桶的43.2%,其总符号数占总符号的38.1% <br nodeIndex="3419">
2 9 ( 24.3%) 81.0% //.... <br nodeIndex="3420">
3 0 ( 0.0%) 81.0% <br nodeIndex="3421">
4 2 ( 5.4%) 100.0%</p>
<p brd="1" nodeIndex="532">length为桶长,number为相同桶长的个数,% of total为相同桶长的个数占总桶的百分比,coverage为相同桶长的桶中总符号数 <br nodeIndex="3422">
占总符号数的百分比。</p>
<p brd="1" nodeIndex="533">问题4:.dynsym节和.symtab节的联系和区别?</p>
<p brd="1" nodeIndex="534">[zws@mail ~/glibc-2.3/build/elf]$readelf -S ld.so <br nodeIndex="3423">
There are 30 section headers, starting at offset 0x96078:</p>
<p brd="1" nodeIndex="535">Section Headers: <br nodeIndex="3424">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="3425">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="3426">
[ 1] .hash HASH 00000094 000094 000148 04 A 2 0 4 <br nodeIndex="3427">
[ 2] .dynsym DYNSYM 000001dc 0001dc 0002b0 10 A 3 1 4 <br nodeIndex="3428">
[ 3] .dynstr STRTAB 0000048c 00048c 0002cf 00 A 0 0 1 <br nodeIndex="3429">
[ 4] .gnu.version VERSYM 0000075c 00075c 000056 02 A 2 0 2 <br nodeIndex="3430">
[ 5] .gnu.version_d VERDEF 000007b4 0007b4 0000a4 00 A 3 5 4 <br nodeIndex="3431">
[ 6] .rel.dyn REL 00000858 000858 000070 08 A 2 0 4 <br nodeIndex="3432">
[ 7] .rel.plt REL 000008c8 0008c8 000048 08 A 2 8 4 <br nodeIndex="3433">
[ 8] .plt PROGBITS 00000910 000910 0000a0 04 AX 0 0 4 <br nodeIndex="3434">
[ 9] .text PROGBITS 000009b0 0009b0 00e6ce 00 AX 0 0 16 <br nodeIndex="3435">
[10] .rodata PROGBITS 0000f080 00f080 002e60 00 A 0 0 32 <br nodeIndex="3436">
[11] .dynamic DYNAMIC 00012000 012000 0000b0 08 WA 3 0 4 <br nodeIndex="3437">
[12] .got PROGBITS 000120b0 0120b0 000038 04 WA 0 0 4 <br nodeIndex="3438">
[13] .got.plt PROGBITS 000120e8 0120e8 000030 04 WA 0 0 4 <br nodeIndex="3439">
[14] .data PROGBITS 00012120 012120 000408 00 WA 0 0 32 <br nodeIndex="3440">
[15] .bss NOBITS 00012540 012528 0001cc 00 WA 0 0 32 <br nodeIndex="3441">
[16] .stab PROGBITS 00000000 012528 0004f8 0c 17 0 4 <br nodeIndex="3442">
[17] .stabstr STRTAB 00000000 012a20 000276 00 0 0 1 <br nodeIndex="3443">
[18] .comment PROGBITS 00000000 012c96 0009f6 00 0 0 1 <br nodeIndex="3444">
[19] .debug_aranges PROGBITS 00000000 01368c 0005e0 00 0 0 1 <br nodeIndex="3445">
[20] .debug_pubnames PROGBITS 00000000 013c6c 000bd9 00 0 0 1 <br nodeIndex="3446">
[21] .debug_info PROGBITS 00000000 014845 06722d 00 0 0 1 <br nodeIndex="3447">
[22] .debug_abbrev PROGBITS 00000000 07ba72 006978 00 0 0 1 <br nodeIndex="3448">
[23] .debug_line PROGBITS 00000000 0823ea 009e0e 00 0 0 1 <br nodeIndex="3449">
[24] .debug_frame PROGBITS 00000000 08c1f8 001934 00 0 0 4 <br nodeIndex="3450">
[25] .debug_str PROGBITS 00000000 08db2c 0083e3 01 MS 0 0 1 <br nodeIndex="3451">
[26] .gnu.warning.llse PROGBITS 00000000 095f20 00003f 00 0 0 32 <br nodeIndex="3452">
[27] .shstrtab STRTAB 00000000 095f5f 000118 00 0 0 1 <br nodeIndex="3453">
[28] .symtab SYMTAB 00000000 096528 001f70 10 29 461 4 <br nodeIndex="3454">
[29] .strtab STRTAB 00000000 098498 00174a 00 0 0 1 <br nodeIndex="3455">
Key to Flags: <br nodeIndex="3456">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="3457">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="3458">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="536">strip ld.so后发现 <br nodeIndex="3459">
[zws@mail ~/glibc-2.3/build/elf]$readelf -S ldx.so <br nodeIndex="3460">
There are 19 section headers, starting at offset 0x12ffc:</p>
<p brd="1" nodeIndex="537">Section Headers: <br nodeIndex="3461">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="3462">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="3463">
[ 1] .hash HASH 00000094 000094 000148 04 A 2 0 4 <br nodeIndex="3464">
[ 2] .dynsym DYNSYM 000001dc 0001dc 0002b0 10 A 3 1 4 <br nodeIndex="3465">
[ 3] .dynstr STRTAB 0000048c 00048c 0002cf 00 A 0 0 1 <br nodeIndex="3466">
[ 4] .gnu.version VERSYM 0000075c 00075c 000056 02 A 2 0 2 <br nodeIndex="3467">
[ 5] .gnu.version_d VERDEF 000007b4 0007b4 0000a4 00 A 3 5 4 <br nodeIndex="3468">
[ 6] .rel.dyn REL 00000858 000858 000070 08 A 2 0 4 <br nodeIndex="3469">
[ 7] .rel.plt REL 000008c8 0008c8 000048 08 A 2 8 4 <br nodeIndex="3470">
[ 8] .plt PROGBITS 00000910 000910 0000a0 04 AX 0 0 4 <br nodeIndex="3471">
[ 9] .text PROGBITS 000009b0 0009b0 00e6ce 00 AX 0 0 16 <br nodeIndex="3472">
[10] .rodata PROGBITS 0000f080 00f080 002e60 00 A 0 0 32 <br nodeIndex="3473">
[11] .dynamic DYNAMIC 00012000 012000 0000b0 08 WA 3 0 4 <br nodeIndex="3474">
[12] .got PROGBITS 000120b0 0120b0 000038 04 WA 0 0 4 <br nodeIndex="3475">
[13] .got.plt PROGBITS 000120e8 0120e8 000030 04 WA 0 0 4 <br nodeIndex="3476">
[14] .data PROGBITS 00012120 012120 000408 00 WA 0 0 32 <br nodeIndex="3477">
[15] .bss NOBITS 00012540 012528 0001cc 00 WA 0 0 32 <br nodeIndex="3478">
[16] .comment PROGBITS 00000000 012528 0009f6 00 0 0 1 <br nodeIndex="3479">
[17] .gnu.warning.llse PROGBITS 00000000 012f20 00003f 00 0 0 32 <br nodeIndex="3480">
[18] .shstrtab STRTAB 00000000 012f5f 00009c 00 0 0 1 <br nodeIndex="3481">
Key to Flags: <br nodeIndex="3482">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="3483">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="3484">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="538">少了11个节，分别是 <br nodeIndex="3485">
[16] .stab PROGBITS 00000000 012528 0004f8 0c 17 0 4 <br nodeIndex="3486">
[17] .stabstr STRTAB 00000000 012a20 000276 00 0 0 1 <br nodeIndex="3487">
[19] .debug_aranges PROGBITS 00000000 01368c 0005e0 00 0 0 1 <br nodeIndex="3488">
[20] .debug_pubnames PROGBITS 00000000 013c6c 000bd9 00 0 0 1 <br nodeIndex="3489">
[21] .debug_info PROGBITS 00000000 014845 06722d 00 0 0 1 <br nodeIndex="3490">
[22] .debug_abbrev PROGBITS 00000000 07ba72 006978 00 0 0 1 <br nodeIndex="3491">
[23] .debug_line PROGBITS 00000000 0823ea 009e0e 00 0 0 1 <br nodeIndex="3492">
[24] .debug_frame PROGBITS 00000000 08c1f8 001934 00 0 0 4 <br nodeIndex="3493">
[25] .debug_str PROGBITS 00000000 08db2c 0083e3 01 MS 0 0 1 <br nodeIndex="3494">
[28] .symtab SYMTAB 00000000 096528 001f70 10 29 461 4 <br nodeIndex="3495">
[29] .strtab STRTAB 00000000 098498 00174a 00 0 0 1</p>
<p brd="1" nodeIndex="539">前面9个都是调试信息节。后面一个是.symtab，一个是.symtab的字符表节，他们的符号表的Lk值是29，指向.strtab节. <br nodeIndex="3496">
说明这些信息都不是执行程序必须的。执行程序用的符号表是.dynsym节，以及为其服务的.hash和.dynstr.</p>
<p brd="1" nodeIndex="540">.dynsym和.symtab分别占用文件空间，两者磁盘空间不相干。在内容上，.dynsym是.symtab的子集。.dynsym用于执行时动态链接， <br nodeIndex="3497">
.symtab由objdump等分析程序使用.这里也体现了EFL的执行和存储两种视图。</p>
<p brd="1" nodeIndex="541">两者侧重点不同，但是相通。链接程序将所有执行时需要的节安排在一起，并安排在最前面。这样程序加载的时候，基址就在文件头处。 <br nodeIndex="3498">
在hash节前面的ELF文件头,然后是程序头。 <br nodeIndex="3499">
执行时不需要的节放在后面，准确说是.bss后。.bss不占用文件空间，但是占用内存空间。</p>
<p brd="1" nodeIndex="542">因此前面的 <br nodeIndex="3500">
[16] .comment PROGBITS 00000000 012528 0009f6 00 0 0 1 <br nodeIndex="3501">
[17] .gnu.warning.llse PROGBITS 00000000 012f20 00003f 00 0 0 32 <br nodeIndex="3502">
[18] .shstrtab STRTAB 00000000 012f5f 00009c 00 0 0 1 <br nodeIndex="3503">
也可以删掉 <br nodeIndex="3504">
还有节表本身，被安排在最后，也可以删掉，不会影响程序的执行。</p>
<p brd="1" nodeIndex="543">我们可以作如下实验，编写一个简单的hello world程序，编译执行。</p>
<p brd="1" nodeIndex="544">使用readelf -S hello,找到.bss节,假设文件偏移是x. <br nodeIndex="3505">
使用python脚本将其截断。 <br nodeIndex="3506">
f=open("hello","r+") <br nodeIndex="3507">
f.seek(x) <br nodeIndex="3508">
f.truncate() <br nodeIndex="3509">
f.close <br nodeIndex="3510">
再执行一下hello,看是否还是可执行.</p>
<p brd="1" nodeIndex="545"> <br nodeIndex="3511">
3.设置map_start和map_end</p>
<p brd="1" nodeIndex="546">GL(dl_rtld_map).l_map_start = (ElfW(Addr)) _begin;// 0 <br nodeIndex="3512">
GL(dl_rtld_map).l_map_end = (ElfW(Addr)) _end;// bss 最后 <br nodeIndex="3513">
/* Copy the TLS related data if necessary. */ <br nodeIndex="3514">
/*#if USE_TLS && !defined DONT_USE_BOOTSTRAP_MAP <br nodeIndex="3515">
//# ifdef HAVE___THREAD <br nodeIndex="3516">
// assert (info->l.l_tls_modid != 0); <br nodeIndex="3517">
//# else <br nodeIndex="3518">
if (info->l.l_tls_modid != 0) <br nodeIndex="3519">
//# endif <br nodeIndex="3520">
{ <br nodeIndex="3521">
GL(dl_rtld_map).l_tls_blocksize = info->l.l_tls_blocksize; <br nodeIndex="3522">
GL(dl_rtld_map).l_tls_align = info->l.l_tls_align; <br nodeIndex="3523">
GL(dl_rtld_map).l_tls_initimage_size = info->l.l_tls_initimage_size; <br nodeIndex="3524">
GL(dl_rtld_map).l_tls_initimage = info->l.l_tls_initimage; <br nodeIndex="3525">
GL(dl_rtld_map).l_tls_offset = info->l.l_tls_offset; <br nodeIndex="3526">
GL(dl_rtld_map).l_tls_modid = 1; <br nodeIndex="3527">
GL(dl_rtld_map).l_tls_tp_initialized <br nodeIndex="3528">
= info->l.l_tls_tp_initialized; <br nodeIndex="3529">
} <br nodeIndex="3530">
#endif <br nodeIndex="3531">
*/ <br nodeIndex="3532">
//#if HP_TIMING_AVAIL <br nodeIndex="3533">
HP_TIMING_NOW (GL(dl_cpuclock_offset)); <br nodeIndex="3534">
//#endif</p>
<p brd="1" nodeIndex="547">查看ld.so的符号表</p>
<p brd="1" nodeIndex="548">405: 00000000 0 NOTYPE LOCAL DEFAULT ABS _begin <br nodeIndex="3535">
417: 0001270c 0 NOTYPE LOCAL DEFAULT ABS _end</p>
<p brd="1" nodeIndex="549">对比节表可发现</p>
<p brd="1" nodeIndex="550">_end正好执行bss结尾(是地址而不是文件偏移)</p>
<p brd="1" nodeIndex="551">4._dl_sysdep_start</p>
<p brd="1" nodeIndex="552"> <br nodeIndex="3536">
/* Call the OS-dependent function to set up life so we can do things like <br nodeIndex="3537">
调用操作系统相关函数，建立操作环境，这样就能执行文件访问等操作 <br nodeIndex="3538">
file access. It will call `dl_main' (below) to do all the real work <br nodeIndex="3539">
of the dynamic linker, and then unwind our frame and run the user <br nodeIndex="3540">
这将会调用dl_main完成所有的动态链接工作 <br nodeIndex="3541">
entry point on the same stack we entered on. <br nodeIndex="3542">
最后退出并执行用户入口 <br nodeIndex="3543">
*/ <br nodeIndex="3544">
start_addr = _dl_sysdep_start (arg, &dl_main);//传递dl_main函数，返回用户入口地址</p>
<p brd="1" nodeIndex="553">//#ifndef HP_TIMING_NONAVAIL <br nodeIndex="3545">
if (HP_TIMING_AVAIL)// 1 <br nodeIndex="3546">
{ <br nodeIndex="3547">
hp_timing_t end_time;</p>
<p brd="1" nodeIndex="554">/* Get the current time. */ <br nodeIndex="3548">
HP_TIMING_NOW (end_time);//记录end_time</p>
<p brd="1" nodeIndex="555">/* Compute the difference. */ <br nodeIndex="3549">
HP_TIMING_DIFF (rtld_total_time, start_time, end_time);//计算耗时 <br nodeIndex="3550">
} <br nodeIndex="3551">
//#endif</p>
<p brd="1" nodeIndex="556">if (__builtin_expect (GL(dl_debug_mask) & DL_DEBUG_STATISTICS, 0)) <br nodeIndex="3552">
print_statistics ();//如果需要，输出统计信息</p>
<p brd="1" nodeIndex="557">return start_addr; <br nodeIndex="3553">
}</p>
<p brd="1" nodeIndex="558">输出的统计信息如下</p>
<p brd="1" nodeIndex="559">[zws@mail ~/glibc-2.3/build/elf]$ LD_DEBUG=statistics ls /proc/slabinfo <br nodeIndex="3554">
30251: <br nodeIndex="3555">
30251: runtime linker statistics: <br nodeIndex="3556">
30251: total startup time in dynamic loader: 1141112 clock cycles <br nodeIndex="3557">
30251: time needed for relocation: 498188 clock cycles (43.6%) <br nodeIndex="3558">
30251: number of relocations: 103 <br nodeIndex="3559">
30251: number of relocations from cache: 5 <br nodeIndex="3560">
30251: time needed to load objects: 377760 clock cycles (33.1%) <br nodeIndex="3561">
/proc/slabinfo <br nodeIndex="3562">
30251: <br nodeIndex="3563">
30251: runtime linker statistics: <br nodeIndex="3564">
30251: final number of relocations: 156 <br nodeIndex="3565">
30251: final number of relocations from cache: 5 <br nodeIndex="3566">
[zws@mail ~/glibc-2.3/build/elf]$</p>


<p nodeIndex="563">ld.so分析之7 _dl_sysdep_start</p>
<p brd="1" nodeIndex="564">(sysdeps/generic/dl-sysdep.c)</p>
<p brd="1" nodeIndex="565">1.获取内核传递过来的信息</p>
<p brd="1" nodeIndex="566">Elf32_Addr//ElfW(Addr) <br nodeIndex="3567">
_dl_sysdep_start (void **start_argptr, <br nodeIndex="3568">
void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum, <br nodeIndex="3569">
ElfW(Addr) *user_entry)) <br nodeIndex="3570">
{ <br nodeIndex="3571">
const ElfW(Phdr) *phdr = NULL; <br nodeIndex="3572">
ElfW(Word) phnum = 0; <br nodeIndex="3573">
ElfW(Addr) user_entry; <br nodeIndex="3574">
ElfW(auxv_t) *av; <br nodeIndex="3575">
uid_t uid = 0; <br nodeIndex="3576">
gid_t gid = 0; <br nodeIndex="3577">
//#ifdef HAVE_AUX_XID <br nodeIndex="3578">
//# define set_seen(tag) (tag) /* Evaluate for the side effects. */ <br nodeIndex="3579">
//#else <br nodeIndex="3580">
unsigned int seen = 0; <br nodeIndex="3581">
# define M(type) (1 << (type)) <br nodeIndex="3582">
# define set_seen(tag) seen |= M ((tag)->a_type) <br nodeIndex="3583">
//#endif</p>
<p brd="1" nodeIndex="567">DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, INTUSE(_dl_argv), _environ, <br nodeIndex="3584">
_dl_auxv);</p>
<p brd="1" nodeIndex="568">2.DL_FIND_ARG_COMPONENTS</p>
<p brd="1" nodeIndex="569"># define DL_FIND_ARG_COMPONENTS(cookie, argc, argv, envp, auxp) \ <br nodeIndex="3585">
do { \ <br nodeIndex="3586">
void **_tmp; \ <br nodeIndex="3587">
(argc) = *(long int *) cookie; \ <br nodeIndex="3588">
(argv) = (char **) ((long int *) cookie + 1); \ <br nodeIndex="3589">
(envp) = (argv) + (argc) + 1; \ <br nodeIndex="3590">
for (_tmp = (void **) (envp); *_tmp; ++_tmp) \ <br nodeIndex="3591">
continue; \ <br nodeIndex="3592">
(auxp) = (void *) ++_tmp; \ <br nodeIndex="3593">
} while (0)</p>
<p brd="1" nodeIndex="570">start_argptr指向argc在栈上的地址，因此这个宏的目的很简单，取得argc,argv,envp,auxp变量值。现在再次把内核传递信息贴出</p>
<p brd="1" nodeIndex="571">注意前面的实参 <br nodeIndex="3594">
start_argptr, 是局部变量 <br nodeIndex="3595">
_dl_argc, 有hidden属性 <br nodeIndex="3596">
INTUSE(_dl_argv),即_dl_argv_internal 有hidden属性,是_dl_argv的alias,_dl_argv是全局变量 <br nodeIndex="3597">
_environ, 有hidden属性，但是最终的符号属性是 <br nodeIndex="3598">
307: 00012524 4 OBJECT LOCAL DEFAULT 14 _environ <br nodeIndex="3599">
有点不一样，不知道什么原因？ <br nodeIndex="3600">
_dl_auxv 是局部变量 <br nodeIndex="3601">
因此会使用GOFOFF访问他们而不需要重定位</p>

<p brd="1" nodeIndex="573">/* <br nodeIndex="3602">
内存布局如下 <br nodeIndex="3603">
position content size (bytes) + comment <br nodeIndex="3604">
------------------------------------------------------------------------ <br nodeIndex="3605">
stack pointer -> [ argc = number of args ] 4 <br nodeIndex="3606">
[ argv[0] (pointer) ] 4 (program name) <br nodeIndex="3607">
[ argv[1] (pointer) ] 4 <br nodeIndex="3608">
[ argv[..] (pointer) ] 4 * x <br nodeIndex="3609">
[ argv[n - 1] (pointer) ] 4 <br nodeIndex="3610">
[ argv[n] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="574">[ envp[0] (pointer) ] 4 <br nodeIndex="3611">
[ envp[1] (pointer) ] 4 <br nodeIndex="3612">
[ envp[..] (pointer) ] 4 <br nodeIndex="3613">
[ envp[term] (pointer) ] 4 (= NULL)</p>
<p brd="1" nodeIndex="575">[ auxv[0] AT_PHDR (Elf32_auxv_t) ] 8 <br nodeIndex="3614">
[ auxv[1] AT_PHENT (Elf32_auxv_t) ] 8 <br nodeIndex="3615">
[ auxv[2] AT_PHNUM (Elf32_auxv_t) ] 8 <br nodeIndex="3616">
[ auxv[3] AT_BASE (Elf32_auxv_t) ] 8 <br nodeIndex="3617">
[ auxv[4] AT_FLAGS (Elf32_auxv_t) ] 8 <br nodeIndex="3618">
[ auxv[5] AT_ENTRY (Elf32_auxv_t) ] 8 <br nodeIndex="3619">
[ auxv[6] AT_UID (Elf32_auxv_t) ] 8 <br nodeIndex="3620">
[ auxv[7] AT_EUID (Elf32_auxv_t) ] 8 <br nodeIndex="3621">
[ auxv[8] AT_GID (Elf32_auxv_t) ] 8 <br nodeIndex="3622">
[ auxv[9] AT_EGID (Elf32_auxv_t) ] 8 <br nodeIndex="3623">
[ auxv[10] AT_HWCAP (Elf32_auxv_t) ] 8 <br nodeIndex="3624">
[ auxv[11] AT_PAGESZ (Elf32_auxv_t) ] 8 <br nodeIndex="3625">
[ auxv[12] AT_CLKTCK (Elf32_auxv_t) ] 8 <br nodeIndex="3626">
[ auxv[13] AT_PLATFORM (Elf32_auxv_t) ] 8 <br nodeIndex="3627">
[ auxv[14] (Elf32_auxv_t) ] 8 (= AT_NULL vector)</p>
<p brd="1" nodeIndex="576">[ padding ] 0 - 15 <br nodeIndex="3628">
[ padding ] 16 <br nodeIndex="3629">
[ padding ] 0 - 15</p>
<p brd="1" nodeIndex="577">[k_platform] 0 - 65 <br nodeIndex="3630">
[ argument ASCIIZ strings ] >= 0 <br nodeIndex="3631">
[ environment ASCIIZ str. ] >= 0 <br nodeIndex="3632">
[filename] >=0</p>
<p brd="1" nodeIndex="578">(0xbffffffc) [ end marker ] 4 (= NULL)</p>
<p brd="1" nodeIndex="579">(0xc0000000) < top of stack > 0 (virtual) <br nodeIndex="3633">
*/</p>
<p brd="1" nodeIndex="580">3.解析auxv</p>
<p brd="1" nodeIndex="581">user_entry = (ElfW(Addr)) ENTRY_POINT;//_start，默认为ld.so的_start，_start有属性hidden <br nodeIndex="3634">
GL(dl_platform) = NULL; /* Default to nothing known about the platform. */</p>
<p brd="1" nodeIndex="582">for (av = _dl_auxv; av->a_type != AT_NULL; set_seen (av++)) <br nodeIndex="3635">
switch (av->a_type) <br nodeIndex="3636">
{ <br nodeIndex="3637">
case AT_PHDR: <br nodeIndex="3638">
phdr = av->a_un.a_ptr; <br nodeIndex="3639">
break; <br nodeIndex="3640">
case AT_PHNUM: <br nodeIndex="3641">
phnum = av->a_un.a_val; <br nodeIndex="3642">
break; <br nodeIndex="3643">
case AT_PAGESZ: <br nodeIndex="3644">
GL(dl_pagesize) = av->a_un.a_val;//4k <br nodeIndex="3645">
break; <br nodeIndex="3646">
case AT_ENTRY: <br nodeIndex="3647">
user_entry = av->a_un.a_val;//用户入口 <br nodeIndex="3648">
break; <br nodeIndex="3649">
//#ifdef NEED_DL_BASE_ADDR <br nodeIndex="3650">
// case AT_BASE: <br nodeIndex="3651">
// _dl_base_addr = av->a_un.a_val; <br nodeIndex="3652">
// break; <br nodeIndex="3653">
//#endif <br nodeIndex="3654">
case AT_UID: <br nodeIndex="3655">
case AT_EUID: <br nodeIndex="3656">
uid ^= av->a_un.a_val;//等价于uid=0^AT_UID^AT_EUID=AT_UID^AT_EUID,即判断AT_UID和AT_EUID是否相等 <br nodeIndex="3657">
break; <br nodeIndex="3658">
case AT_GID: <br nodeIndex="3659">
case AT_EGID: <br nodeIndex="3660">
gid ^= av->a_un.a_val;//同理判断AT_GID和AT_EGID是否相等 <br nodeIndex="3661">
break; <br nodeIndex="3662">
case AT_PLATFORM: <br nodeIndex="3663">
GL(dl_platform) = av->a_un.a_ptr; <br nodeIndex="3664">
break; <br nodeIndex="3665">
case AT_HWCAP: <br nodeIndex="3666">
GL(dl_hwcap) = av->a_un.a_val; <br nodeIndex="3667">
break; <br nodeIndex="3668">
case AT_CLKTCK: <br nodeIndex="3669">
GL(dl_clktck) = av->a_un.a_val; <br nodeIndex="3670">
break; <br nodeIndex="3671">
case AT_FPUCW: <br nodeIndex="3672">
GL(dl_fpu_control) = av->a_un.a_val; <br nodeIndex="3673">
break; <br nodeIndex="3674">
}</p>
<p brd="1" nodeIndex="583">//#ifdef DL_SYSDEP_OSCHECK <br nodeIndex="3675">
DL_SYSDEP_OSCHECK (dl_fatal);//编译时为空 <br nodeIndex="3676">
//#endif</p>
<p brd="1" nodeIndex="584">/* Fill in the values we have not gotten from the kernel through the <br nodeIndex="3677">
auxiliary vector. */ <br nodeIndex="3678">
//#ifndef HAVE_AUX_XID <br nodeIndex="3679">
# define SEE(UID, var, uid) \ <br nodeIndex="3680">
if ((seen & M (AT_##UID)) == 0) var ^= __get##uid ()/就如果没有该属性，就调用系统调用取得 <br nodeIndex="3681">
SEE (UID, uid, uid);//if ((seen & (1 << (AT_UID))) == 0) uid ^= __getuid (); <br nodeIndex="3682">
SEE (EUID, uid, euid);//if ((seen & (1 << (AT_EUID))) == 0) uid ^= __geteuid (); <br nodeIndex="3683">
SEE (GID, gid, gid);//if ((seen & (1 << (AT_GID))) == 0) gid ^= __getgid (); <br nodeIndex="3684">
SEE (EGID, gid, egid);//if ((seen & (1 << (AT_EGID))) == 0) gid ^= __getegid (); <br nodeIndex="3685">
//#endif</p>
<p brd="1" nodeIndex="585">/* If one of the two pairs of IDs does not mattch this is a setuid <br nodeIndex="3686">
如果两对id中有一个不等，则这是一个setuid和setgid程序 <br nodeIndex="3687">
or setgid run. */ <br nodeIndex="3688">
INTUSE(__libc_enable_secure) = uid | gid;</p>
<p brd="1" nodeIndex="586">//#ifndef HAVE_AUX_PAGESIZE <br nodeIndex="3689">
if (GL(dl_pagesize) == 0) <br nodeIndex="3690">
GL(dl_pagesize) = __getpagesize (); <br nodeIndex="3691">
//#endif</p>
<p brd="1" nodeIndex="587">//#ifdef DL_SYSDEP_INIT <br nodeIndex="3692">
DL_SYSDEP_INIT; <br nodeIndex="3693">
//#endif</p>
<p brd="1" nodeIndex="588">//#ifdef DL_PLATFORM_INIT <br nodeIndex="3694">
DL_PLATFORM_INIT; <br nodeIndex="3695">
//#endif</p>
<p brd="1" nodeIndex="589">4.DL_SYSDEP_INIT(sysdeps/unix/sysv/linux/dl-sysdep.c)</p>
<p brd="1" nodeIndex="590">#define DL_SYSDEP_INIT frob_brk ()</p>
<p brd="1" nodeIndex="591">static inline void <br nodeIndex="3696">
frob_brk (void) <br nodeIndex="3697">
{ <br nodeIndex="3698">
__brk (0); /* Initialize the break. 取得brk起始地址*/ <br nodeIndex="3699">
}</p>
<p brd="1" nodeIndex="592"> <br nodeIndex="3700">
5.DL_SYSDEP_INIT->frob_brk ->__brk(sysdeps/unix/sysv/linux/i386/brk.c)</p>
<p brd="1" nodeIndex="593">/* This must be initialized data because commons can't have aliases. */ <br nodeIndex="3701">
void *__curbrk = 0;</p>
<p brd="1" nodeIndex="594">/* Old braindamage in GCC's crtstuff.c requires this symbol in an attempt <br nodeIndex="3702">
to work around different old braindamage in the old Linux ELF dynamic <br nodeIndex="3703">
linker. */ <br nodeIndex="3704">
weak_alias (__curbrk, ___brk_addr)</p>
<p brd="1" nodeIndex="595">int <br nodeIndex="3705">
__brk (void *addr) <br nodeIndex="3706">
{ <br nodeIndex="3707">
void *__unbounded newbrk, *__unbounded scratch;</p>
<p brd="1" nodeIndex="596">asm ("movl %%ebx, %1\n" /* Save %ebx in scratch register. 保存%ebx,这是GOT地址*/ <br nodeIndex="3708">
"movl %3, %%ebx\n" /* Put ADDR in %ebx to be syscall arg. 将addr值存入%ebx*/ <br nodeIndex="3709">
"int $0x80 # %2\n" /* Perform the system call. 执行系统调用*/ <br nodeIndex="3710">
"movl %1, %%ebx\n" /* Restore %ebx from scratch register. 还原%ebx */ <br nodeIndex="3711">
: "=a" (newbrk), "=r" (scratch) <br nodeIndex="3712">
: "0" (SYS_ify (brk)), "g" (__ptrvalue (addr)));//SYS_ify(brk)等价于__NR_brk,即系统调用sys_brk</p>
<p brd="1" nodeIndex="597">__curbrk = newbrk;//返回新地址</p>
<p brd="1" nodeIndex="598">if (newbrk < addr) <br nodeIndex="3713">
{ <br nodeIndex="3714">
__set_errno (ENOMEM); <br nodeIndex="3715">
return -1; <br nodeIndex="3716">
}</p>
<p brd="1" nodeIndex="599">return 0; <br nodeIndex="3717">
}</p>
<p brd="1" nodeIndex="600">weak_alias (__brk, brk)//brk是__brk的alias且weak</p>
<p brd="1" nodeIndex="601"> <br nodeIndex="3718">
6.DL_SYSDEP_INIT->frob_brk ->__brk->sys_brk(内核中 2.4.0)</p>
<p brd="1" nodeIndex="602">asmlinkage unsigned long sys_brk(unsigned long brk) <br nodeIndex="3719">
{ <br nodeIndex="3720">
unsigned long rlim, retval; <br nodeIndex="3721">
unsigned long newbrk, oldbrk; <br nodeIndex="3722">
struct mm_struct *mm = current->mm;</p>
<p brd="1" nodeIndex="603">down(&mm->mmap_sem);</p>
<p brd="1" nodeIndex="604">if (brk < mm->end_code) <br nodeIndex="3723">
goto out;</p>
<p brd="1" nodeIndex="605">由于前面的调用参数是0,因此直接out <br nodeIndex="3724">
out: <br nodeIndex="3725">
retval = mm->brk; <br nodeIndex="3726">
up(&mm->mmap_sem); <br nodeIndex="3727">
return retval; <br nodeIndex="3728">
}</p>
<p brd="1" nodeIndex="606">返回mm->brk,由于到目前为止还没有调用sys_brk,应该返回的是mm->start_brk，即紧随bss后的地址.</p>
<p brd="1" nodeIndex="607">验证 <br nodeIndex="3729">
[zws@mail ~/glibc-2.3/build/elf]$strace -e brk ls <br nodeIndex="3730">
brk(0) = 0x80586c8 <br nodeIndex="3731">
... <br nodeIndex="3732">
[zws@mail ~]$readelf -S /bin/ls <br nodeIndex="3733">
[23] .bss NOBITS 08058360 010360 000368 00 WA 0 0 32</p>
<p brd="1" nodeIndex="608">0x8058360+0x368=0x80586c8</p>
<p brd="1" nodeIndex="609">7.DL_PLATFORM_INIT(sysdeps/i386/dl-machine.h)</p>
<p brd="1" nodeIndex="610">/* We define an initialization functions. This is called very early in <br nodeIndex="3734">
_dl_sysdep_start. */ <br nodeIndex="3735">
#define DL_PLATFORM_INIT dl_platform_init ()</p>
<p brd="1" nodeIndex="611">static inline void //__attribute__ ((unused)) <br nodeIndex="3736">
dl_platform_init (void)//这个函数没什么可说的 <br nodeIndex="3737">
{ <br nodeIndex="3738">
if (GL(dl_platform) != NULL && *GL(dl_platform) == '\0') <br nodeIndex="3739">
/* Avoid an empty string which would disturb us. */ <br nodeIndex="3740">
GL(dl_platform) = NULL; <br nodeIndex="3741">
}</p>
<p brd="1" nodeIndex="612">8.调用__sbrk</p>
<p brd="1" nodeIndex="613">/* Determine the length of the platform name. */ <br nodeIndex="3742">
if (GL(dl_platform) != NULL) <br nodeIndex="3743">
GL(dl_platformlen) = strlen (GL(dl_platform));</p>
<p brd="1" nodeIndex="614">if (__sbrk (0) == &_end) <br nodeIndex="3744">
/* The dynamic linker was run as a program, and so the initial break <br nodeIndex="3745">
动态链接器本身直接运行,所有起始break就紧随bss，在&_end处 <br nodeIndex="3746">
starts just after our bss, at &_end. The malloc in dl-minimal.c <br nodeIndex="3747">
will consume the rest of this page, so tell the kernel to move the <br nodeIndex="3748">
在dl-minimal.c中的malloc将消耗掉该页剩下部分,所有告诉内核移动break跳过该部分 <br nodeIndex="3749">
break up that far. When the user program examines its break, it <br nodeIndex="3750">
will see this new value and not clobber our data. <br nodeIndex="3751">
当用户程序检查它的break,它将会看到新值，而不会破坏我们的数据.</p>
<p brd="1" nodeIndex="615">不太明白这里的意思? <br nodeIndex="3752">
*/ <br nodeIndex="3753">
__sbrk (GL(dl_pagesize) - ((&_end - (void *) 0) & (GL(dl_pagesize) - 1)));</p>
<p brd="1" nodeIndex="616"> <br nodeIndex="3754">
9.__sbrk(sysdeps/generic/sbrk.c) <br nodeIndex="3755">
/* Extend the process's data space by INCREMENT. <br nodeIndex="3756">
根据INCREMENT扩展进程数据空间 <br nodeIndex="3757">
If INCREMENT is negative, shrink data space by - INCREMENT. <br nodeIndex="3758">
如果INCREMENT是负数，缩减数据空间INCREMENT大小 <br nodeIndex="3759">
Return start of new space allocated, or -1 for errors. <br nodeIndex="3760">
返回新分配空间的起始地址 <br nodeIndex="3761">
*/ <br nodeIndex="3762">
void * <br nodeIndex="3763">
__sbrk (intptr_t increment) <br nodeIndex="3764">
{ <br nodeIndex="3765">
void *oldbrk;</p>
<p brd="1" nodeIndex="617">/* If this is not part of the dynamic library or the library is used <br nodeIndex="3766">
via dynamic loading in a statically linked program update <br nodeIndex="3767">
__curbrk from the kernel's brk value. That way two separate <br nodeIndex="3768">
instances of __brk and __sbrk can share the heap, returning <br nodeIndex="3769">
interleaved pieces of it. */ <br nodeIndex="3770">
if (__curbrk == NULL || __libc_multiple_libcs)//__libc_multiple_libcs=0,因此本条件为假，不会调用__brk <br nodeIndex="3771">
if (__brk (0) < 0) /* Initialize the break. */ <br nodeIndex="3772">
return (void *) -1;</p>
<p brd="1" nodeIndex="618">if (increment == 0)//为0，直接返回__curbrk <br nodeIndex="3773">
return __curbrk;</p>
<p brd="1" nodeIndex="619">oldbrk = __curbrk; <br nodeIndex="3774">
if (__brk (oldbrk + increment) < 0)//扩展到oldbrk+increment <br nodeIndex="3775">
return (void *) -1;</p>
<p brd="1" nodeIndex="620">return oldbrk; <br nodeIndex="3776">
}</p>
<p brd="1" nodeIndex="621"> <br nodeIndex="3777">
10.返回_dl_sysdep_start</p>
<p brd="1" nodeIndex="622">/* If this is a SUID program we make sure that FDs 0, 1, and 2 are <br nodeIndex="3778">
allocated. If necessary we are doing it ourself. If it is not <br nodeIndex="3779">
如果是SUID程序，确保FD 0,1,2都被分配,如果必须，我们自己分配它们。 <br nodeIndex="3780">
possible we stop the program. <br nodeIndex="3781">
否则停止程序 <br nodeIndex="3782">
*/ <br nodeIndex="3783">
if (__builtin_expect (INTUSE(__libc_enable_secure), 0)) <br nodeIndex="3784">
__libc_check_standard_fds ();</p>
<p brd="1" nodeIndex="623">11.__libc_check_standard_fds (sysdeps/generic/check_fds.c)</p>
<p brd="1" nodeIndex="624">void <br nodeIndex="3785">
__libc_check_standard_fds (void) <br nodeIndex="3786">
{ <br nodeIndex="3787">
/* This is really paranoid but some people actually are. If /dev/null <br nodeIndex="3788">
这确实有点偏执 <br nodeIndex="3789">
should happen to be a symlink to somewhere else and not the device <br nodeIndex="3790">
如果/dev/null碰巧被符号链接到某处，而不是我们通常认为的那个/dev/null设备，我们退出 <br nodeIndex="3791">
commonly known as "/dev/null" we bail out. We can detect this with <br nodeIndex="3792">
the O_NOFOLLOW flag for open() but only on some system. <br nodeIndex="3793">
我们能使用O_NOFOLLOW标识调用open来测试这种情况,仅对某些系统可以. <br nodeIndex="3794">
*/ <br nodeIndex="3795">
//#ifndef O_NOFOLLOW //已定义，是0400000 <br nodeIndex="3796">
//# define O_NOFOLLOW 0 <br nodeIndex="3797">
//#endif <br nodeIndex="3798">
/* Check all three standard file descriptors. */ <br nodeIndex="3799">
check_one_fd (STDIN_FILENO, O_RDONLY | O_NOFOLLOW); <br nodeIndex="3800">
check_one_fd (STDOUT_FILENO, O_RDWR | O_NOFOLLOW); <br nodeIndex="3801">
check_one_fd (STDERR_FILENO, O_RDWR | O_NOFOLLOW); <br nodeIndex="3802">
}</p>
<p brd="1" nodeIndex="625">12.__libc_check_standard_fds->check_one_fd (sysdeps/generic/check_fds.c)</p>
<p brd="1" nodeIndex="626">/* Should other OSes (e.g., Hurd) have different versions which can <br nodeIndex="3803">
be written in a better way? */ <br nodeIndex="3804">
static void <br nodeIndex="3805">
check_one_fd (int fd, int mode) <br nodeIndex="3806">
{ <br nodeIndex="3807">
if (__builtin_expect (__libc_fcntl (fd, F_GETFD), 0) == -1 <br nodeIndex="3808">
&& errno == EBADF)//该fd不存在 <br nodeIndex="3809">
{ <br nodeIndex="3810">
struct stat64 st;</p>
<p brd="1" nodeIndex="627">/* Something is wrong with this descriptor, it's probably not <br nodeIndex="3811">
该描述符出错，可能是未打开 <br nodeIndex="3812">
opened. Open /dev/null so that the SUID program we are <br nodeIndex="3813">
打开/dev/null以便SUID程序能使用它 <br nodeIndex="3814">
about to start does not accidently use this descriptor. */ <br nodeIndex="3815">
int nullfd = __libc_open (_PATH_DEVNULL, mode); <br nodeIndex="3816">
/* We are very paranoid here. With all means we try to ensure <br nodeIndex="3817">
that we are actually opening the /dev/null device and nothing <br nodeIndex="3818">
else.</p>
<p brd="1" nodeIndex="628">Note that the following code assumes that STDIN_FILENO, <br nodeIndex="3819">
STDOUT_FILENO, STDERR_FILENO are the three lowest file <br nodeIndex="3820">
decsriptor numbers, in this order. */ <br nodeIndex="3821">
if (__builtin_expect (nullfd != fd, 0)//安装的fd不是想要的 <br nodeIndex="3822">
|| __builtin_expect (__fxstat64 (_STAT_VER, fd, &st), 0) != 0//不能stat该fd <br nodeIndex="3823">
|| __builtin_expect (S_ISCHR (st.st_mode), 1) == 0//该fd不是字符设备 <br nodeIndex="3824">
#if defined DEV_NULL_MAJOR && defined DEV_NULL_MINOR <br nodeIndex="3825">
|| st.st_rdev != makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR)//该设备不是空设备 <br nodeIndex="3826">
#endif <br nodeIndex="3827">
) <br nodeIndex="3828">
/* We cannot even give an error message here since it would <br nodeIndex="3829">
run into the same problems. <br nodeIndex="3830">
不能给出错误消息，因为可能会碰到同样的问题 <br nodeIndex="3831">
*/ <br nodeIndex="3832">
while (1) <br nodeIndex="3833">
/* Try for ever and ever. */ <br nodeIndex="3834">
ABORT_INSTRUCTION;//asm ("hlt"); <br nodeIndex="3835">
} <br nodeIndex="3836">
}</p>
<p brd="1" nodeIndex="629">13.一且都准备好了，调用dl_main</p>
<p brd="1" nodeIndex="630">(*dl_main) (phdr, phnum, &user_entry); <br nodeIndex="3837">
return user_entry; <br nodeIndex="3838">
} <br nodeIndex="3839"></p>
<p nodeIndex="631">ld.so分析8 dl_main->process_envars处理环境变量</p>
<p brd="1" nodeIndex="632">dl_main函数是ld.so的真实主体，很大很复杂,想读懂它必须选择一条主线或情景.我们就看hello world程序如何被动态链接的吧。</p>
<p brd="1" nodeIndex="633">1.准备例子</p>
<p brd="1" nodeIndex="634">hello.c</p>
<p brd="1" nodeIndex="635">#include <stdio.h></p>
<p brd="1" nodeIndex="636">int main() <br nodeIndex="3840">
{ <br nodeIndex="3841">
printf("Hello World!\n"); <br nodeIndex="3842">
return 0; <br nodeIndex="3843">
}</p>
<p brd="1" nodeIndex="637">gcc hello.c -o hello</p>
<p brd="1" nodeIndex="638">显示完整的elf信息 <br nodeIndex="3844">
[zws@mail ~/glibc-2.3/build/elf]$readelf -a hello <br nodeIndex="3845">
ELF Header: <br nodeIndex="3846">
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 <br nodeIndex="3847">
Class: ELF32 <br nodeIndex="3848">
Data: 2's complement, little endian <br nodeIndex="3849">
Version: 1 (current) <br nodeIndex="3850">
OS/ABI: UNIX - System V <br nodeIndex="3851">
ABI Version: 0 <br nodeIndex="3852">
Type: EXEC (Executable file) <br nodeIndex="3853">
Machine: Intel 80386 <br nodeIndex="3854">
Version: 0x1 <br nodeIndex="3855">
Entry point address: 0x8048278 <br nodeIndex="3856">
Start of program headers: 52 (bytes into file) <br nodeIndex="3857">
Start of section headers: 7460 (bytes into file) <br nodeIndex="3858">
Flags: 0x0 <br nodeIndex="3859">
Size of this header: 52 (bytes) <br nodeIndex="3860">
Size of program headers: 32 (bytes) <br nodeIndex="3861">
Number of program headers: 6 <br nodeIndex="3862">
Size of section headers: 40 (bytes) <br nodeIndex="3863">
Number of section headers: 35 <br nodeIndex="3864">
Section header string table index: 32</p>
<p brd="1" nodeIndex="639">Section Headers: <br nodeIndex="3865">
[Nr] Name Type Addr Off Size ES Flg Lk Inf Al <br nodeIndex="3866">
[ 0] NULL 00000000 000000 000000 00 0 0 0 <br nodeIndex="3867">
[ 1] .interp PROGBITS 080480f4 0000f4 000013 00 A 0 0 1 <br nodeIndex="3868">
[ 2] .note.ABI-tag NOTE 08048108 000108 000020 00 A 0 0 4 <br nodeIndex="3869">
[ 3] .hash HASH 08048128 000128 000028 04 A 4 0 4 <br nodeIndex="3870">
[ 4] .dynsym DYNSYM 08048150 000150 000050 10 A 5 1 4 <br nodeIndex="3871">
[ 5] .dynstr STRTAB 080481a0 0001a0 00004c 00 A 0 0 1 <br nodeIndex="3872">
[ 6] .gnu.version VERSYM 080481ec 0001ec 00000a 02 A 4 0 2 <br nodeIndex="3873">
[ 7] .gnu.version_r VERNEED 080481f8 0001f8 000020 00 A 5 1 4 <br nodeIndex="3874">
[ 8] .rel.dyn REL 08048218 000218 000008 08 A 4 0 4 <br nodeIndex="3875">
[ 9] .rel.plt REL 08048220 000220 000010 08 A 4 11 4 <br nodeIndex="3876">
[10] .init PROGBITS 08048230 000230 000017 00 AX 0 0 4 <br nodeIndex="3877">
[11] .plt PROGBITS 08048248 000248 000030 04 AX 0 0 4 <br nodeIndex="3878">
[12] .text PROGBITS 08048278 000278 000160 00 AX 0 0 4 <br nodeIndex="3879">
[13] .fini PROGBITS 080483d8 0003d8 00001b 00 AX 0 0 4 <br nodeIndex="3880">
[14] .rodata PROGBITS 080483f4 0003f4 000016 00 A 0 0 4 <br nodeIndex="3881">
[15] .eh_frame PROGBITS 0804840c 00040c 000004 00 A 0 0 4 <br nodeIndex="3882">
[16] .ctors PROGBITS 08049410 000410 000008 00 WA 0 0 4 <br nodeIndex="3883">
[17] .dtors PROGBITS 08049418 000418 000008 00 WA 0 0 4 <br nodeIndex="3884">
[18] .jcr PROGBITS 08049420 000420 000004 00 WA 0 0 4 <br nodeIndex="3885">
[19] .dynamic DYNAMIC 08049424 000424 0000c8 08 WA 5 0 4 <br nodeIndex="3886">
[20] .got PROGBITS 080494ec 0004ec 000004 04 WA 0 0 4 <br nodeIndex="3887">
[21] .got.plt PROGBITS 080494f0 0004f0 000014 04 WA 0 0 4 <br nodeIndex="3888">
[22] .data PROGBITS 08049504 000504 00000c 00 WA 0 0 4 <br nodeIndex="3889">
[23] .bss NOBITS 08049510 000510 000004 00 WA 0 0 4 <br nodeIndex="3890">
[24] .comment PROGBITS 00000000 000510 000132 00 0 0 1 <br nodeIndex="3891">
[25] .debug_aranges PROGBITS 00000000 000648 000078 00 0 0 8 <br nodeIndex="3892">
[26] .debug_pubnames PROGBITS 00000000 0006c0 000025 00 0 0 1 <br nodeIndex="3893">
[27] .debug_info PROGBITS 00000000 0006e5 000a84 00 0 0 1 <br nodeIndex="3894">
[28] .debug_abbrev PROGBITS 00000000 001169 000138 00 0 0 1 <br nodeIndex="3895">
[29] .debug_line PROGBITS 00000000 0012a1 00027c 00 0 0 1 <br nodeIndex="3896">
[30] .debug_frame PROGBITS 00000000 001520 000014 00 0 0 4 <br nodeIndex="3897">
[31] .debug_str PROGBITS 00000000 001534 0006ba 01 MS 0 0 1 <br nodeIndex="3898">
[32] .shstrtab STRTAB 00000000 001bee 000134 00 0 0 1 <br nodeIndex="3899">
[33] .symtab SYMTAB 00000000 00229c 0006a0 10 34 88 4 <br nodeIndex="3900">
[34] .strtab STRTAB 00000000 00293c 0003ee 00 0 0 1 <br nodeIndex="3901">
Key to Flags: <br nodeIndex="3902">
W (write), A (alloc), X (execute), M (merge), S (strings) <br nodeIndex="3903">
I (info), L (link order), G (group), x (unknown) <br nodeIndex="3904">
O (extra OS processing required) o (OS specific), p (processor specific)</p>
<p brd="1" nodeIndex="640">There are no section groups in this file.</p>
<p brd="1" nodeIndex="641">Program Headers: <br nodeIndex="3905">
Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align <br nodeIndex="3906">
PHDR 0x000034 0x08048034 0x08048034 0x000c0 0x000c0 R E 0x4 <br nodeIndex="3907">
INTERP 0x0000f4 0x080480f4 0x080480f4 0x00013 0x00013 R 0x1 <br nodeIndex="3908">
[Requesting program interpreter: /lib/ld-linux.so.2] <br nodeIndex="3909">
LOAD 0x000000 0x08048000 0x08048000 0x00410 0x00410 R E 0x1000 <br nodeIndex="3910">
LOAD 0x000410 0x08049410 0x08049410 0x00100 0x00104 RW 0x1000 <br nodeIndex="3911">
DYNAMIC 0x000424 0x08049424 0x08049424 0x000c8 0x000c8 RW 0x4 <br nodeIndex="3912">
NOTE 0x000108 0x08048108 0x08048108 0x00020 0x00020 R 0x4</p>
<p brd="1" nodeIndex="642">Section to Segment mapping: <br nodeIndex="3913">
Segment Sections... <br nodeIndex="3914">
00 <br nodeIndex="3915">
01 .interp <br nodeIndex="3916">
02 .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame <br nodeIndex="3917">
03 .ctors .dtors .jcr .dynamic .got .got.plt .data .bss <br nodeIndex="3918">
04 .dynamic <br nodeIndex="3919">
05 .note.ABI-tag</p>
<p brd="1" nodeIndex="643">Dynamic section at offset 0x424 contains 20 entries: <br nodeIndex="3920">
Tag Type Name/Value <br nodeIndex="3921">
0x00000001 (NEEDED) Shared library: [libc.so.6] <br nodeIndex="3922">
0x0000000c (INIT) 0x8048230 <br nodeIndex="3923">
0x0000000d (FINI) 0x80483d8 <br nodeIndex="3924">
0x00000004 (HASH) 0x8048128 <br nodeIndex="3925">
0x00000005 (STRTAB) 0x80481a0 <br nodeIndex="3926">
0x00000006 (SYMTAB) 0x8048150 <br nodeIndex="3927">
0x0000000a (STRSZ) 76 (bytes) <br nodeIndex="3928">
0x0000000b (SYMENT) 16 (bytes) <br nodeIndex="3929">
0x00000015 (DEBUG) 0x0 <br nodeIndex="3930">
0x00000003 (PLTGOT) 0x80494f0 <br nodeIndex="3931">
0x00000002 (PLTRELSZ) 16 (bytes) <br nodeIndex="3932">
0x00000014 (PLTREL) REL <br nodeIndex="3933">
0x00000017 (JMPREL) 0x8048220 <br nodeIndex="3934">
0x00000011 (REL) 0x8048218 <br nodeIndex="3935">
0x00000012 (RELSZ) 8 (bytes) <br nodeIndex="3936">
0x00000013 (RELENT) 8 (bytes) <br nodeIndex="3937">
0x6ffffffe (VERNEED) 0x80481f8 <br nodeIndex="3938">
0x6fffffff (VERNEEDNUM) 1 <br nodeIndex="3939">
0x6ffffff0 (VERSYM) 0x80481ec <br nodeIndex="3940">
0x00000000 (NULL) 0x0</p>
<p brd="1" nodeIndex="644">Relocation section '.rel.dyn' at offset 0x218 contains 1 entries: <br nodeIndex="3941">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="3942">
080494ec 00000106 R_386_GLOB_DAT 00000000 __gmon_start__</p>
<p brd="1" nodeIndex="645">Relocation section '.rel.plt' at offset 0x220 contains 2 entries: <br nodeIndex="3943">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="3944">
080494fc 00000207 R_386_JUMP_SLOT 00000000 __libc_start_main <br nodeIndex="3945">
08049500 00000407 R_386_JUMP_SLOT 00000000 printf</p>
<p brd="1" nodeIndex="646">There are no unwind sections in this file.</p>
<p brd="1" nodeIndex="647">Symbol table '.dynsym' contains 5 entries: <br nodeIndex="3946">
Num: Value Size Type Bind Vis Ndx Name <br nodeIndex="3947">
0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br nodeIndex="3948">
1: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ <br nodeIndex="3949">
2: 00000000 251 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (2) <br nodeIndex="3950">
3: 080483f8 4 OBJECT GLOBAL DEFAULT 14 _IO_stdin_used <br nodeIndex="3951">
4: 00000000 57 FUNC GLOBAL DEFAULT UND printf@GLIBC_2.0 (2)</p>
<p brd="1" nodeIndex="648">Symbol table '.symtab' contains 106 entries: <br nodeIndex="3952">
Num: Value Size Type Bind Vis Ndx Name <br nodeIndex="3953">
0: 00000000 0 NOTYPE LOCAL DEFAULT UND <br nodeIndex="3954">
1: 080480f4 0 SECTION LOCAL DEFAULT 1 <br nodeIndex="3955">
2: 08048108 0 SECTION LOCAL DEFAULT 2 <br nodeIndex="3956">
3: 08048128 0 SECTION LOCAL DEFAULT 3 <br nodeIndex="3957">
4: 08048150 0 SECTION LOCAL DEFAULT 4 <br nodeIndex="3958">
5: 080481a0 0 SECTION LOCAL DEFAULT 5 <br nodeIndex="3959">
6: 080481ec 0 SECTION LOCAL DEFAULT 6 <br nodeIndex="3960">
7: 080481f8 0 SECTION LOCAL DEFAULT 7 <br nodeIndex="3961">
8: 08048218 0 SECTION LOCAL DEFAULT 8 <br nodeIndex="3962">
9: 08048220 0 SECTION LOCAL DEFAULT 9 <br nodeIndex="3963">
10: 08048230 0 SECTION LOCAL DEFAULT 10 <br nodeIndex="3964">
11: 08048248 0 SECTION LOCAL DEFAULT 11 <br nodeIndex="3965">
12: 08048278 0 SECTION LOCAL DEFAULT 12 <br nodeIndex="3966">
13: 080483d8 0 SECTION LOCAL DEFAULT 13 <br nodeIndex="3967">
14: 080483f4 0 SECTION LOCAL DEFAULT 14 <br nodeIndex="3968">
15: 0804840c 0 SECTION LOCAL DEFAULT 15 <br nodeIndex="3969">
16: 08049410 0 SECTION LOCAL DEFAULT 16 <br nodeIndex="3970">
17: 08049418 0 SECTION LOCAL DEFAULT 17 <br nodeIndex="3971">
18: 08049420 0 SECTION LOCAL DEFAULT 18 <br nodeIndex="3972">
19: 08049424 0 SECTION LOCAL DEFAULT 19 <br nodeIndex="3973">
20: 080494ec 0 SECTION LOCAL DEFAULT 20 <br nodeIndex="3974">
21: 080494f0 0 SECTION LOCAL DEFAULT 21 <br nodeIndex="3975">
22: 08049504 0 SECTION LOCAL DEFAULT 22 <br nodeIndex="3976">
23: 08049510 0 SECTION LOCAL DEFAULT 23 <br nodeIndex="3977">
24: 00000000 0 SECTION LOCAL DEFAULT 24 <br nodeIndex="3978">
25: 00000000 0 SECTION LOCAL DEFAULT 25 <br nodeIndex="3979">
26: 00000000 0 SECTION LOCAL DEFAULT 26 <br nodeIndex="3980">
27: 00000000 0 SECTION LOCAL DEFAULT 27 <br nodeIndex="3981">
28: 00000000 0 SECTION LOCAL DEFAULT 28 <br nodeIndex="3982">
29: 00000000 0 SECTION LOCAL DEFAULT 29 <br nodeIndex="3983">
30: 00000000 0 SECTION LOCAL DEFAULT 30 <br nodeIndex="3984">
31: 00000000 0 SECTION LOCAL DEFAULT 31 <br nodeIndex="3985">
32: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="3986">
33: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="3987">
34: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="3988">
35: 00000000 0 FILE LOCAL DEFAULT ABS <built-in> <br nodeIndex="3989">
36: 00000000 0 FILE LOCAL DEFAULT ABS abi-note.S <br nodeIndex="3990">
37: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="3991">
38: 00000000 0 FILE LOCAL DEFAULT ABS abi-note.S <br nodeIndex="3992">
39: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="3993">
40: 00000000 0 FILE LOCAL DEFAULT ABS abi-note.S <br nodeIndex="3994">
41: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="3995">
42: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="3996">
43: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="3997">
44: 00000000 0 FILE LOCAL DEFAULT ABS <built-in> <br nodeIndex="3998">
45: 00000000 0 FILE LOCAL DEFAULT ABS abi-note.S <br nodeIndex="3999">
46: 00000000 0 FILE LOCAL DEFAULT ABS init.c <br nodeIndex="4000">
47: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4001">
48: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4002">
49: 00000000 0 FILE LOCAL DEFAULT ABS initfini.c <br nodeIndex="4003">
50: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4004">
51: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="4005">
52: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4006">
53: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="4007">
54: 00000000 0 FILE LOCAL DEFAULT ABS <built-in> <br nodeIndex="4008">
55: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4009">
56: 0804829c 0 FUNC LOCAL DEFAULT 12 call_gmon_start <br nodeIndex="4010">
57: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c <br nodeIndex="4011">
58: 08049410 0 OBJECT LOCAL DEFAULT 16 __CTOR_LIST__ <br nodeIndex="4012">
59: 08049418 0 OBJECT LOCAL DEFAULT 17 __DTOR_LIST__ <br nodeIndex="4013">
60: 0804840c 0 OBJECT LOCAL DEFAULT 15 __EH_FRAME_BEGIN__ <br nodeIndex="4014">
61: 08049420 0 OBJECT LOCAL DEFAULT 18 __JCR_LIST__ <br nodeIndex="4015">
62: 0804950c 0 OBJECT LOCAL DEFAULT 22 p.0 <br nodeIndex="4016">
63: 08049510 1 OBJECT LOCAL DEFAULT 23 completed.1 <br nodeIndex="4017">
64: 080482c0 0 FUNC LOCAL DEFAULT 12 __do_global_dtors_aux <br nodeIndex="4018">
65: 080482fc 0 FUNC LOCAL DEFAULT 12 frame_dummy <br nodeIndex="4019">
66: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c <br nodeIndex="4020">
67: 08049414 0 OBJECT LOCAL DEFAULT 16 __CTOR_END__ <br nodeIndex="4021">
68: 0804941c 0 OBJECT LOCAL DEFAULT 17 __DTOR_END__ <br nodeIndex="4022">
69: 0804840c 0 OBJECT LOCAL DEFAULT 15 __FRAME_END__ <br nodeIndex="4023">
70: 08049420 0 OBJECT LOCAL DEFAULT 18 __JCR_END__ <br nodeIndex="4024">
71: 080483b4 0 FUNC LOCAL DEFAULT 12 __do_global_ctors_aux <br nodeIndex="4025">
72: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4026">
73: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4027">
74: 00000000 0 FILE LOCAL DEFAULT ABS initfini.c <br nodeIndex="4028">
75: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4029">
76: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="4030">
77: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4031">
78: 00000000 0 FILE LOCAL DEFAULT ABS <command line> <br nodeIndex="4032">
79: 00000000 0 FILE LOCAL DEFAULT ABS <built-in> <br nodeIndex="4033">
80: 00000000 0 FILE LOCAL DEFAULT ABS /usr/src/build/231499-i38 <br nodeIndex="4034">
81: 00000000 0 FILE LOCAL DEFAULT ABS 1.c <br nodeIndex="4035">
82: 08049410 0 NOTYPE LOCAL HIDDEN 16 __fini_array_end <br nodeIndex="4036">
83: 080494f0 0 OBJECT LOCAL HIDDEN 21 _GLOBAL_OFFSET_TABLE_ <br nodeIndex="4037">
84: 08049410 0 NOTYPE LOCAL HIDDEN 16 __fini_array_start <br nodeIndex="4038">
85: 08049410 0 NOTYPE LOCAL HIDDEN 16 __init_array_end <br nodeIndex="4039">
86: 08049410 0 NOTYPE LOCAL HIDDEN 16 __init_array_start <br nodeIndex="4040">
87: 08049424 0 OBJECT LOCAL HIDDEN 19 _DYNAMIC <br nodeIndex="4041">
88: 08049504 0 NOTYPE WEAK DEFAULT 22 data_start <br nodeIndex="4042">
89: 08048380 52 FUNC GLOBAL DEFAULT 12 __libc_csu_fini <br nodeIndex="4043">
90: 08048278 0 FUNC GLOBAL DEFAULT 12 _start <br nodeIndex="4044">
91: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ <br nodeIndex="4045">
92: 00000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses <br nodeIndex="4046">
93: 080483f4 4 OBJECT GLOBAL DEFAULT 14 _fp_hw <br nodeIndex="4047">
94: 080483d8 0 FUNC GLOBAL DEFAULT 13 _fini <br nodeIndex="4048">
95: 00000000 251 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ <br nodeIndex="4049">
96: 080483f8 4 OBJECT GLOBAL DEFAULT 14 _IO_stdin_used <br nodeIndex="4050">
97: 08049504 0 NOTYPE GLOBAL DEFAULT 22 __data_start <br nodeIndex="4051">
98: 08049508 0 OBJECT GLOBAL HIDDEN 22 __dso_handle <br nodeIndex="4052">
99: 08048350 48 FUNC GLOBAL DEFAULT 12 __libc_csu_init <br nodeIndex="4053">
100: 00000000 57 FUNC GLOBAL DEFAULT UND printf@@GLIBC_2.0 <br nodeIndex="4054">
101: 08049510 0 NOTYPE GLOBAL DEFAULT ABS __bss_start <br nodeIndex="4055">
102: 08049514 0 NOTYPE GLOBAL DEFAULT ABS _end <br nodeIndex="4056">
103: 08049510 0 NOTYPE GLOBAL DEFAULT ABS _edata <br nodeIndex="4057">
104: 08048328 39 FUNC GLOBAL DEFAULT 12 main <br nodeIndex="4058">
105: 08048230 0 FUNC GLOBAL DEFAULT 10 _init</p>
<p brd="1" nodeIndex="649">Histogram for bucket list length (total of 3 buckets): <br nodeIndex="4059">
Length Number % of total Coverage <br nodeIndex="4060">
0 0 ( 0.0%) <br nodeIndex="4061">
1 2 ( 66.7%) 50.0% <br nodeIndex="4062">
2 1 ( 33.3%) 100.0%</p>
<p brd="1" nodeIndex="650">Version symbols section '.gnu.version' contains 5 entries: <br nodeIndex="4063">
Addr: 00000000080481ec Offset: 0x0001ec Link: 4 (.dynsym) <br nodeIndex="4064">
000: 0 (*local*) 0 (*local*) 2 (GLIBC_2.0) 1 (*global*) <br nodeIndex="4065">
004: 2 (GLIBC_2.0)</p>
<p brd="1" nodeIndex="651">Version needs section '.gnu.version_r' contains 1 entries: <br nodeIndex="4066">
Addr: 0x00000000080481f8 Offset: 0x0001f8 Link to section: 5 (.dynstr) <br nodeIndex="4067">
000000: Version: 1 File: libc.so.6 Cnt: 1 <br nodeIndex="4068">
0x0010: Name: GLIBC_2.0 Flags: none Version: 2</p>
<p brd="1" nodeIndex="652">Notes at offset 0x00000108 with length 0x00000020: <br nodeIndex="4069">
Owner Data size Description <br nodeIndex="4070">
GNU 0x00000010 NT_GNU_ABI_TAG (ABI version tag)</p>
<p brd="1" nodeIndex="653"> <br nodeIndex="4071">
我们发现有上三个重定位项 <br nodeIndex="4072">
Relocation section '.rel.dyn' at offset 0x218 contains 1 entries: <br nodeIndex="4073">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="4074">
080494ec 00000106 R_386_GLOB_DAT 00000000 __gmon_start__</p>
<p brd="1" nodeIndex="654">Relocation section '.rel.plt' at offset 0x220 contains 2 entries: <br nodeIndex="4075">
Offset Info Type Sym.Value Sym. Name <br nodeIndex="4076">
080494fc 00000207 R_386_JUMP_SLOT 00000000 __libc_start_main <br nodeIndex="4077">
08049500 00000407 R_386_JUMP_SLOT 00000000 printf</p>
<p brd="1" nodeIndex="655"> <br nodeIndex="4078">
2. dl_main 局部变量定义</p>
<p brd="1" nodeIndex="656"> <br nodeIndex="4079">
static void <br nodeIndex="4080">
dl_main (const ElfW(Phdr) *phdr, <br nodeIndex="4081">
ElfW(Word) phnum, <br nodeIndex="4082">
ElfW(Addr) *user_entry) <br nodeIndex="4083">
{ <br nodeIndex="4084">
const ElfW(Phdr) *ph; <br nodeIndex="4085">
enum mode mode; <br nodeIndex="4086">
struct link_map **preloads; <br nodeIndex="4087">
unsigned int npreloads; <br nodeIndex="4088">
size_t file_size; <br nodeIndex="4089">
char *file; <br nodeIndex="4090">
bool has_interp = false; <br nodeIndex="4091">
unsigned int i; <br nodeIndex="4092">
bool prelinked = false; <br nodeIndex="4093">
bool rtld_is_main = false; <br nodeIndex="4094">
//#ifndef HP_TIMING_NONAVAIL <br nodeIndex="4095">
hp_timing_t start; <br nodeIndex="4096">
hp_timing_t stop; <br nodeIndex="4097">
hp_timing_t diff; <br nodeIndex="4098">
//#endif <br nodeIndex="4099">
//#ifdef USE_TLS <br nodeIndex="4100">
// void *tcbp; <br nodeIndex="4101">
//#endif</p>
<p brd="1" nodeIndex="657">/* Process the environment variable which control the behaviour. */ <br nodeIndex="4102">
process_envvars (&mode);//处理环境变量</p>
<p brd="1" nodeIndex="658">/* Set up a flag which tells we are just starting. */ <br nodeIndex="4103">
INTUSE(_dl_starting_up) = 1;</p>
<p brd="1" nodeIndex="659">3.先处理环境变量 process_envvars</p>
<p brd="1" nodeIndex="660">static void <br nodeIndex="4104">
process_envvars (enum mode *modep) <br nodeIndex="4105">
{ <br nodeIndex="4106">
char **runp = _environ;//指向_environ <br nodeIndex="4107">
char *envline; <br nodeIndex="4108">
enum mode mode = normal; <br nodeIndex="4109">
char *debug_output = NULL;</p>
<p brd="1" nodeIndex="661">/* This is the default place for profiling data file. */ <br nodeIndex="4110">
GL(dl_profile_output) <br nodeIndex="4111">
= &"/var/tmp\0/var/profile"[INTUSE(__libc_enable_secure) ? 9 : 0];//根据libc_enable_secure的值不同取/var/tmp 或 /var/profile</p>
<p brd="1" nodeIndex="662">while ((envline = _dl_next_ld_env_entry (&runp)) != NULL)</p>
<p brd="1" nodeIndex="663">4.process_envvars->_dl_next_ld_env_entry(sysdeps/generic/dl-environ.c)</p>
<p brd="1" nodeIndex="664">/* Walk through the environment of the process and return all entries <br nodeIndex="4112">
遍历环境变量，返回所有以LD_开始的项目 <br nodeIndex="4113">
starting with `LD_'. <br nodeIndex="4114">
有效的LD_环境变量有 <br nodeIndex="4115">
LD_LIBRARY_PATH <br nodeIndex="4116">
LD_PRELOAD <br nodeIndex="4117">
LD_TRACE_LOADED_OBJECTS <br nodeIndex="4118">
LD_BIND_NOW <br nodeIndex="4119">
LD_WARN <br nodeIndex="4120">
LD_DEBUG <br nodeIndex="4121">
LD_DEBUG_OUTPUT <br nodeIndex="4122">
LD_VERBOSE <br nodeIndex="4123">
在man ld.so中有详细说明 <br nodeIndex="4124">
*/ <br nodeIndex="4125">
char * <br nodeIndex="4126">
//internal_function <br nodeIndex="4127">
_dl_next_ld_env_entry (char ***position) <br nodeIndex="4128">
{ <br nodeIndex="4129">
char **current = *position; <br nodeIndex="4130">
char *result = NULL;</p>
<p brd="1" nodeIndex="665">while (*current != NULL) <br nodeIndex="4131">
{ <br nodeIndex="4132">
if (__builtin_expect ((*current)[0] == 'L', 0) <br nodeIndex="4133">
&& (*current)[1] == 'D' && (*current)[2] == '_') <br nodeIndex="4134">
{ <br nodeIndex="4135">
result = &(*current)[3];//返回LD_后面的字符串</p>
<p brd="1" nodeIndex="666">/* Save current position for next visit. */ <br nodeIndex="4136">
*position = ++current;//为下次访问保存下一个位置</p>
<p brd="1" nodeIndex="667">break; <br nodeIndex="4137">
}</p>
<p brd="1" nodeIndex="668">++current; <br nodeIndex="4138">
}</p>
<p brd="1" nodeIndex="669">return result; <br nodeIndex="4139">
}</p>
<p brd="1" nodeIndex="670">5返回process_envvars <br nodeIndex="4140">
{ <br nodeIndex="4141">
size_t len = 0;</p>
<p brd="1" nodeIndex="671">while (envline[len] != '\0' && envline[len] != '=')//查找= <br nodeIndex="4142">
++len;</p>
<p brd="1" nodeIndex="672">if (envline[len] != '=')//不是key=value格式 <br nodeIndex="4143">
/* This is a "LD_" variable at the end of the string without <br nodeIndex="4144">
这个LD_变量在字符串末尾没有=字符 <br nodeIndex="4145">
a '=' character. Ignore it since otherwise we will access <br nodeIndex="4146">
为了避免后面访问无效内存，忽略它 <br nodeIndex="4147">
invalid memory below. */ <br nodeIndex="4148">
continue;</p>
<p brd="1" nodeIndex="673">switch (len) <br nodeIndex="4149">
{ <br nodeIndex="4150">
case 4: <br nodeIndex="4151">
/* Warning level, verbose or not. 警告级别，详细或没有*/ <br nodeIndex="4152">
if (memcmp (envline, "WARN", 4) == 0) <br nodeIndex="4153">
GL(dl_verbose) = envline[5] != '\0';//=号后面是否为空串,例如LD_WARN=1会详细显示 <br nodeIndex="4154">
break;</p>
<p brd="1" nodeIndex="674">case 5: <br nodeIndex="4155">
/* Debugging of the dynamic linker? */ <br nodeIndex="4156">
if (memcmp (envline, "DEBUG", 5) == 0) <br nodeIndex="4157">
process_dl_debug (&envline[6]);//进一步处理 <br nodeIndex="4158">
break;</p>
<p brd="1" nodeIndex="675">case 7: <br nodeIndex="4159">
/* Print information about versions. */ <br nodeIndex="4160">
if (memcmp (envline, "VERBOSE", 7) == 0) <br nodeIndex="4161">
{ <br nodeIndex="4162">
version_info = envline[8] != '\0';//=号后面是否为空串 <br nodeIndex="4163">
break; <br nodeIndex="4164">
}</p>
<p brd="1" nodeIndex="676">/* List of objects to be preloaded. */ <br nodeIndex="4165">
if (memcmp (envline, "PRELOAD", 7) == 0) <br nodeIndex="4166">
{ <br nodeIndex="4167">
preloadlist = &envline[8]; <br nodeIndex="4168">
break; <br nodeIndex="4169">
}</p>
<p brd="1" nodeIndex="677">/* Which shared object shall be profiled. */ <br nodeIndex="4170">
if (memcmp (envline, "PROFILE", 7) == 0 && envline[8] != '\0') <br nodeIndex="4171">
GL(dl_profile) = &envline[8]; <br nodeIndex="4172">
break;</p>
<p brd="1" nodeIndex="678">case 8: <br nodeIndex="4173">
/* Do we bind early? */ <br nodeIndex="4174">
if (memcmp (envline, "BIND_NOW", 8) == 0) <br nodeIndex="4175">
{ <br nodeIndex="4176">
GL(dl_lazy) = envline[9] == '\0';//LD_BIND_NOW=1，立即bind,LD_BIND_NOW=,lazy bind <br nodeIndex="4177">
break; <br nodeIndex="4178">
} <br nodeIndex="4179">
if (memcmp (envline, "BIND_NOT", 8) == 0)//LD_BIND_NOT,作用未知？ <br nodeIndex="4180">
GL(dl_bind_not) = envline[9] != '\0'; <br nodeIndex="4181">
break;</p>
<p brd="1" nodeIndex="679">case 9: <br nodeIndex="4182">
/* Test whether we want to see the content of the auxiliary <br nodeIndex="4183">
array passed up from the kernel. */ <br nodeIndex="4184">
if (memcmp (envline, "SHOW_AUXV", 9) == 0)//显示AUXV数组 <br nodeIndex="4185">
_dl_show_auxv (); <br nodeIndex="4186">
break;</p>
<p brd="1" nodeIndex="680">case 10: <br nodeIndex="4187">
/* Mask for the important hardware capabilities. */ <br nodeIndex="4188">
if (memcmp (envline, "HWCAP_MASK", 10) == 0) <br nodeIndex="4189">
GL(dl_hwcap_mask) = __strtoul_internal (&envline[11], NULL, 0, 0); <br nodeIndex="4190">
break;</p>
<p brd="1" nodeIndex="681">case 11: <br nodeIndex="4191">
/* Path where the binary is found. */ <br nodeIndex="4192">
if (!INTUSE(__libc_enable_secure) <br nodeIndex="4193">
&& memcmp (envline, "ORIGIN_PATH", 11) == 0) <br nodeIndex="4194">
GL(dl_origin_path) = &envline[12]; <br nodeIndex="4195">
break;</p>
<p brd="1" nodeIndex="682">case 12: <br nodeIndex="4196">
/* The library search path. */ <br nodeIndex="4197">
if (memcmp (envline, "LIBRARY_PATH", 12) == 0) <br nodeIndex="4198">
{ <br nodeIndex="4199">
library_path = &envline[13]; <br nodeIndex="4200">
break; <br nodeIndex="4201">
}</p>
<p brd="1" nodeIndex="683">/* Where to place the profiling data file. */ <br nodeIndex="4202">
if (memcmp (envline, "DEBUG_OUTPUT", 12) == 0) <br nodeIndex="4203">
{ <br nodeIndex="4204">
debug_output = &envline[13]; <br nodeIndex="4205">
break; <br nodeIndex="4206">
}</p>
<p brd="1" nodeIndex="684">if (memcmp (envline, "DYNAMIC_WEAK", 12) == 0) <br nodeIndex="4207">
GL(dl_dynamic_weak) = 1; <br nodeIndex="4208">
break;</p>
<p brd="1" nodeIndex="685">case 14: <br nodeIndex="4209">
/* Where to place the profiling data file. */ <br nodeIndex="4210">
if (!INTUSE(__libc_enable_secure) <br nodeIndex="4211">
&& memcmp (envline, "PROFILE_OUTPUT", 14) == 0 <br nodeIndex="4212">
&& envline[15] != '\0') <br nodeIndex="4213">
GL(dl_profile_output) = &envline[15]; <br nodeIndex="4214">
break;</p>
<p brd="1" nodeIndex="686">case 16: <br nodeIndex="4215">
/* The mode of the dynamic linker can be set. */ <br nodeIndex="4216">
if (memcmp (envline, "TRACE_PRELINKING", 16) == 0) <br nodeIndex="4217">
{ <br nodeIndex="4218">
mode = trace; <br nodeIndex="4219">
GL(dl_verbose) = 1; <br nodeIndex="4220">
GL(dl_debug_mask) |= DL_DEBUG_PRELINK; <br nodeIndex="4221">
GL(dl_trace_prelink) = &envline[17]; <br nodeIndex="4222">
} <br nodeIndex="4223">
break;</p>
<p brd="1" nodeIndex="687">case 20: <br nodeIndex="4224">
/* The mode of the dynamic linker can be set. */ <br nodeIndex="4225">
if (memcmp (envline, "TRACE_LOADED_OBJECTS", 20) == 0) <br nodeIndex="4226">
mode = trace; <br nodeIndex="4227">
break;</p>
<p brd="1" nodeIndex="688">/* We might have some extra environment variable to handle. This <br nodeIndex="4228">
is tricky due to the pre-processing of the length of the name <br nodeIndex="4229">
in the switch statement here. The code here assumes that added <br nodeIndex="4230">
environment variables have a different length. */ <br nodeIndex="4231">
#ifdef EXTRA_LD_ENVVARS <br nodeIndex="4232">
EXTRA_LD_ENVVARS <br nodeIndex="4233">
#endif <br nodeIndex="4234">
} <br nodeIndex="4235">
}</p>
<p brd="1" nodeIndex="689">上面的处理流程很清晰，各个参数什么用，后面会涉及到</p>
<p brd="1" nodeIndex="690">查看生成的汇编代码发现gcc对switch做了优化,使用数组索引各个case.memcmp虽然没有定义但是也因为使用-O参数而被被优化成内联</p>
<p brd="1" nodeIndex="691">subl $4, %eax//%eax为len,减去4 <br nodeIndex="4236">
cmpl $16, %eax//和16比较 <br nodeIndex="4237">
ja .L718//如果大于16,则进入下一轮循环 <br nodeIndex="4238">
movl .L770@GOTOFF(%ebx,%eax,4), %eax//取各个case的地址,%ebx为GOT基址,%eax为索引,4为元素大小,.L770@GOTOFF为.L770相对于GOT偏移 <br nodeIndex="4239">
addl %ebx, %eax//GOT加上case的地址相对于GOT偏移 <br nodeIndex="4240">
jmp *%eax//跳到该case处 <br nodeIndex="4241">
.section .rodata//case数组存入.rodata <br nodeIndex="4242">
.align 4 <br nodeIndex="4243">
.align 4 <br nodeIndex="4244">
.L770: <br nodeIndex="4245">
.long .L728@GOTOFF//len=4 <br nodeIndex="4246">
.long .L730@GOTOFF//len=5 <br nodeIndex="4247">
.long .L718@GOTOFF//len=6,没有，置为下一轮循环地址 <br nodeIndex="4248">
.long .L732@GOTOFF//len=7 <br nodeIndex="4249">
.long .L736@GOTOFF//len=8 <br nodeIndex="4250">
.long .L739@GOTOFF//len=9 <br nodeIndex="4251">
.long .L741@GOTOFF//len=10 <br nodeIndex="4252">
.long .L743@GOTOFF//len=11 <br nodeIndex="4253">
.long .L745@GOTOFF//len=12 <br nodeIndex="4254">
.long .L755@GOTOFF//len=13 <br nodeIndex="4255">
.long .L749@GOTOFF//len=14 <br nodeIndex="4256">
.long .L766@GOTOFF//len=15 <br nodeIndex="4257">
.long .L751@GOTOFF//len=16 <br nodeIndex="4258">
.long .L718@GOTOFF//len=17没有，置为下一轮循环地址 <br nodeIndex="4259">
.long .L718@GOTOFF//len=18没有，置为下一轮循环地址 <br nodeIndex="4260">
.long .L718@GOTOFF//len=19没有，置为下一轮循环地址 <br nodeIndex="4261">
.long .L753@GOTOFF//len=20 <br nodeIndex="4262">
.text <br nodeIndex="4263">
.L728: <br nodeIndex="4264">
.loc 1 1775 0 <br nodeIndex="4265">
movl -40(%ebp), %esi <br nodeIndex="4266">
leal .LC62@GOTOFF(%ebx), %edi <br nodeIndex="4267">
movl $4, %eax <br nodeIndex="4268">
cld //memcmp被内联 <br nodeIndex="4269">
movl %eax, %ecx <br nodeIndex="4270">
repz <br nodeIndex="4271">
cmpsb <br nodeIndex="4272">
seta %dl <br nodeIndex="4273">
setb %al <br nodeIndex="4274">
cmpb %al, %dl <br nodeIndex="4275">
jne .L718 <br nodeIndex="4276">
.loc 1 1776 0 <br nodeIndex="4277">
movl -40(%ebp), %eax <br nodeIndex="4278">
cmpb $0, 5(%eax) <br nodeIndex="4279">
setne %al <br nodeIndex="4280">
movzbl %al, %eax <br nodeIndex="4281">
movl %eax, 80+_rtld_local@GOTOFF(%ebx) <br nodeIndex="4282">
.loc 1 1777 0 <br nodeIndex="4283">
jmp .L718</p>
<p brd="1" nodeIndex="692">6.process_envvars->process_dl_debug 分析debug选项</p>
<p brd="1" nodeIndex="693">/* Nonzero if any of the debugging options is enabled. */ <br nodeIndex="4284">
static int any_debug;</p>
<p brd="1" nodeIndex="694">/* Process the string given as the parameter which explains which debugging <br nodeIndex="4285">
options are enabled. */</p>
<p brd="1" nodeIndex="695">static void <br nodeIndex="4286">
process_dl_debug (const char *dl_debug) <br nodeIndex="4287">
{ <br nodeIndex="4288">
/* When adding new entries make sure that the maximal length of a name <br nodeIndex="4289">
is correctly handled in the LD_DEBUG_HELP code below. */ <br nodeIndex="4290">
//定义LD_DEBUG=value的value有哪些 <br nodeIndex="4291">
static const struct <br nodeIndex="4292">
{ <br nodeIndex="4293">
unsigned char len; <br nodeIndex="4294">
const char name[10]; <br nodeIndex="4295">
const char helptext[41]; <br nodeIndex="4296">
unsigned short int mask; <br nodeIndex="4297">
} <br nodeIndex="4298">
debopts[] = <br nodeIndex="4299">
{ <br nodeIndex="4300">
#define LEN_AND_STR(str) sizeof (str) - 1, str <br nodeIndex="4301">
{ LEN_AND_STR ("libs"), "display library search paths", <br nodeIndex="4302">
DL_DEBUG_LIBS | DL_DEBUG_IMPCALLS }, <br nodeIndex="4303">
{ LEN_AND_STR ("reloc"), "display relocation processing", <br nodeIndex="4304">
DL_DEBUG_RELOC | DL_DEBUG_IMPCALLS }, <br nodeIndex="4305">
{ LEN_AND_STR ("files"), "display progress for input file", <br nodeIndex="4306">
DL_DEBUG_FILES | DL_DEBUG_IMPCALLS }, <br nodeIndex="4307">
{ LEN_AND_STR ("symbols"), "display symbol table processing", <br nodeIndex="4308">
DL_DEBUG_SYMBOLS | DL_DEBUG_IMPCALLS }, <br nodeIndex="4309">
{ LEN_AND_STR ("bindings"), "display information about symbol binding", <br nodeIndex="4310">
DL_DEBUG_BINDINGS | DL_DEBUG_IMPCALLS }, <br nodeIndex="4311">
{ LEN_AND_STR ("versions"), "display version dependencies", <br nodeIndex="4312">
DL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS }, <br nodeIndex="4313">
{ LEN_AND_STR ("all"), "all previous options combined", <br nodeIndex="4314">
DL_DEBUG_LIBS | DL_DEBUG_RELOC | DL_DEBUG_FILES | DL_DEBUG_SYMBOLS <br nodeIndex="4315">
| DL_DEBUG_BINDINGS | DL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS }, <br nodeIndex="4316">
{ LEN_AND_STR ("statistics"), "display relocation statistics", <br nodeIndex="4317">
DL_DEBUG_STATISTICS }, <br nodeIndex="4318">
{ LEN_AND_STR ("help"), "display this help message and exit", <br nodeIndex="4319">
DL_DEBUG_HELP }, <br nodeIndex="4320">
}; <br nodeIndex="4321">
#define ndebopts (sizeof (debopts) / sizeof (debopts[0]))</p>
<p brd="1" nodeIndex="696">/* Skip separating white spaces and commas. 跳过分界符空格和逗号*/ <br nodeIndex="4322">
while (*dl_debug != '\0')//value未结束 <br nodeIndex="4323">
{ <br nodeIndex="4324">
if (*dl_debug != ' ' && *dl_debug != ',' && *dl_debug != ':')//跳过多余的空格，逗号，冒号,如果有的话 <br nodeIndex="4325">
{ <br nodeIndex="4326">
size_t cnt; <br nodeIndex="4327">
size_t len = 1;</p>
<p brd="1" nodeIndex="697">while (dl_debug[len] != '\0' && dl_debug[len] != ' ' <br nodeIndex="4328">
&& dl_debug[len] != ',' && dl_debug[len] != ':') <br nodeIndex="4329">
++len;//查找本value后的分隔符</p>
<p brd="1" nodeIndex="698">for (cnt = 0; cnt < ndebopts; ++cnt)//在debopts中查找 <br nodeIndex="4330">
if (debopts[cnt].len == len <br nodeIndex="4331">
&& memcmp (dl_debug, debopts[cnt].name, len) == 0) <br nodeIndex="4332">
{ <br nodeIndex="4333">
GL(dl_debug_mask) |= debopts[cnt].mask;//置位 <br nodeIndex="4334">
any_debug = 1;//有调试选项 <br nodeIndex="4335">
break; <br nodeIndex="4336">
}</p>
<p brd="1" nodeIndex="699">if (cnt == ndebopts)//未找到，无效 <br nodeIndex="4337">
{ <br nodeIndex="4338">
/* Display a warning and skip everything until next 显示警告，在找到下一个分隔符之前跳过所有字符 <br nodeIndex="4339">
separator. */ <br nodeIndex="4340">
char *copy = strndupa (dl_debug, len); <br nodeIndex="4341">
_dl_error_printf ("\ <br nodeIndex="4342">
warning: debug option `%s' unknown; try LD_DEBUG=help\n", copy); <br nodeIndex="4343">
}</p>
<p brd="1" nodeIndex="700">dl_debug += len; <br nodeIndex="4344">
continue; <br nodeIndex="4345">
}</p>
<p brd="1" nodeIndex="701">++dl_debug; <br nodeIndex="4346">
}</p>
<p brd="1" nodeIndex="702">if (GL(dl_debug_mask) & DL_DEBUG_HELP)//显示help <br nodeIndex="4347">
{ <br nodeIndex="4348">
size_t cnt;</p>
<p brd="1" nodeIndex="703">_dl_printf ("\ <br nodeIndex="4349">
Valid options for the LD_DEBUG environment variable are:\n\n");</p>
<p brd="1" nodeIndex="704">for (cnt = 0; cnt < ndebopts; ++cnt) <br nodeIndex="4350">
_dl_printf (" %.*s%s%s\n", debopts[cnt].len, debopts[cnt].name, <br nodeIndex="4351">
" " + debopts[cnt].len - 3, <br nodeIndex="4352">
debopts[cnt].helptext);</p>
<p brd="1" nodeIndex="705">_dl_printf ("\n\ <br nodeIndex="4353">
To direct the debugging output into a file instead of standard output\n\ <br nodeIndex="4354">
a filename can be specified using the LD_DEBUG_OUTPUT environment variable.\n"); <br nodeIndex="4355">
_exit (0); <br nodeIndex="4356">
} <br nodeIndex="4357">
}</p>
<p brd="1" nodeIndex="706">举例 <br nodeIndex="4358">
[zws@mail ~/glibc-2.3/build/elf]$LD_DEBUG=help ls <br nodeIndex="4359">
Valid options for the LD_DEBUG environment variable are:</p>
<p brd="1" nodeIndex="707">libs display library search paths <br nodeIndex="4360">
reloc display relocation processing <br nodeIndex="4361">
files display progress for input file <br nodeIndex="4362">
symbols display symbol table processing <br nodeIndex="4363">
bindings display information about symbol binding <br nodeIndex="4364">
versions display version dependencies <br nodeIndex="4365">
all all previous options combined <br nodeIndex="4366">
statistics display relocation statistics <br nodeIndex="4367">
help display this help message and exit</p>
<p brd="1" nodeIndex="708">To direct the debugging output into a file instead of standard output <br nodeIndex="4368">
a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</p>
<p brd="1" nodeIndex="709">其他的选项大家自己试验一下看看</p>
<p brd="1" nodeIndex="710">7.process_envvars->process_dl_debug->strndupa (string/string.h)</p>
<p brd="1" nodeIndex="711">/* Return an alloca'd copy of at most N bytes of string. */ <br nodeIndex="4369">
# define strndupa(s, n) \ <br nodeIndex="4370">
(__extension__ \ <br nodeIndex="4371">
({ \ <br nodeIndex="4372">
__const char *__old = (s); \ <br nodeIndex="4373">
size_t __len = strnlen (__old, (n)); \ <br nodeIndex="4374">
char *__new = (char *) __builtin_alloca (__len + 1); \ <br nodeIndex="4375">
__new[__len] = '\0'; \ <br nodeIndex="4376">
(char *) memcpy (__new, __old, __len); \ <br nodeIndex="4377">
}))</p>
<p brd="1" nodeIndex="712">对应的汇编代码是 <br nodeIndex="4378">
.LBB78: <br nodeIndex="4379">
subl $8, %esp <br nodeIndex="4380">
pushl -16(%ebp) //参数len <br nodeIndex="4381">
pushl 8(%ebp) //参数dl_debug <br nodeIndex="4382">
.LCFI78: <br nodeIndex="4383">
call __strnlen@PLT//调用__strnlen,strnlen是__strnlen的weark_alias <br nodeIndex="4384">
addl $16, %esp//平栈,8+4+4 <br nodeIndex="4385">
leal 16(%eax), %edx//16+__len->%edx <br nodeIndex="4386">
andl $-16, %edx//%edx向地地址方向对齐到16字节边界 <br nodeIndex="4387">
subl %edx, %esp//__builtin_alloca 在栈上分配空间,实际分配的大小>=__len+16 <br nodeIndex="4388">
movl %esp, %edx//__new->%edx <br nodeIndex="4389">
movb $0, (%esp,%eax)//__new[__len] = '\0'; <br nodeIndex="4390">
subl $4, %esp <br nodeIndex="4391">
pushl %eax//参数__len <br nodeIndex="4392">
pushl 8(%ebp)//__old <br nodeIndex="4393">
pushl %edx//__new <br nodeIndex="4394">
call memcpy@PLT <br nodeIndex="4395">
addl $12, %esp//平栈 <br nodeIndex="4396">
.LBE78: <br nodeIndex="4397">
.loc 1 1710 0 <br nodeIndex="4398">
pushl %eax//copy <br nodeIndex="4399">
leal .LC56@GOTOFF(%ebx), %eax//warning: debug option `%s' unknown; try LD_DEBUG=help\n <br nodeIndex="4400">
pushl %eax <br nodeIndex="4401">
pushl $2//STDERR_FILENO <br nodeIndex="4402">
call _dl_dprintf <br nodeIndex="4403">
.LBE77: <br nodeIndex="4404">
addl $16, %esp//平栈，12+前面的subl $4,%esp的4字节 <br nodeIndex="4405">
.L700: <br nodeIndex="4406">
.loc 1 1714 0 <br nodeIndex="4407">
movl -16(%ebp), %eax <br nodeIndex="4408">
addl %eax, 8(%ebp)//dl_debug += len; <br nodeIndex="4409">
.loc 1 1715 0 <br nodeIndex="4410">
jmp .L685</p>
<p brd="1" nodeIndex="713"> <br nodeIndex="4411">
还要指出多次调用__builtin_alloca会不断的在栈上分配空间，即%esp向低地址方向增长。但是随着函数的返回，这些空间自然全部被释放。</p>
<p brd="1" nodeIndex="714"> <br nodeIndex="4412">
8.process_envvars->_dl_show_auxv(sysdeps/generic/dl-sysdep.c) <br nodeIndex="4413">
显示AUXV信息</p>
<p brd="1" nodeIndex="715">void <br nodeIndex="4414">
//internal_function <br nodeIndex="4415">
_dl_show_auxv (void) <br nodeIndex="4416">
{ <br nodeIndex="4417">
char buf[64]; <br nodeIndex="4418">
ElfW(auxv_t) *av;</p>
<p brd="1" nodeIndex="716">/* Terminate string. */ <br nodeIndex="4419">
buf[63] = '\0';</p>
<p brd="1" nodeIndex="717">/* The following code assumes that the AT_* values are encoded <br nodeIndex="4420">
下面的代码假定AT_*值从0(AT_NULL)开始编码,1代表AT_IGNORE,其他值? <br nodeIndex="4421">
starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values <br nodeIndex="4422">
close by (otherwise the array will be too large). In case we have <br nodeIndex="4423">
为避免必须支持不同平台，必须采用可定制实现 <br nodeIndex="4424">
to support a platform where these requirements are not fulfilled <br nodeIndex="4425">
some alternative implementation has to be used. */ <br nodeIndex="4426">
for (av = _dl_auxv; av->a_type != AT_NULL; ++av) <br nodeIndex="4427">
{ <br nodeIndex="4428">
static const struct <br nodeIndex="4429">
{ <br nodeIndex="4430">
const char label[20]; <br nodeIndex="4431">
enum { dec, hex, str } form; <br nodeIndex="4432">
} <br nodeIndex="4433">
auxvars[] = <br nodeIndex="4434">
{ <br nodeIndex="4435">
[AT_EXECFD - 2] = { "AT_EXECFD: ", dec }, <br nodeIndex="4436">
[AT_PHDR - 2] = { "AT_PHDR: 0x", hex }, <br nodeIndex="4437">
[AT_PHENT - 2] = { "AT_PHENT: ", dec }, <br nodeIndex="4438">
[AT_PHNUM - 2] = { "AT_PHNUM: ", dec }, <br nodeIndex="4439">
[AT_PAGESZ - 2] = { "AT_PAGESZ: ", dec }, <br nodeIndex="4440">
[AT_BASE - 2] = { "AT_BASE: 0x", hex }, <br nodeIndex="4441">
[AT_FLAGS - 2] = { "AT_FLAGS: 0x", hex }, <br nodeIndex="4442">
[AT_ENTRY - 2] = { "AT_ENTRY: 0x", hex }, <br nodeIndex="4443">
[AT_NOTELF - 2] = { "AT_NOTELF: ", hex }, <br nodeIndex="4444">
[AT_UID - 2] = { "AT_UID: ", dec }, <br nodeIndex="4445">
[AT_EUID - 2] = { "AT_EUID: ", dec }, <br nodeIndex="4446">
[AT_GID - 2] = { "AT_GID: ", dec }, <br nodeIndex="4447">
[AT_EGID - 2] = { "AT_EGID: ", dec }, <br nodeIndex="4448">
[AT_PLATFORM - 2] = { "AT_PLATFORM: ", str }, <br nodeIndex="4449">
[AT_HWCAP - 2] = { "AT_HWCAP: ", hex }, <br nodeIndex="4450">
[AT_CLKTCK - 2] = { "AT_CLKTCK: ", dec }, <br nodeIndex="4451">
[AT_FPUCW - 2] = { "AT_FPUCW: ", hex }, <br nodeIndex="4452">
[AT_DCACHEBSIZE - 2] = { "AT_DCACHEBSIZE: 0x", hex }, <br nodeIndex="4453">
[AT_ICACHEBSIZE - 2] = { "AT_ICACHEBSIZE: 0x", hex }, <br nodeIndex="4454">
[AT_UCACHEBSIZE - 2] = { "AT_UCACHEBSIZE: 0x", hex } <br nodeIndex="4455">
}; <br nodeIndex="4456">
unsigned int idx = (unsigned int) (av->a_type - 2);// -2忽略0,和1</p>
<p brd="1" nodeIndex="718">assert (AT_NULL == 0); <br nodeIndex="4457">
assert (AT_IGNORE == 1); <br nodeIndex="4458">
if (idx < sizeof (auxvars) / sizeof (auxvars[0])) <br nodeIndex="4459">
{ <br nodeIndex="4460">
if (av->a_type != AT_HWCAP || _dl_procinfo (av->a_un.a_val) < 0)//不是AT_HWCAP，或者是AT_HWCAP就调用_dl_procinfo,代码自己看 <br nodeIndex="4461">
{ <br nodeIndex="4462">
const char *val = av->a_un.a_ptr;</p>
<p brd="1" nodeIndex="719">if (__builtin_expect (auxvars[idx].form, dec) == dec)//十进制数据 <br nodeIndex="4463">
val = _itoa ((unsigned long int) av->a_un.a_val, <br nodeIndex="4464">
buf + sizeof buf - 1, 10, 0);//调用_itoa，代码自己看 <br nodeIndex="4465">
else if (__builtin_expect (auxvars[idx].form, hex) == hex) <br nodeIndex="4466">
val = _itoa ((unsigned long int) av->a_un.a_val, <br nodeIndex="4467">
buf + sizeof buf - 1, 16, 0);</p>
<p brd="1" nodeIndex="720">_dl_printf ("%s%s\n", auxvars[idx].label, val); <br nodeIndex="4468">
} <br nodeIndex="4469">
} <br nodeIndex="4470">
} <br nodeIndex="4471">
}</p>
<p brd="1" nodeIndex="721">举例 <br nodeIndex="4472">
[zws@mail elf]$ LD_SHOW_AUXV=1 ls <br nodeIndex="4473">
AT_SYSINFO: 0xffffe000 <br nodeIndex="4474">
AT_HWCAP: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe <br nodeIndex="4475">
AT_PAGESZ: 4096 <br nodeIndex="4476">
AT_CLKTCK: 100 <br nodeIndex="4477">
AT_PHDR: 0x8048034 <br nodeIndex="4478">
AT_PHENT: 32 <br nodeIndex="4479">
AT_PHNUM: 7 <br nodeIndex="4480">
AT_BASE: 0x40000000 <br nodeIndex="4481">
AT_FLAGS: 0x0 <br nodeIndex="4482">
AT_ENTRY: 0x8049690 <br nodeIndex="4483">
AT_UID: 503 <br nodeIndex="4484">
AT_EUID: 503 <br nodeIndex="4485">
AT_GID: 504 <br nodeIndex="4486">
AT_EGID: 504 <br nodeIndex="4487">
AT_PLATFORM: i686</p>
<p brd="1" nodeIndex="722">9.process_envvars->EXTRA_LD_ENVVARS (sysdeps/unix/sysv/linux/i386/dl-librecron.c) <br nodeIndex="4488">
额外的环境变量 <br nodeIndex="4489">
#define EXTRA_LD_ENVVARS \ <br nodeIndex="4490">
case 13: \ <br nodeIndex="4491">
if (memcmp (envline, "ASSUME_KERNEL", 13) == 0)/*指定内核版本*/ \ <br nodeIndex="4492">
{ \ <br nodeIndex="4493">
unsigned long int i, j, osversion = 0; \ <br nodeIndex="4494">
char *p = &envline[14], *q; \ <br nodeIndex="4495">
\ <br nodeIndex="4496">
for (i = 0; i < 3; i++, p = q + 1)/*i代表x.y.z中数的个数,共三个*/ \ <br nodeIndex="4497">
{ \ <br nodeIndex="4498">
j = __strtoul_internal (p, &q, 0, 0);/*版本字符串转换成数x.y.z*/ \ <br nodeIndex="4499">
if (j >= 255/*j不能>=255*/ || p == q /*该字符串不是数*/|| (i < 2 && *q && *q != '.')/*前两个数且后面还有字符，且该字符不为'.'*/) \ <br nodeIndex="4500">
{ \ <br nodeIndex="4501">
osversion = 0; \ <br nodeIndex="4502">
break; \ <br nodeIndex="4503">
} \ <br nodeIndex="4504">
osversion |= j << (16 - 8 * i);/*i==0,j<<16;i=-1;j<<8;i==2,j<<0,说明每个数占一个字节*/ \ <br nodeIndex="4505">
if (!*q) \ <br nodeIndex="4506">
break; \ <br nodeIndex="4507">
} \ <br nodeIndex="4508">
if (osversion) \ <br nodeIndex="4509">
GL(dl_osversion) = osversion; \ <br nodeIndex="4510">
break; \ <br nodeIndex="4511">
} \ <br nodeIndex="4512">
\ <br nodeIndex="4513">
case 15: \ <br nodeIndex="4514">
if (memcmp (envline, "LIBRARY_VERSION", 15) == 0) \ <br nodeIndex="4515">
{ \ <br nodeIndex="4516">
GL(dl_correct_cache_id) = envline[16] == '5' ? 2 : 3;/*值为5,则dl_correct_cache_id=2；否则为dl_correct_cache_id=3*/ \ <br nodeIndex="4517">
break; \ <br nodeIndex="4518">
}</p>
<p brd="1" nodeIndex="723">10.返回process_envvars</p>
<p brd="1" nodeIndex="724">/* The caller wants this information. */ <br nodeIndex="4519">
*modep = mode;</p>
<p brd="1" nodeIndex="725">/* Extra security for SUID binaries. Remove all dangerous environment <br nodeIndex="4520">
因为是SUID程序，移除所有危险环境变量 <br nodeIndex="4521">
variables. */ <br nodeIndex="4522">
if (__builtin_expect (INTUSE(__libc_enable_secure), 0)) <br nodeIndex="4523">
{ <br nodeIndex="4524">
static const char unsecure_envvars[] = <br nodeIndex="4525">
//#ifdef EXTRA_UNSECURE_ENVVARS <br nodeIndex="4526">
/*该宏定义在sysdeps/unix/sysv/linux/i386/dl-librecon.h <br nodeIndex="4527">
/* <br nodeIndex="4528">
Extra unsecure variables. The names are all stuffed in a single <br nodeIndex="4529">
特别不安全变量。这些名字被组合成单个字符串，因此需要显示使用'\0' 结束这些名字 <br nodeIndex="4530">
string which means they have to be terminated with a '\0' explicitly. * / <br nodeIndex="4531">
#define EXTRA_UNSECURE_ENVVARS \ <br nodeIndex="4532">
"LD_AOUT_LIBRARY_PATH\0" \ <br nodeIndex="4533">
"LD_AOUT_PRELOAD\0" <br nodeIndex="4534">
*/ <br nodeIndex="4535">
EXTRA_UNSECURE_ENVVARS <br nodeIndex="4536">
//#endif <br nodeIndex="4537">
/*该宏定义在sysdeps/generic/unsecvars.h <br nodeIndex="4538">
/* <br nodeIndex="4539">
Environment variable to be removed for SUID programs. The names are <br nodeIndex="4540">
all stuffed in a single string which means they have to be terminated <br nodeIndex="4541">
with a '\0' explicitly. * / <br nodeIndex="4542">
#define UNSECURE_ENVVARS \ <br nodeIndex="4543">
"LD_PRELOAD\0" \ <br nodeIndex="4544">
"LD_LIBRARY_PATH\0" \ <br nodeIndex="4545">
"LD_ORIGIN_PATH\0" \ <br nodeIndex="4546">
"LD_DEBUG_OUTPUT\0" \ <br nodeIndex="4547">
"LD_PROFILE\0" \ <br nodeIndex="4548">
"GCONV_PATH\0" \ <br nodeIndex="4549">
"HOSTALIASES\0" \ <br nodeIndex="4550">
"LOCALDOMAIN\0" \ <br nodeIndex="4551">
"LOCPATH\0" \ <br nodeIndex="4552">
"MALLOC_TRACE\0" \ <br nodeIndex="4553">
"NLSPATH\0" \ <br nodeIndex="4554">
"RESOLV_HOST_CONF\0" \ <br nodeIndex="4555">
"RES_OPTIONS\0" \ <br nodeIndex="4556">
"TMPDIR\0" \ <br nodeIndex="4557">
"TZDIR\0"</p>
<p brd="1" nodeIndex="726">*/ <br nodeIndex="4558">
UNSECURE_ENVVARS; <br nodeIndex="4559">
const char *nextp;</p>
<p brd="1" nodeIndex="727">nextp = unsecure_envvars; <br nodeIndex="4560">
do <br nodeIndex="4561">
{ <br nodeIndex="4562">
unsetenv (nextp);//注销该环境变量,其实就是将后面的环境变量指针往前移，覆盖掉该变量指针 <br nodeIndex="4563">
/* We could use rawmemchr but this need not be fast. */ <br nodeIndex="4564">
nextp = (char *) (strchr) (nextp, '\0') + 1; <br nodeIndex="4565">
} <br nodeIndex="4566">
while (*nextp != '\0');</p>
<p brd="1" nodeIndex="728">if (__access ("/etc/suid-debug", F_OK) != 0)//不存在文件/etc/suid-debug <br nodeIndex="4567">
unsetenv ("MALLOC_CHECK_");//注销MALLOC_CHECK_ <br nodeIndex="4568">
} <br nodeIndex="4569">
/* If we have to run the dynamic linker in debugging mode and the <br nodeIndex="4570">
不是SUID程序，如果我们必须运行dl在调试模式下，并且存在环境变量LD_DEBUG_OUTPUT <br nodeIndex="4571">
LD_DEBUG_OUTPUT environment variable is given, we write the debug <br nodeIndex="4572">
则将调试信息写入这个文件 <br nodeIndex="4573">
messages to this file. */ <br nodeIndex="4574">
else if (any_debug && debug_output != NULL) <br nodeIndex="4575">
{ <br nodeIndex="4576">
//#ifdef O_NOFOLLOW <br nodeIndex="4577">
const int flags = O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW; <br nodeIndex="4578">
//#else <br nodeIndex="4579">
// const int flags = O_WRONLY | O_APPEND | O_CREAT; <br nodeIndex="4580">
//#endif <br nodeIndex="4581">
size_t name_len = strlen (debug_output); <br nodeIndex="4582">
char buf[name_len + 12];//在栈上动态分配 <br nodeIndex="4583">
char *startp;</p>
<p brd="1" nodeIndex="729">buf[name_len + 11] = '\0'; <br nodeIndex="4584">
startp = _itoa (__getpid (), &buf[name_len + 11], 10, 0);//存入buf的最后 <br nodeIndex="4585">
*--startp = '.';//前面加. <br nodeIndex="4586">
startp = memcpy (startp - name_len, debug_output, name_len);//复制debug_output,组成x.y格式</p>
<p brd="1" nodeIndex="730">GL(dl_debug_fd) = __open (startp, flags, DEFFILEMODE); <br nodeIndex="4587">
if (GL(dl_debug_fd) == -1) <br nodeIndex="4588">
/* We use standard output if opening the file failed. */ <br nodeIndex="4589">
GL(dl_debug_fd) = STDOUT_FILENO; <br nodeIndex="4590">
} <br nodeIndex="4591">
}</p>

</div>