---
layout: post
title: Releases/FeatureBuildId
categories:
- Pocket
tags:
---
原文地址：http://fedoraproject.org/wiki/Releases/FeatureBuildId

收藏时间：2015-04-25 10:04:29

<div  lang="en">
<h2 nodeIndex="104"><span class="mw-headline" id="Summary" nodeIndex="272">Summary</span></h2>
<ul nodeIndex="106"><li nodeIndex="105">Make core dumps self-identifying enough to find the exact correct versions of all relevant binaries and debuginfo</li>
<li nodeIndex="107">Optimize debuginfo validation to avoid current whole-file checksumming</li>
</ul><h2 nodeIndex="108"><span class="mw-headline" id="Owner" nodeIndex="273">Owner</span></h2>
<ul nodeIndex="110"><li nodeIndex="109">Name: RolandMcGrath</li>
</ul><h2 nodeIndex="111"><span class="mw-headline" id="Current_status" nodeIndex="274">Current status</span></h2>
<ul nodeIndex="113"><li nodeIndex="112">Targeted release: <a href="http://fedoraproject.org/wiki/Releases/8" title="Releases/8" nodeIndex="275">Fedora 8</a></li>
<li nodeIndex="114">
<li nodeIndex="115">Percentage of completion: 100%</li>
</ul><h2 nodeIndex="116"><span class="mw-headline" id="Detailed_Description" nodeIndex="276">Detailed Description</span></h2>
<h2 nodeIndex="117"><span class="mw-headline" id="The_Problems" nodeIndex="277">The Problems</span></h2>
<h3 nodeIndex="118"><span class="mw-headline" id="Quick_debuginfo_validation" nodeIndex="278">Quick debuginfo validation</span></h3>
<p nodeIndex="119">The current <code nodeIndex="279">.gnu_debuglink</code> ties a stripped object (executable, DSO, <code nodeIndex="280">.ko</code>) to its <code nodeIndex="281">.debug</code> file with a name (in practice always <code nodeIndex="282">foobar.debug</code> in a file originally called <code nodeIndex="283">/some/thing/foobar</code>), and a (weak) CRC32 checksum of the <code nodeIndex="284">.debug</code> file. The only way to find the <code nodeIndex="285">.debug</code> file is by name based on knowing the name of the stripped object, the two having come in parallel from rpm or whatever. The only way to verify it's really the right one is to read the entire contents of the <code nodeIndex="286">.debug</code> file from disk to checksum it. This is obviously poor for memory and I/O performance, especially as the DWARF consumers keep improving to avoid reading in as much debuginfo at once.</p>
<p nodeIndex="120">A while ago, a few of us spoke about improving this. What we discussed was switching to a strong checksum (sha1sum) so that comparing two stored checksums is sufficient for confidence in validation. The important change is to have the checksum stored in both the <code nodeIndex="287">.debug</code> file and the stripped file, so that there is a small amount of data to read from the file that is sufficient to do the validation. We had in mind simply a new kind of debuglink section (still not allocated) that <code nodeIndex="288">eu-strip</code>/<code nodeIndex="289">objcopy</code> would insert into both output files. We didn't really change the checksum plan aside from the algorithm, i.e. using sha1sum of the entire unstripped file or of the <code nodeIndex="290">.debug</code> file with an all-zeros debuglink section.</p>
<p nodeIndex="121">In later contemplation, I became dissatisfied with using a checksum on the entire contents of the <code nodeIndex="291">.debug</code> file. I would like to be able to perform transformations on the DWARF data after the fact (fancy compression et al) and still say "this is the DWARF data for your binary". It feels wrong to have to edit the stripped binary to make it match transformed debug data. (In the abstract, I also think one should always be able to do spurious ELF file layout juggling that doesn't change the semantics of the data.) So I thought about using sha1sum of the loaded segments and phdrs or something. But that's not right. Your <code nodeIndex="292">main(){}</code> and my <code nodeIndex="293">main(){}</code> are going to produce the same stripped binaries, but my binaries should get me the source code with my comments in it, and not yours just because it's identical modulo pontification. (It's all about the pontification!) But, the real plan behind using a strong checksum was never actually to compute a checksum from the data ever again after build time, because you really just rely on the comparison of a strongly unique embedded identifier.</p>

<h3 nodeIndex="123"><span class="mw-headline" id="Finding_binaries_for_dumps" nodeIndex="295">Finding binaries for dumps</span></h3>
<p nodeIndex="124">People dealing with core files often confront the problem of not knowing exactly which executable and DSO binaries were in use when the program was running. It may have been hours or months after the crash happened when a person is attempting ernest post-mortem analysis, and one really needs to have the right binaries to get anywhere. Normally the text segments are elided from the dump, so you don't have the original code to examine or to compare to a file on disk you think was the one in use.</p>
<p nodeIndex="125">For post-mortem debugging now, the only way to find the DSOs involved is to examine the dynamic linker's data in the dump's memory image where quasi-standard data structures give the file names the dynamic linker used to open the DSOs. That process requires you know the right address in the executable's data to look at, or know the right dynamic linker file to consult and grok its internal symbols. So even to get bootstrapped, you need to have the right executable file (or perhaps the right dynamic linker). Then, all you have are names, with no clear way to know whether the files by those names now match what existed there when this dump was made.</p>
<p nodeIndex="126">The case of kernel-mode/whole-machine dumps is not fundamentally different from user core dump files, except that usually all the memory is dumped so you have the text to look at.</p>
<p nodeIndex="127">File storage space being what it is, perhaps many people would be happy to have core dumps include the full text segments ( <a href="http://fedoraproject.org/w/index.php?title=Coresysctl&action=edit&redlink=1" class="new" title="Coresysctl (page does not exist)" nodeIndex="296">see below</a> ); the data being dumped is often far larger than the text already. Full text segments are very handy to make e.g. disassembly and unwind info (if in <code nodeIndex="297">.eh_frame</code>) available immediately without consulting any other files at all. But, often you really want to know the detailed provenance of the binary, or at least quickly find the debuginfo that goes with it. What you need from the dump is an unambiguous identifier that you can associate with each DSO/executable that went into the crash. Having the whole text is not so important, because you really just rely on the lookup and comparison of a strongly unique embedded identifier.</p>

<h2 nodeIndex="129"><span class="mw-headline" id="The_Plan" nodeIndex="299">The Plan</span></h2>
<h3 nodeIndex="130"><span class="mw-headline" id="Unique_build_ID" nodeIndex="300">Unique build ID</span></h3>
<p nodeIndex="131">What we really want is a unique build ID. At first I liked the canonical UUID generation for this (128 bits of random or of something time and host-based). But that has the very undesireable property of making for unreproducible builds, where it's between difficult and impossible to start from the same conditions and repeat the procedure of making binaries from all the same constituents to get binaries without gratuitous differences from the original build. Perhaps something like <code nodeIndex="301">sha1sum</code> of the unstripped file is what we want to use as the basis of a reproducible identifier unique to completely identical builds. But I'd like to specify it explicitly as being a unique identifier good only for matching, not any kind of checksum that can be verified against the contents. (There are external general means for content verification, and I don't think debuginfo association needs to do that.)</p>
<p nodeIndex="132">To embed an ID into both the stripped object and its <code nodeIndex="302">.debug</code> file, I've chosen to use an ELF note section. <code nodeIndex="303">strip</code> et al can keep the section intact in both files when its type is <code nodeIndex="304">SHT_NOTE</code>. The new section is canonically called <code nodeIndex="305">.note.gnu.build-id</code>, but the name is not normative, and the section can be merged with other <code nodeIndex="306">SHT_NOTE</code> sections. The ELF note headers give name <code nodeIndex="307">"GNU"</code> and type 3 (<code nodeIndex="308">NT_GNU_BUILD_ID</code>) for a build ID note, of which there can be only one in a linked object (or an <code nodeIndex="309">ET_REL</code> file of the <code nodeIndex="310">.ko</code> style). The <code nodeIndex="311">descsz</code> and the following data can be any nonzero number of bytes chosen by the producer. It should be long enough to be plausibly truly unique while not being unreasonably long to use as a shorthand. The bits should be chosen in a fashion that makes it a useful approximation of true uniqueness across all binaries that might be used by overlapping sets of people. Likely common sizes are 16 (UUID or MD5) and 20 (SHA1). The section canonically has <code nodeIndex="312">SHF_ALLOC</code> in <code nodeIndex="313">sh_flags</code>, meaning it appears in the loaded memory image, and the normal link order puts allocated note sections very early in the memory image.</p>
<h3 nodeIndex="133"><span class="mw-headline" id="Use_build_ID_to_validate_debuginfo" nodeIndex="314">Use build ID to validate debuginfo</span></h3>
<p nodeIndex="134">DWARF consumers that look at separate debuginfo files to go with a stripped file now validate their association by doing CRC32 on the whole debuginfo file (sometimes huge) to compare with the <code nodeIndex="315">.gnu_debuglink</code> checksum. They can change to check for a build ID note in the stripped file. When a build ID is present, check that the debuginfo file contains an identical corresponding <code nodeIndex="316">SHT_NOTE</code> section. This requires reading only a small part of each file, probably the first and last pages of each.</p>
<h3 nodeIndex="135"><span class="mw-headline" id="Include_build_IDs_in_core_dumps" nodeIndex="317">Include build IDs in core dumps</span></h3>
<p nodeIndex="136">In the kernel's core dump code, it's easy to detect the mappings likely to be the first mapping for an executable or DSO: <code nodeIndex="318">MAP_PRIVATE</code> to a file at offset 0, with <code nodeIndex="319">ELFMAG</code> in the first word of the mapped contents. For each of those, include the first page of the mapping in the core dump (<code nodeIndex="320">p_filesz</code> = <code nodeIndex="321">PAGE_SIZE</code>, <code nodeIndex="322">p_memsz</code> = larger total). The build ID note is normally near the beginning of the image and will be in the first page unless there are an unreasonable number of phdrs or other notes. (The kernel should not deal with anything more complex than a simple rule like the first page, so the odd binary with its notes in the wrong places will just lose.) If it was some innocent mmap'ing and not really a loaded DSO or the executable, then no harm done. Noone minds several extra pages in a core dump (it just shouldn't have whole huge text segments).</p>
<p nodeIndex="137">It's possible that existing consumers are confused by a core file <code nodeIndex="323">PT_LOAD</code> segment with <code nodeIndex="324">p_filesz</code> < <code nodeIndex="325">p_memsz</code> but not <code nodeIndex="326">p_filesz</code> == 0. If need be, we can write a simple tool to extract ELF ident notes and list ID:address associations while removing the extra pages from the core file. GDB loaded the remaining part of the code segments zeroed, fix is accepted upstream and present since Rawhide gdb-6.6-21.fc8.</p>

<h2 nodeIndex="139"><span class="mw-headline" id="The_Work" nodeIndex="328">The Work</span></h2>
<p nodeIndex="140">Work I have done so far that is not already upstream is in <a class="external free" href="http://people.redhat.com/roland/build-id/" nodeIndex="329">http://people.redhat.com/roland/build-id/</a>.</p>
<h3 nodeIndex="141"><span class="mw-headline" id="Put_a_build_ID_into_every_binary" nodeIndex="330">Put a build ID into every binary</span></h3>
<ul nodeIndex="143"><li nodeIndex="142">Compiler toolchain</li>
</ul><ul nodeIndex="145"><li nodeIndex="144"><code nodeIndex="331">ld</code>: new option <code nodeIndex="332">--build-id</code> <b nodeIndex="333">DONE</b></li>
</ul><p nodeIndex="146">This adds an option to <code nodeIndex="334">ld</code> to synthesize a <code nodeIndex="335">.note.gnu.build-id</code> section with type <code nodeIndex="336">SHT_NOTE</code> and flags <code nodeIndex="337">SHF_ALLOC</code> (read-only data), that contains an ELF note header and the build ID bits. This then goes into the link as if it were part of the first object file (so it may be placed or merged by the linker script). The build ID bits are determined as the very last thing <code nodeIndex="338">ld</code> does before writing out the linked file. You can give <code nodeIndex="339">--build-id=<i nodeIndex="340">style</i></code> chose <code nodeIndex="341">md5</code>, <code nodeIndex="342">uuid</code> (128 random bits), or <code nodeIndex="343">0x<i nodeIndex="344">abcdef</i></code> (your chosen bytes in hex). Just <code nodeIndex="345">--build-id</code> defaults to <code nodeIndex="346">md5</code>, which computes an 128-bit MD5 signature based all the ELF header bits and section contents in the file--i.e., an ID that is unique among the set of meaningful contents for ELF files and identical when the output file would otherwise have been identical.</p>
<p nodeIndex="147">The Linux binutils-2.17.50.0.17 release includes this, in f8test1.</p>
<p nodeIndex="148">binutils-2.17.50.0.17-3 and later in Rawhide have the feature.</p>
<ul nodeIndex="150"><li nodeIndex="149"><code nodeIndex="347">eu-strip</code>: keep allocated notes in debuginfo <b nodeIndex="348">DONE</b></li>
</ul><p nodeIndex="151">The <code nodeIndex="349">-f</code> option used for separate debuginfo generation has been changed to preserve all <code nodeIndex="350">SHT_NOTE</code> sections intact in the debuginfo file. The version released in <code nodeIndex="351">elfutils-0.128</code> does this.</p>
<ul nodeIndex="153"><li nodeIndex="152"><code nodeIndex="352">objcopy</code>: keep allocated notes in debuginfo <b nodeIndex="353">DONE</b></li>
</ul><p nodeIndex="154">The <code nodeIndex="354">--only-keep-debug</code> option is used for separate debuginfo generation in regimes not using <code nodeIndex="355">elfutils</code>. I have committed a change upstream to keep all <code nodeIndex="356">SHT_NOTE</code> sections intact in the debuginfo file. The Linux binutils-2.17.50.0.17 release includes this, in f8test1.</p>
<ul nodeIndex="156"><li nodeIndex="155">compiler passes option by default <b nodeIndex="357">POSTED</b>, <b nodeIndex="358">RAWHIDE</b></li>
</ul><p nodeIndex="157">So this can be useful all the time, the default compiler settings should pass <code nodeIndex="359">--build-id</code> for every normal final link of a DSO or executable. Probably <code nodeIndex="360">%{!nostartfiles:--build-id}</code> or something. We can try this first in Fedora 8, but I think it is a reasonable default for upstream gcc once ld supports <code nodeIndex="361">--build-id</code>.</p>
<p nodeIndex="158"> <br nodeIndex="362">
f8test1 gcc has this. I've sent a patch upstream, but it has not been integrated yet.</p>
<ul nodeIndex="160"><li nodeIndex="159">Packaging</li>
</ul><ul nodeIndex="162"><li nodeIndex="161"><code nodeIndex="363">debugedit</code> <b nodeIndex="364">DONE</b></li>
</ul><p nodeIndex="163">The program <code nodeIndex="365">/usr/lib/rpm/debugedit</code> is used in <code nodeIndex="366">rpm</code>'s separate debuginfo creation. It modifies DWARF data to replace the build-time absolute directory names with consistent names. This makes the installed debuginfo's source references usable, and it makes for reproducible rpm builds from identical constituents to produce identical binaries. The build ID computed by <code nodeIndex="367">ld</code> was affected by the name of the rpm build directory, so it will differ between two otherwise identical builds that used a different <code nodeIndex="368">$RPM_BUILD_ROOT</code>.</p>
<p nodeIndex="164"> adds the <code nodeIndex="369">-i</code> option to make <code nodeIndex="370">debugedit</code> recompute the build ID based on the contents of the file after the transformation. It also prints out the build ID bits in hex.</p>
<p nodeIndex="165">This is in rpm-4.4.2.1, in f8-test1.</p>
<ul nodeIndex="167"><li nodeIndex="166"><code nodeIndex="371">find-debuginfo.sh</code> <b nodeIndex="372">DONE</b></li>
</ul><p nodeIndex="168">The <code nodeIndex="373">/usr/lib/rpm/find-debuginfo.sh</code> script is what runs <code nodeIndex="374">debugedit</code>. I've <a class="external text" href="http://people.redhat.com/roland/build-id/find-debuginfo-build-id.patch" nodeIndex="375">modified</a> the script to pass the new option to <code nodeIndex="376">debugedit</code>. Since my goal for Fedora8 is to have a build ID in every binary in the distribution, I've made it more sensitive to errors from <code nodeIndex="377">debugedit</code> and it will fail if there was no build ID. It also adds to the debuginfo package a symlink to the binary and to the debuginfo file from <code nodeIndex="378">/usr/lib/debug/.build-id/</code>; [#symlinks see below] .</p>
<p nodeIndex="169">The new script is part of rpm-build >= 4.4.2.1-4.fc8, in Rawhide after test1.</p>

<h3 nodeIndex="171"><span class="mw-headline" id="Linux_kernel_changes" nodeIndex="380">Linux kernel changes</span></h3>
<ul nodeIndex="173"><li nodeIndex="172">core dump code <b nodeIndex="381">SUBMITTED</b>,<b nodeIndex="382">RAWHIDE</b></li>
</ul><p nodeIndex="174"><span id="coresysctl" nodeIndex="383"></span> The upstream 2.6.23 kernel includes new controls via /proc/pid/coredump_filter. My patch adds a new bit there, which makes core dumping include the first page of an ELF file mapping that would otherwise have been elided. This is turned on by default in F8, but can be disabled for a process and its children via /proc/pid/coredump_filter.</p>
<p nodeIndex="175">kernel-2.6.23-0.30.rc0.git6.fc8 and later in Rawhide have the feature.</p>
<ul nodeIndex="177"><li nodeIndex="176">use <code nodeIndex="384">--build-id</code> on the kernel <b nodeIndex="385">DONE</b></li>
</ul><p nodeIndex="178"><a class="external text" href="http://people.redhat.com/roland/build-id/series" nodeIndex="386">My patch series</a> changes the kernel linker script on several machines to handle allocated note sections, and uses <code nodeIndex="387">--build-id</code> when <code nodeIndex="388">ld</code> supports it. Any other oddball programs that have a really good reason to use the linker directly instead of letting the compiler chose the options also need to be changed.</p>
<p nodeIndex="179">This is incorporated upstream now.</p>
<ul nodeIndex="181"><li nodeIndex="180">xen <b nodeIndex="389">NEEDED</b></li>
</ul><p nodeIndex="182">Use <code nodeIndex="390">--build-id</code> when linking the hypervisor.</p>
<ul nodeIndex="184"><li nodeIndex="183">assembly debuginfo <b nodeIndex="391">POSTED</b>,<b nodeIndex="392">RAWHIDE</b></li>
</ul><p nodeIndex="185"><a class="external text" href="http://people.redhat.com/roland/build-id/series" nodeIndex="393">My patch series</a> turns on <code nodeIndex="394">-g</code> for assembly files in the kernel, so the debuginfo is useful for even more of the code (to read comments in the source and so forth).</p>
<p nodeIndex="186">This is in -mm, and is enabled in Rawhide kernels now.</p>
<ul nodeIndex="188"><li nodeIndex="187">vDSO debuginfo <b nodeIndex="395">POSTED</b>,<b nodeIndex="396">RAWHIDE</b></li>
</ul><p nodeIndex="189"><a class="external text" href="http://people.redhat.com/roland/build-id/series" nodeIndex="397">My patch series</a> also has the kernel's <code nodeIndex="398">make install</code> copy unstripped versions of the vDSO images into <code nodeIndex="399">/lib/modules/.../vdso</code> alongside the kernel's modules. These are linked as normal DSOs via <code nodeIndex="400">gcc</code>, so they will get build IDs implicitly. Having these on disk means that when a build ID is found in the vDSO image embedded in a core dump, the same means used for normal DSOs can find the kernel debuginfo package and lead to seeing the vDSO's assembly in original source form.</p>
<p nodeIndex="190">This is in -mm, and is enabled in Rawhide kernels now.</p>
<ul nodeIndex="192"><li nodeIndex="191">/sys/kernel/notes <b nodeIndex="401">DONE</b></li>
</ul><p nodeIndex="193">The bonus feature in <a class="external text" href="http://people.redhat.com/roland/build-id/series" nodeIndex="402">my patch series</a> adds the magic file <code nodeIndex="403">/sys/kernel/notes</code>. Reading this gives you the binary contents of the ELF notes section built into the kernel. Here you can find the build ID of the running kernel. This gives a solution to a problem that has arisen for <code nodeIndex="404">systemtap</code> users, where nothing prevents them from using the <code nodeIndex="405">kernel-debuginfo.i586</code> data to drive Systemtap's probe details, but are actually running the kernel from the <code nodeIndex="406">kernel.i686</code> rpm. This is a failure on many levels, but some simple sanity-checking at the bottom always helps. Now it is easy to verify you have the right debuginfo file for the kernel you are running.</p>
<p nodeIndex="194">This is incorporated upstream now.</p>

<h3 nodeIndex="196"><span class="mw-headline" id="Replace_debuginfo_CRC32_check" nodeIndex="408">Replace debuginfo CRC32 check</span></h3>
<p nodeIndex="197">The consumers of debuginfo files that now use the CRC32 value in the <code nodeIndex="409">.gnu_debuglink</code> section can look for build IDs and compare those instead.</p>
<ul nodeIndex="199"><li nodeIndex="198"><code nodeIndex="410">gdb</code> (<code nodeIndex="411">bfd</code>) <b nodeIndex="412">RAWHIDE</b></li>
<li nodeIndex="200"><code nodeIndex="413">elfutils</code> (<code nodeIndex="414">libdwfl</code>) <b nodeIndex="415">UPSTREAM</b></li>
</ul><h3 nodeIndex="201"><span class="mw-headline" id="Find_files_by_build_ID" nodeIndex="416">Find files by build ID</span></h3>
<p nodeIndex="202">There needs to be some standard way to take a build ID gleaned from a memory dump and look it up to learn its proper name and find its debuginfo file. A large organization producing lots of builds might want to incorporate build ID info into their own database tracking the details of all their builds. Such complex things are beyond the scope of my what I've designed.</p>

<ul nodeIndex="205"><li nodeIndex="204">Packager/consumer convention. <b nodeIndex="418">now de facto standard</b></li>
</ul><p nodeIndex="206">My current thinking is to use some simple filesystem conventions for looking up build IDs. This uses everybody's favorite backend database for file-sized objects keyed by fixed-size bitstrings, the humble Unix directory. At least for system installed binaries, this seems appropriately simple and adequate for the number of unique IDs in use on one system.</p>
<p nodeIndex="207">My plan is that the debuginfo directory contains a <code nodeIndex="419">.build-id/</code> subdirectory of symlinks named by the build ID bits rendered in ASCII hex, one symlink to the stripped file and one to the debuginfo file. For example, <code nodeIndex="420">/usr/lib/debug/.build-id/ab/cdef1234</code> for <code nodeIndex="421">abcdef1234</code> (real ones are 32 or more chars long, not 10), so <code nodeIndex="422">/usr/bin/foo</code> might yield:</p>
<pre nodeIndex="208">
/usr/lib/debug/.build-id/ab/cdef1234 -> ../../../../bin/foo
/usr/lib/debug/.build-id/ab/cdef1234.debug -> ../../usr/bin/foo.debug
</pre>
<p nodeIndex="209">The advantages of this are:</p>
<ul nodeIndex="211"><li nodeIndex="210">Use existing configuration for debuginfo directory or path</li>
</ul><p nodeIndex="212">Consumers can just start looking for <code nodeIndex="423">.build-id/...</code> in the directories where they now look for debuginfo files by name, no new user configuration is required.</p>
<ul nodeIndex="214"><li nodeIndex="213">Simple convention for all users, packagers, consumers to follow</li>
<li nodeIndex="215">Optimal for consumers</li>
</ul><p nodeIndex="216">Go from build ID bits to open debuginfo file in one system call.</p>
<ul nodeIndex="218"><li nodeIndex="217">Simple addition to existing packaging</li>
</ul><p nodeIndex="219">For rpm, the changes in <code nodeIndex="424">find-debuginfo.sh</code> are straightforward, so build-ID symlinks are included in the debuginfo rpm automatically along with the debuginfo files and source files.</p>
<ul nodeIndex="221"><li nodeIndex="220">Leverage existing packaging support for files</li>
<li nodeIndex="222"><code nodeIndex="425">yum install /usr/lib/debug/.build-id/...</code> works with no special support</li>
<li nodeIndex="223">If something goes awry in the toolchain, existing mechanisms for</li>
</ul><p nodeIndex="224">e.g. finding file names included in two different packages in the same repository can flag it for the debuginfo repository.</p>
<ul nodeIndex="226"><li nodeIndex="225">Fedora 8 rebuild with build IDs in binaries, symlinks in debuginfo <b nodeIndex="426">DONE</b></li>
</ul><ul nodeIndex="228"><li nodeIndex="227"><code nodeIndex="427">libdwfl</code> (<code nodeIndex="428">elfutils</code>) build ID-aware consumer</li>
<li nodeIndex="229">build ID-driven find_debuginfo <b nodeIndex="429">UPSTREAM</b></li>
<li nodeIndex="230">build ID recovery from core files <b nodeIndex="430">WORK IN PROGRESS</b></li>
</ul><p nodeIndex="231">This is in upstream elfutils and may still make F8 release. If not, it will be in an elfutils update shortly after F8.</p>
<ul nodeIndex="233"><li nodeIndex="232"><code nodeIndex="431">bfd</code> (<code nodeIndex="432">gdb</code>) build ID-aware consumer <b nodeIndex="433">RAWHIDE</b></li>
</ul><p nodeIndex="234">Jan Kratochvil is working on this for F8.</p>

<h3 nodeIndex="236"><span class="mw-headline" id="Compatibility_testing" nodeIndex="435">Compatibility testing</span></h3>
<p nodeIndex="237">DONE: old gdb no good</p>
<p nodeIndex="238">Existing versions of gdb are confused by a core file with segments that are only partially present in the dump but not elided completely. With my patch the kernel produces these, which have not been seen before. The meaning of the ELF header fields is perfectly clear and valid for this case, but it is a new wrinkle compared to tradition. This is why the new format option won't be enabled by default in upstream kernels for some time to come.</p>
<h2 nodeIndex="239"><span class="mw-headline" id="User_Experience" nodeIndex="436">User Experience</span></h2>
<p nodeIndex="240">End users don't really notice an impact. The big help is that development tools will be more efficient in finding their debuginfo</p>
<h2 nodeIndex="241"><span class="mw-headline" id="Dependencies" nodeIndex="437">Dependencies</span></h2>
<p nodeIndex="242">Self-contained, but a fair number of tools need changing (see above)</p>
<h2 nodeIndex="243"><span class="mw-headline" id="Contingency_Plan" nodeIndex="438">Contingency Plan</span></h2>
<p nodeIndex="244">Things have to continue to work whether or not they're built with the new information, so the contingency is just that this partially implemented.</p>
<h2 nodeIndex="245"><span class="mw-headline" id="Documentation" nodeIndex="439">Documentation</span></h2>
<p nodeIndex="246">See above.</p>
<h2 nodeIndex="247"><span class="mw-headline" id="Release_Notes" nodeIndex="440">Release Notes</span></h2>
<p nodeIndex="248">See above.</p>
</div>