---
layout: post
title: Load-time relocation of shared libraries
categories:
- Pocket
tags:
---
原文地址：http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries

收藏时间：2015-03-20 09:47:01

<div  lang="en">



<div class="section" id="loading-executables" nodeIndex="19">
<h3 nodeIndex="20">Loading executables</h3>
<p nodeIndex="21">Linux, similarly to other OSes with virtual memory support, loads executables to a fixed memory address. If we examine the ELF header of some random executable, we'll see an <em nodeIndex="202">Entry point address</em>:</p>

<p nodeIndex="24">This is placed by the linker to tell the OS where to start executing the executable's code <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id14" id="id1" nodeIndex="203">[1]</a>. And indeed if we then load the executable with GDB and examine the address <tt class="docutils literal" nodeIndex="204">0x8048470</tt>, we'll see the first instructions of the executable's <tt class="docutils literal" nodeIndex="205">.text</tt> segment there.</p>
<p nodeIndex="25">What this means is that the linker, when linking the executable, can fully resolve all <em nodeIndex="206">internal</em> symbol references (to functions and data) to fixed and final locations. The linker does some relocations of its own <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id15" id="id2" nodeIndex="207">[2]</a>, but eventually the output it produces contains no additional relocations.</p>
<p nodeIndex="26">Or does it? Note that I emphasized the word <em nodeIndex="208">internal</em> in the previous paragraph. As long as the executable needs no shared libraries <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id16" id="id3" nodeIndex="209">[3]</a>, it needs no relocations. But if it <em nodeIndex="210">does</em> use shared libraries (as do the vast majority of Linux applications), symbols taken from these shared libraries need to be relocated, because of how shared libraries are loaded.</p>
</div>
<div class="section" id="loading-shared-libraries" nodeIndex="27">
<h3 nodeIndex="28">Loading shared libraries</h3>
<p nodeIndex="29">Unlike executables, when shared libraries are being built, the linker can't assume a known load address for their code. The reason for this is simple. Each program can use any number of shared libraries, and there's simply no way to know in advance where any given shared library will be loaded in the process's virtual memory. Many solutions were invented for this problem over the years, but in this article I will just focus on the ones currently used by Linux.</p>
<p nodeIndex="30">But first, let's briefly examine the problem. Here's some sample C code <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id17" id="id4" nodeIndex="211">[4]</a> which I compile into a shared library:</p>
<div class="highlight" nodeIndex="31">
<pre nodeIndex="32">
<span nodeIndex="212">int</span> myglob = <span nodeIndex="213">42</span>;

<span nodeIndex="214">int</span> <span nodeIndex="215">ml_func</span>(<span nodeIndex="216">int</span> a, <span nodeIndex="217">int</span> b)
{
    myglob += a;
    <span nodeIndex="218">return</span> b + myglob;
}
</pre></div>
<p nodeIndex="33">Note how <tt class="docutils literal" nodeIndex="219">ml_func</tt> references <tt class="docutils literal" nodeIndex="220">myglob</tt> a few times. When translated to x86 assembly, this will involve a <tt class="docutils literal" nodeIndex="221">mov</tt> instruction to pull the value of <tt class="docutils literal" nodeIndex="222">myglob</tt> from its location in memory into a register. <tt class="docutils literal" nodeIndex="223">mov</tt> requires an absolute address - so how does the linker know which address to place in it? The answer is - it doesn't. As I mentioned above, shared libraries have no pre-defined load address - it will be decided at runtime.</p>
<p nodeIndex="34">In Linux, the <em nodeIndex="224">dynamic loader</em> <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id18" id="id5" nodeIndex="225">[5]</a> is a piece of code responsible for preparing programs for running. One of its tasks is to load shared libraries from disk into memory, when the running executable requests them. When a shared library is loaded into memory, it is then adjusted for its newly determined load location. It is the job of the dynamic loader to solve the problem presented in the previous paragraph.</p>
<p nodeIndex="35">There are two main approaches to solve this problem in Linux ELF shared libraries:</p>
<ol class="arabic simple" nodeIndex="37"><li nodeIndex="36">Load-time relocation</li>
<li nodeIndex="38">Position independent code (PIC)</li>
</ol><p nodeIndex="39">Although PIC is the more common and nowadays-recommended solution, in this article I will focus on load-time relocation. Eventually I plan to cover both approaches and write a separate article on PIC, and I think starting with load-time relocation will make PIC easier to explain later. (<em nodeIndex="226">Update 03.11.2011</em>: <a class="reference external" href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" nodeIndex="227">the article about PIC</a> was published)</p>
</div>
<div class="section" id="linking-the-shared-library-for-load-time-relocation" nodeIndex="40">
<h3 nodeIndex="41">Linking the shared library for load-time relocation</h3>
<p nodeIndex="42">To create a shared library that has to be relocated at load-time, I'll compile it without the <tt class="docutils literal" nodeIndex="228"><span class="pre" nodeIndex="229">-fPIC</span></tt> flag (which would otherwise trigger PIC generation):</p>
<div class="highlight" nodeIndex="43">
<pre nodeIndex="44">
gcc -g -c ml_main.c -o ml_mainreloc.o
gcc -shared -o libmlreloc.so ml_mainreloc.o
</pre></div>
<p nodeIndex="45">The first interesting thing to see is the entry point of <tt class="docutils literal" nodeIndex="230">libmlreloc.so</tt>:</p>

<p nodeIndex="48">For simplicity, the linker just links the shared object for address <tt class="docutils literal" nodeIndex="231">0x0</tt> (the <tt class="docutils literal" nodeIndex="232">.text</tt> section starting at <tt class="docutils literal" nodeIndex="233">0x3b0</tt>), knowing that the loader will move it anyway. Keep this fact in mind - it will be useful later in the article.</p>
<p nodeIndex="49">Now let's look at the disassembly of the shared library, focusing on <tt class="docutils literal" nodeIndex="234">ml_func</tt>:</p>
<div class="highlight" nodeIndex="50">
<pre nodeIndex="51">
$ objdump -d -Mintel libmlreloc.so

libmlreloc.so:     file format elf32-i386

[...] skipping stuff

0000046c <ml_func>:
 46c: 55                      push   ebp
 46d: 89 e5                   mov    ebp,esp
 46f: a1 00 00 00 00          mov    eax,ds:0x0
 474: 03 45 08                add    eax,DWORD PTR [ebp+0x8]
 477: a3 00 00 00 00          mov    ds:0x0,eax
 47c: a1 00 00 00 00          mov    eax,ds:0x0
 481: 03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 484: 5d                      pop    ebp
 485: c3                      ret

[...] skipping stuff
</pre></div>
<p nodeIndex="52">After the first two instructions which are part of the prologue <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id19" id="id6" nodeIndex="235">[6]</a>, we see the compiled version of <tt class="docutils literal" nodeIndex="236">myglob += a</tt> <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id20" id="id7" nodeIndex="237">[7]</a>. The value of <tt class="docutils literal" nodeIndex="238">myglob</tt> is taken from memory into <tt class="docutils literal" nodeIndex="239">eax</tt>, incremented by <tt class="docutils literal" nodeIndex="240">a</tt> (which is at <tt class="docutils literal" nodeIndex="241">ebp+0x8</tt>) and then placed back into memory.</p>
<p nodeIndex="53">But wait, the <tt class="docutils literal" nodeIndex="242">mov</tt> takes <tt class="docutils literal" nodeIndex="243">myglob</tt>? Why? It appears that the actual operand of <tt class="docutils literal" nodeIndex="244">mov</tt> is just <tt class="docutils literal" nodeIndex="245">0x0</tt> <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id21" id="id8" nodeIndex="246">[8]</a>. What gives? This is how relocations work. The linker places some provisional pre-defined value (<tt class="docutils literal" nodeIndex="247">0x0</tt> in this case) into the instruction stream, and then creates a special relocation entry pointing to this place. Let's examine the relocation entries for this shared library:</p>
<div class="highlight" nodeIndex="54">
<pre nodeIndex="55">
$ readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x2fc contains 7 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002008  00000008 R_386_RELATIVE
00000470  00000401 R_386_32          0000200C   myglob
00000478  00000401 R_386_32          0000200C   myglob
0000047d  00000401 R_386_32          0000200C   myglob
[...] skipping stuff
</pre></div>
<p nodeIndex="56">The <tt class="docutils literal" nodeIndex="248">rel.dyn</tt> section of ELF is reserved for dynamic (load-time) relocations, to be consumed by the dynamic loader. There are 3 relocation entries for <tt class="docutils literal" nodeIndex="249">myglob</tt> in the section showed above, since there are 3 references to <tt class="docutils literal" nodeIndex="250">myglob</tt> in the disassembly. Let's decipher the first one.</p>
<p nodeIndex="57">It says: go to offset 0x470 in this object (shared library), and apply relocation of type <tt class="docutils literal" nodeIndex="251">R_386_32</tt> to it for symbol <tt class="docutils literal" nodeIndex="252">myglob</tt>. If we consult the ELF spec we see that relocation type <tt class="docutils literal" nodeIndex="253">R_386_32</tt> means: take the value at the offset specified in the entry, add the address of the symbol to it, and place it back into the offset.</p>
<p nodeIndex="58">What do we have at offset <tt class="docutils literal" nodeIndex="254">0x470</tt> in the object? Recall this instruction from the disassembly of <tt class="docutils literal" nodeIndex="255">ml_func</tt>:</p>
<div class="highlight" nodeIndex="59">
<pre nodeIndex="60">
46f:  a1 00 00 00 00          mov    eax,ds:0x0
</pre></div>
<p nodeIndex="61"><tt class="docutils literal" nodeIndex="256">a1</tt> encodes the <tt class="docutils literal" nodeIndex="257">mov</tt> instruction, so its operand starts at the next address which is <tt class="docutils literal" nodeIndex="258">0x470</tt>. This is the <tt class="docutils literal" nodeIndex="259">0x0</tt> we see in the disassembly. So back to the relocation entry, we now see it says: add the address of <tt class="docutils literal" nodeIndex="260">myglob</tt> to the operand of that <tt class="docutils literal" nodeIndex="261">mov</tt> instruction. In other words it tells the dynamic loader - once you perform actual address assignment, put the real address of <tt class="docutils literal" nodeIndex="262">myglob</tt> into <tt class="docutils literal" nodeIndex="263">0x470</tt>, thus replacing the operand of <tt class="docutils literal" nodeIndex="264">mov</tt> by the correct symbol value. Neat, huh?</p>
<p nodeIndex="62">Note also the "Sym. value" column in the relocation section, which contains <tt class="docutils literal" nodeIndex="265">0x200C</tt> for <tt class="docutils literal" nodeIndex="266">myglob</tt>. This is the offset of <tt class="docutils literal" nodeIndex="267">myglob</tt> in the virtual memory image of the shared library (which, recall, the linker assumes is just loaded at <tt class="docutils literal" nodeIndex="268">0x0</tt>). This value can also be examined by looking at the symbol table of the library, for example with <tt class="docutils literal" nodeIndex="269">nm</tt>:</p>
<div class="highlight" nodeIndex="63">
<pre nodeIndex="64">
$ nm libmlreloc.so
[...] skipping stuff
0000200c D myglob
</pre></div>
<p nodeIndex="65">This output also provides the offset of <tt class="docutils literal" nodeIndex="270">myglob</tt> inside the library. <tt class="docutils literal" nodeIndex="271">D</tt> means the symbol is in the initialized data section (<tt class="docutils literal" nodeIndex="272">.data</tt>).</p>
</div>
<div class="section" id="load-time-relocation-in-action" nodeIndex="66">
<h3 nodeIndex="67">Load-time relocation in action</h3>
<p nodeIndex="68">To see the load-time relocation in action, I will use our shared library from a simple driver executable. When running this executable, the OS will load the shared library and relocate it appropriately.</p>
<p nodeIndex="69">Curiously, due to the <a class="reference external" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" nodeIndex="273">address space layout randomization feature</a> which is enabled in Linux, relocation is relatively difficult to follow, because every time I run the executable, the <tt class="docutils literal" nodeIndex="274">libmlreloc.so</tt> shared library gets placed in a different virtual memory address <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id22" id="id9" nodeIndex="275">[9]</a>.</p>
<p nodeIndex="70">This is a rather weak deterrent, however. There is a way to make sense in it all. But first, let's talk about the segments our shared library consists of:</p>
<div class="highlight" nodeIndex="71">
<pre nodeIndex="72">
$ readelf --segments libmlreloc.so

Elf file type is DYN (Shared object file)
Entry point 0x3b0
There are 6 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00000000 0x00000000 0x004e8 0x004e8 R E 0x1000
  LOAD           0x000f04 0x00001f04 0x00001f04 0x0010c 0x00114 RW  0x1000
  DYNAMIC        0x000f18 0x00001f18 0x00001f18 0x000d0 0x000d0 RW  0x4
  NOTE           0x0000f4 0x000000f4 0x000000f4 0x00024 0x00024 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x000f04 0x00001f04 0x00001f04 0x000fc 0x000fc R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .eh_frame
   01     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   02     .dynamic
   03     .note.gnu.build-id
   04
   05     .ctors .dtors .jcr .dynamic .got
</pre></div>
<p nodeIndex="73">To follow the <tt class="docutils literal" nodeIndex="276">myglob</tt> symbol, we're interested in the second segment listed here. Note a couple of things:</p>
<ul class="simple" nodeIndex="75"><li nodeIndex="74">In the section to segment mapping in the bottom, segment 01 is said to contain the <tt class="docutils literal" nodeIndex="277">.data</tt> section, which is the home of <tt class="docutils literal" nodeIndex="278">myglob</tt></li>
<li nodeIndex="76">The <tt class="docutils literal" nodeIndex="279">VirtAddr</tt> column specifies that the second segment starts at <tt class="docutils literal" nodeIndex="280">0x1f04</tt> and has size <tt class="docutils literal" nodeIndex="281">0x10c</tt>, meaning that it extends until <tt class="docutils literal" nodeIndex="282">0x2010</tt> and thus contains <tt class="docutils literal" nodeIndex="283">myglob</tt> which is at <tt class="docutils literal" nodeIndex="284">0x200C</tt>.</li>
</ul><p nodeIndex="77">Now let's use a nice tool Linux gives us to examine the load-time linking process - the <a class="reference external" href="http://linux.die.net/man/3/dl_iterate_phdr" nodeIndex="285">dl_iterate_phdr function</a>, which allows an application to inquire at runtime which shared libraries it has loaded, and more importantly - take a peek at their program headers.</p>
<p nodeIndex="78">So I'm going to write the following code into <tt class="docutils literal" nodeIndex="286">driver.c</tt>:</p>
<div class="highlight" nodeIndex="79">
<pre nodeIndex="80">
<span nodeIndex="287">#define _GNU_SOURCE</span>
<span nodeIndex="288">#include <link.h></span>
<span nodeIndex="289">#include <stdlib.h></span>
<span nodeIndex="290">#include <stdio.h></span>


<span nodeIndex="291">static</span> <span nodeIndex="292">int</span> <span nodeIndex="293">header_handler</span>(<span nodeIndex="294">struct</span> dl_phdr_info* info, <span nodeIndex="295">size_t</span> size, <span nodeIndex="296">void</span>* data)
{
    printf(<span nodeIndex="297">"name=%s (%d segments) address=%p\n"</span>,
            info->dlpi_name, info->dlpi_phnum, (<span nodeIndex="298">void</span>*)info->dlpi_addr);
    <span nodeIndex="299">for</span> (<span nodeIndex="300">int</span> j = <span nodeIndex="301">0</span>; j < info->dlpi_phnum; j++) {
         printf(<span nodeIndex="302">"\t\t header %2d: address=%10p\n"</span>, j,
             (<span nodeIndex="303">void</span>*) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr));
         printf(<span nodeIndex="304">"\t\t\t type=%u, flags=0x%X\n"</span>,
                 info->dlpi_phdr[j].p_type, info->dlpi_phdr[j].p_flags);
    }
    printf(<span nodeIndex="305">"\n"</span>);
    <span nodeIndex="306">return</span> <span nodeIndex="307">0</span>;
}


<span nodeIndex="308">extern</span> <span nodeIndex="309">int</span> ml_func(<span nodeIndex="310">int</span>, <span nodeIndex="311">int</span>);


<span nodeIndex="312">int</span> <span nodeIndex="313">main</span>(<span nodeIndex="314">int</span> argc, <span nodeIndex="315">const</span> <span nodeIndex="316">char</span>* argv[])
{
    dl_iterate_phdr(header_handler, <span nodeIndex="317">NULL</span>);

    <span nodeIndex="318">int</span> t = ml_func(argc, argc);
    <span nodeIndex="319">return</span> t;
}
</pre></div>
<p nodeIndex="81"><tt class="docutils literal" nodeIndex="320">header_handler</tt> implements the callback for <tt class="docutils literal" nodeIndex="321">dl_iterate_phdr</tt>. It will get called for all libraries and report their names and load addresses, along with all their segments. It also invokes <tt class="docutils literal" nodeIndex="322">ml_func</tt>, which is taken from the <tt class="docutils literal" nodeIndex="323">libmlreloc.so</tt> shared library.</p>
<p nodeIndex="82">To compile and link this driver with our shared library, run:</p>
<div class="highlight" nodeIndex="83">
<pre nodeIndex="84">
gcc -g -c driver.c -o driver.o
gcc -o driver driver.o -L. -lmlreloc
</pre></div>
<p nodeIndex="85">Running the driver stand-alone we get the information, but for each run the addresses are different. So what I'm going to do is run it under <tt class="docutils literal" nodeIndex="324">gdb</tt> <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id23" id="id10" nodeIndex="325">[10]</a>, see what it says, and then use <tt class="docutils literal" nodeIndex="326">gdb</tt> to further query the process's memory space:</p>
<div class="highlight" nodeIndex="86">
<pre nodeIndex="87">
 $ gdb -q driver
 Reading symbols from driver...done.
 (gdb) b driver.c:31
 Breakpoint 1 at 0x804869e: file driver.c, line 31.
 (gdb) r
 Starting program: driver
 [...] skipping output
 name=./libmlreloc.so (6 segments) address=0x12e000
                header  0: address=  0x12e000
                        type=1, flags=0x5
                header  1: address=  0x12ff04
                        type=1, flags=0x6
                header  2: address=  0x12ff18
                        type=2, flags=0x6
                header  3: address=  0x12e0f4
                        type=4, flags=0x4
                header  4: address=  0x12e000
                        type=1685382481, flags=0x6
                header  5: address=  0x12ff04
                        type=1685382482, flags=0x4

[...] skipping output
 Breakpoint 1, main (argc=1, argv=0xbffff3d4) at driver.c:31
 31    }
 (gdb)
</pre></div>
<p nodeIndex="88">Since <tt class="docutils literal" nodeIndex="327">driver</tt> reports all the libraries it loads (even implicitly, like <tt class="docutils literal" nodeIndex="328">libc</tt> or the dynamic loader itself), the output is lengthy and I will just focus on the report about <tt class="docutils literal" nodeIndex="329">libmlreloc.so</tt>. Note that the 6 segments are the same segments reported by <tt class="docutils literal" nodeIndex="330">readelf</tt>, but this time relocated into their final memory locations.</p>
<p nodeIndex="89">Let's do some math. The output says <tt class="docutils literal" nodeIndex="331">libmlreloc.so</tt> was placed in virtual address <tt class="docutils literal" nodeIndex="332">0x12e000</tt>. We're interested in the second segment, which as we've seen in <tt class="docutils literal" nodeIndex="333">readelf</tt> is at ofset <tt class="docutils literal" nodeIndex="334">0x1f04</tt>. Indeed, we see in the output it was loaded to address <tt class="docutils literal" nodeIndex="335">0x12ff04</tt>. And since <tt class="docutils literal" nodeIndex="336">myglob</tt> is at offset <tt class="docutils literal" nodeIndex="337">0x200c</tt> in the file, we'd expect it to now be at address <tt class="docutils literal" nodeIndex="338">0x13000c</tt>.</p>
<p nodeIndex="90">So, let's ask GDB:</p>
<div class="highlight" nodeIndex="91">
<pre nodeIndex="92">
(gdb) p &myglob
$1 = (int *) 0x13000c
</pre></div>
<p nodeIndex="93">Excellent! But what about the code of <tt class="docutils literal" nodeIndex="339">ml_func</tt> which refers to <tt class="docutils literal" nodeIndex="340">myglob</tt>? Let's ask GDB again:</p>
<div class="highlight" nodeIndex="94">
<pre nodeIndex="95">
(gdb) set disassembly-flavor intel
(gdb) disas ml_func
Dump of assembler code for function ml_func:
   0x0012e46c <+0>:   push   ebp
   0x0012e46d <+1>:   mov    ebp,esp
   0x0012e46f <+3>:   mov    eax,ds:0x13000c
   0x0012e474 <+8>:   add    eax,DWORD PTR [ebp+0x8]
   0x0012e477 <+11>:  mov    ds:0x13000c,eax
   0x0012e47c <+16>:  mov    eax,ds:0x13000c
   0x0012e481 <+21>:  add    eax,DWORD PTR [ebp+0xc]
   0x0012e484 <+24>:  pop    ebp
   0x0012e485 <+25>:  ret
End of assembler dump.
</pre></div>
<p nodeIndex="96">As expected, the real address of <tt class="docutils literal" nodeIndex="341">myglob</tt> was placed in all the <tt class="docutils literal" nodeIndex="342">mov</tt> instructions referring to it, just as the relocation entries specified.</p>
</div>
<div class="section" id="relocating-function-calls" nodeIndex="97">
<h3 nodeIndex="98">Relocating function calls</h3>
<p nodeIndex="99">So far this article demonstrated relocation of data references - using the global variable <tt class="docutils literal" nodeIndex="343">myglob</tt> as an example. Another thing that needs to be relocated is code references - in other words, function calls. This section is a brief guide on how this gets done. The pace is much faster than in the rest of this article, since I can now assume the reader understands what relocation is all about.</p>
<p nodeIndex="100">Without further ado, let's get to it. I've modified the code of the shared library to be the following:</p>
<div class="highlight" nodeIndex="101">
<pre nodeIndex="102">
<span nodeIndex="344">int</span> myglob = <span nodeIndex="345">42</span>;

<span nodeIndex="346">int</span> <span nodeIndex="347">ml_util_func</span>(<span nodeIndex="348">int</span> a)
{
    <span nodeIndex="349">return</span> a + <span nodeIndex="350">1</span>;
}

<span nodeIndex="351">int</span> <span nodeIndex="352">ml_func</span>(<span nodeIndex="353">int</span> a, <span nodeIndex="354">int</span> b)
{
    <span nodeIndex="355">int</span> c = b + ml_util_func(a);
    myglob += c;
    <span nodeIndex="356">return</span> b + myglob;
}
</pre></div>
<p nodeIndex="103"><tt class="docutils literal" nodeIndex="357">ml_util_func</tt> was added and it's being used by <tt class="docutils literal" nodeIndex="358">ml_func</tt>. Here's the disassembly of <tt class="docutils literal" nodeIndex="359">ml_func</tt> in the linked shared library:</p>
<div class="highlight" nodeIndex="104">
<pre nodeIndex="105">
000004a7 <ml_func>:
 4a7:   55                      push   ebp
 4a8:   89 e5                   mov    ebp,esp
 4aa:   83 ec 14                sub    esp,0x14
 4ad:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 4b0:   89 04 24                mov    DWORD PTR [esp],eax
 4b3:   e8 fc ff ff ff          call   4b4 <ml_func+0xd>
 4b8:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 4bb:   89 45 fc                mov    DWORD PTR [ebp-0x4],eax
 4be:   a1 00 00 00 00          mov    eax,ds:0x0
 4c3:   03 45 fc                add    eax,DWORD PTR [ebp-0x4]
 4c6:   a3 00 00 00 00          mov    ds:0x0,eax
 4cb:   a1 00 00 00 00          mov    eax,ds:0x0
 4d0:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 4d3:   c9                      leave
 4d4:   c3                      ret
</pre></div>
<p nodeIndex="106">What's interesting here is the instruction at address <tt class="docutils literal" nodeIndex="360">0x4b3</tt> - it's the call to <tt class="docutils literal" nodeIndex="361">ml_util_func</tt>. Let's dissect it:</p>
<p nodeIndex="107"><tt class="docutils literal" nodeIndex="362">e8</tt> is the opcode for <tt class="docutils literal" nodeIndex="363">call</tt>. The argument of this <tt class="docutils literal" nodeIndex="364">call</tt> is the offset relative to the next instruction. In the disassembly above, this argument is <tt class="docutils literal" nodeIndex="365">0xfffffffc</tt>, or simply <tt class="docutils literal" nodeIndex="366"><span class="pre" nodeIndex="367">-4</span></tt>. So the <tt class="docutils literal" nodeIndex="368">call</tt> currently points to itself. This clearly isn't right - but let's not forget about relocation. Here's what the relocation section of the shared library looks like now:</p>
<div class="highlight" nodeIndex="108">
<pre nodeIndex="109">
$ readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x324 contains 8 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002008  00000008 R_386_RELATIVE
000004b4  00000502 R_386_PC32        0000049c   ml_util_func
000004bf  00000401 R_386_32          0000200c   myglob
000004c7  00000401 R_386_32          0000200c   myglob
000004cc  00000401 R_386_32          0000200c   myglob
[...] skipping stuff
</pre></div>
<p nodeIndex="110">If we compare it to the previous invocation of <tt class="docutils literal" nodeIndex="369">readelf <span class="pre" nodeIndex="370">-r</span></tt>, we'll notice a new entry added for <tt class="docutils literal" nodeIndex="371">ml_util_func</tt>. This entry points at address <tt class="docutils literal" nodeIndex="372">0x4b4</tt> which is the argument of the <tt class="docutils literal" nodeIndex="373">call</tt> instruction, and its type is <tt class="docutils literal" nodeIndex="374">R_386_PC32</tt>. This relocation type is more complicated than <tt class="docutils literal" nodeIndex="375">R_386_32</tt>, but not by much.</p>
<p nodeIndex="111">It means the following: take the value at the offset specified in the entry, add the address of the symbol to it, subtract the address of the offset itself, and place it back into the word at the offset. Recall that this relocation is done at <em nodeIndex="376">load-time</em>, when the final load addresses of the symbol and the relocated offset itself are already known. These final addresses participate in the computation.</p>
<p nodeIndex="112">What does this do? Basically, it's a <em nodeIndex="377">relative</em> relocation, taking its location into account and thus suitable for arguments of instructions with relative addressing (which the <tt class="docutils literal" nodeIndex="378">e8 call</tt> is). I promise it will become clearer once we get to the real numbers.</p>
<p nodeIndex="113">I'm now going to build the driver code and run it under GDB again, to see this relocation in action. Here's the GDB session, followed by explanations:</p>
<div class="highlight" nodeIndex="114">
<pre nodeIndex="115">
 $ gdb -q driver
 Reading symbols from driver...done.
 (gdb) b driver.c:31
 Breakpoint 1 at 0x804869e: file driver.c, line 31.
 (gdb) r
 Starting program: driver
 [...] skipping output
 name=./libmlreloc.so (6 segments) address=0x12e000
               header  0: address=  0x12e000
                       type=1, flags=0x5
               header  1: address=  0x12ff04
                       type=1, flags=0x6
               header  2: address=  0x12ff18
                       type=2, flags=0x6
               header  3: address=  0x12e0f4
                       type=4, flags=0x4
               header  4: address=  0x12e000
                       type=1685382481, flags=0x6
               header  5: address=  0x12ff04
                       type=1685382482, flags=0x4

[...] skipping output
Breakpoint 1, main (argc=1, argv=0xbffff3d4) at driver.c:31
31    }
(gdb)  set disassembly-flavor intel
(gdb) disas ml_util_func
Dump of assembler code for function ml_util_func:
   0x0012e49c <+0>:   push   ebp
   0x0012e49d <+1>:   mov    ebp,esp
   0x0012e49f <+3>:   mov    eax,DWORD PTR [ebp+0x8]
   0x0012e4a2 <+6>:   add    eax,0x1
   0x0012e4a5 <+9>:   pop    ebp
   0x0012e4a6 <+10>:  ret
End of assembler dump.
(gdb) disas /r ml_func
Dump of assembler code for function ml_func:
   0x0012e4a7 <+0>:    55     push   ebp
   0x0012e4a8 <+1>:    89 e5  mov    ebp,esp
   0x0012e4aa <+3>:    83 ec 14       sub    esp,0x14
   0x0012e4ad <+6>:    8b 45 08       mov    eax,DWORD PTR [ebp+0x8]
   0x0012e4b0 <+9>:    89 04 24       mov    DWORD PTR [esp],eax
   0x0012e4b3 <+12>:   e8 e4 ff ff ff call   0x12e49c <ml_util_func>
   0x0012e4b8 <+17>:   03 45 0c       add    eax,DWORD PTR [ebp+0xc]
   0x0012e4bb <+20>:   89 45 fc       mov    DWORD PTR [ebp-0x4],eax
   0x0012e4be <+23>:   a1 0c 00 13 00 mov    eax,ds:0x13000c
   0x0012e4c3 <+28>:   03 45 fc       add    eax,DWORD PTR [ebp-0x4]
   0x0012e4c6 <+31>:   a3 0c 00 13 00 mov    ds:0x13000c,eax
   0x0012e4cb <+36>:   a1 0c 00 13 00 mov    eax,ds:0x13000c
   0x0012e4d0 <+41>:   03 45 0c       add    eax,DWORD PTR [ebp+0xc]
   0x0012e4d3 <+44>:   c9     leave
   0x0012e4d4 <+45>:   c3     ret
End of assembler dump.
(gdb)
</pre></div>
<p nodeIndex="116">The important parts here are:</p>
<ol class="arabic simple" nodeIndex="118"><li nodeIndex="117">In the printout from <tt class="docutils literal" nodeIndex="379">driver</tt> we see that the first segment (the code segment) of <tt class="docutils literal" nodeIndex="380">libmlreloc.so</tt> has been mapped to <tt class="docutils literal" nodeIndex="381">0x12e000</tt> <a class="footnote-reference" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id24" id="id11" nodeIndex="382">[11]</a></li>
<li nodeIndex="119"><tt class="docutils literal" nodeIndex="383">ml_util_func</tt> was loaded to address <tt class="docutils literal" nodeIndex="384">0x0012e49c</tt></li>
<li nodeIndex="120">The address of the relocated offset is <tt class="docutils literal" nodeIndex="385">0x0012e4b4</tt></li>
<li nodeIndex="121">The call in <tt class="docutils literal" nodeIndex="386">ml_func</tt> to <tt class="docutils literal" nodeIndex="387">ml_util_func</tt> was patched to place <tt class="docutils literal" nodeIndex="388">0xffffffe4</tt> in the argument (I disassembled <tt class="docutils literal" nodeIndex="389">ml_func</tt> with the <tt class="docutils literal" nodeIndex="390">/r</tt> flag to show raw hex in addition to disassembly), which is interpreted as the correct offset to <tt class="docutils literal" nodeIndex="391">ml_util_func</tt>.</li>
</ol><p nodeIndex="122">Obviously we're most interested in how (4) was done. Again, it's time for some math. Interpreting the <tt class="docutils literal" nodeIndex="392">R_386_PC32</tt> relocation entry mentioned above, we have:</p>
<p nodeIndex="123">Take the value at the offset specified in the entry (<tt class="docutils literal" nodeIndex="393">0xfffffffc</tt>), add the address of the symbol to it (<tt class="docutils literal" nodeIndex="394">0x0012e49c</tt>), subtract the address of the offset itself (<tt class="docutils literal" nodeIndex="395">0x0012e4b4</tt>), and place it back into the word at the offset. Everything is done assuming 32-bit 2-s complement, of course. The result is <tt class="docutils literal" nodeIndex="396">0xffffffe4</tt>, as expected.</p>
</div>

<div class="section" id="extra-credit-2-referencing-shared-library-data-from-the-executable" nodeIndex="132" rilp="1">
<h3 nodeIndex="133">Extra credit #2: Referencing shared library data from the executable</h3>
<p nodeIndex="134">Again, this is a bonus section that discusses an advanced topic. It can be skipped safely if you're tired of this stuff.</p>
<p nodeIndex="135">In the example above, <tt class="docutils literal" nodeIndex="397">myglob</tt> was only used internally in the shared library. What happens if we reference it from the program (<tt class="docutils literal" nodeIndex="398">driver.c</tt>)? After all, <tt class="docutils literal" nodeIndex="399">myglob</tt> is a global variable and thus visible externally.</p>
<p nodeIndex="136">Let's modify <tt class="docutils literal" nodeIndex="400">driver.c</tt> to the following (note I've removed the segment iteration code):</p>
<div class="highlight" nodeIndex="137">
<pre nodeIndex="138">
<span nodeIndex="401">#include <stdio.h></span>

<span nodeIndex="402">extern</span> <span nodeIndex="403">int</span> ml_func(<span nodeIndex="404">int</span>, <span nodeIndex="405">int</span>);
<span nodeIndex="406">extern</span> <span nodeIndex="407">int</span> myglob;

<span nodeIndex="408">int</span> <span nodeIndex="409">main</span>(<span nodeIndex="410">int</span> argc, <span nodeIndex="411">const</span> <span nodeIndex="412">char</span>* argv[])
{
    printf(<span nodeIndex="413">"addr myglob = %p\n"</span>, (<span nodeIndex="414">void</span>*)&myglob);
    <span nodeIndex="415">int</span> t = ml_func(argc, argc);
    <span nodeIndex="416">return</span> t;
}
</pre></div>
<p nodeIndex="139">It now prints the address of <tt class="docutils literal" nodeIndex="417">myglob</tt>. The output is:</p>
<div class="highlight" nodeIndex="140">
<pre nodeIndex="141">
addr myglob = 0x804a018
</pre></div>
<p nodeIndex="142">Wait, something doesn't compute here. Isn't <tt class="docutils literal" nodeIndex="418">myglob</tt> in the shared library's address space? <tt class="docutils literal" nodeIndex="419">0x804xxxx</tt> looks like the program's address space. What's going on?</p>
<p nodeIndex="143">Recall that the program/executable is not relocatable, and thus its data addresses have to bound at link time. Therefore, the linker has to create a copy of the variable in the program's address space, and the dynamic loader will use <em nodeIndex="420">that</em> as the relocation address. This is similar to the discussion in the previous section - in a sense, <tt class="docutils literal" nodeIndex="421">myglob</tt> in the main program overrides the one in the shared library, and according to the global symbol lookup rules, it's being used instead. If we examine <tt class="docutils literal" nodeIndex="422">ml_func</tt> in GDB, we'll see the correct reference made to <tt class="docutils literal" nodeIndex="423">myglob</tt>:</p>
<div class="highlight" nodeIndex="144">
<pre nodeIndex="145">
0x0012e48e <+23>:      a1 18 a0 04 08 mov    eax,ds:0x804a018
</pre></div>
<p nodeIndex="146">This makes sense because a <tt class="docutils literal" nodeIndex="424">R_386_32</tt> relocation for <tt class="docutils literal" nodeIndex="425">myglob</tt> still exists in <tt class="docutils literal" nodeIndex="426">libmlreloc.so</tt>, and the dynamic loader makes it point to the correct place where <tt class="docutils literal" nodeIndex="427">myglob</tt> now lives.</p>
<p nodeIndex="147">This is all great, but something is missing. <tt class="docutils literal" nodeIndex="428">myglob</tt> is initialized in the shared library (to 42) - how does this initialization value get to the address space of the program? It turns out there's a special relocation entry that the linker builds into the <em nodeIndex="429">program</em> (so far we've only been examining relocation entries in the shared library):</p>
<div class="highlight" nodeIndex="148">
<pre nodeIndex="149">
$ readelf -r driver

Relocation section '.rel.dyn' at offset 0x3c0 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__
0804a018  00000605 R_386_COPY        0804a018   myglob
[...] skipping stuff
</pre></div>
<p nodeIndex="150">Note the <tt class="docutils literal" nodeIndex="430">R_386_COPY</tt> relocation for <tt class="docutils literal" nodeIndex="431">myglob</tt>. It simply means: copy the value from the symbol's address into this offset. The dynamic loader performs this when it loads the shared library. How does it know how much to copy? The symbol table section contains the size of each symbol; for example the size for <tt class="docutils literal" nodeIndex="432">myglob</tt> in the <tt class="docutils literal" nodeIndex="433">.symtab</tt> section of <tt class="docutils literal" nodeIndex="434">libmlreloc.so</tt> is 4.</p>
<p nodeIndex="151">I think this is a pretty cool example that shows how the process of executable linking and loading is orchestrated together. The linker puts special instructions in the output for the dynamic loader to consume and execute.</p>
</div>
<div class="section" id="conclusion" nodeIndex="152">
<h3 nodeIndex="153">Conclusion</h3>
<p nodeIndex="154">Load-time relocation is one of the methods used in Linux (and other OSes) to resolve internal data and code references in shared libraries when loading them into memory. These days, position independent code (PIC) is a more popular approach, and some modern systems (such as x86-64) no longer support load-time relocation.</p>
<p nodeIndex="155">Still, I decided to write an article on load-time relocation for two reasons. First, load-time relocation has a couple of advantages over PIC on some systems, especially in terms of performance. Second, load-time relocation is IMHO simpler to understand without prior knowledge, which will make PIC easier to explain in the future. (<em nodeIndex="435">Update 03.11.2011</em>: <a class="reference external" href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" nodeIndex="436">the article about PIC</a> was published)</p>
<p nodeIndex="156">Regardless of the motivation, I hope this article has helped to shed some light on the magic going behind the scenes of linking and loading shared libraries in a modern OS.</p>
<div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2015-03-20-99827932/1"/></div><table class="docutils footnote ril_dataTable" frame="void" id="id15" rules="none" nodeIndex="443"><colgroup nodeIndex="444"><col class="label" nodeIndex="445"><col nodeIndex="446"></colgroup><tbody valign="top" nodeIndex="447"><tr nodeIndex="161"><td class="label" nodeIndex="160" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id2" nodeIndex="448">[2]</a></td>
<td nodeIndex="162"><em nodeIndex="449">Link-time relocation</em> happens in the process of combining multiple object files into an executable (or shared library). It involves quite a lot of relocations to resolve symbol references between the object files. Link-time relocation is a more complex topic than load-time relocation, and I won't cover it in this article.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id16" rules="none" nodeIndex="450"><colgroup nodeIndex="451"><col class="label" nodeIndex="452"><col nodeIndex="453"></colgroup><tbody valign="top" nodeIndex="454"><tr nodeIndex="164"><td class="label" nodeIndex="163" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id3">[3]</a></td>
<td nodeIndex="165">This can be made possible by compiling all your libraries into static libraries (with <tt class="docutils literal">ar</tt> combining object files instead <tt class="docutils literal">gcc <span class="pre">-shared</span></tt>), and providing the <tt class="docutils literal"><span class="pre">-static</span></tt> flag to <tt class="docutils literal">gcc</tt> when linking the executable - to avoid linkage with the shared version of <tt class="docutils literal">libc</tt>.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id17" rules="none" nodeIndex="455"><colgroup nodeIndex="456"><col class="label" nodeIndex="457"><col nodeIndex="458"></colgroup><tbody valign="top" nodeIndex="459"><tr nodeIndex="167"><td class="label" nodeIndex="166" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id4">[4]</a></td>
<td nodeIndex="168"><tt class="docutils literal">ml</tt> simply stands for "my library". Also, the code itself is absolutely non-sensical and only used for purposes of demonstration.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id18" rules="none" nodeIndex="460"><colgroup nodeIndex="461"><col class="label" nodeIndex="462"><col nodeIndex="463"></colgroup><tbody valign="top" nodeIndex="464"><tr nodeIndex="170"><td class="label" nodeIndex="169" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id5" nodeIndex="465">[5]</a></td>
<td nodeIndex="171">Also called "dynamic linker". It's a shared object itself (though it can also run as an executable), residing at <tt class="docutils literal" nodeIndex="466"><span class="pre" nodeIndex="467">/lib/ld-linux.so.2</span></tt> (the last number is the SO version and may be different).</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id19" rules="none" nodeIndex="468"><colgroup nodeIndex="469"><col class="label" nodeIndex="470"><col nodeIndex="471"></colgroup><tbody valign="top" nodeIndex="472"><tr nodeIndex="173"><td class="label" nodeIndex="172" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id6">[6]</a></td>
<td nodeIndex="174">If you're not familiar with how x86 structures its stack frames, this would be a good time to read <a class="reference external" href="http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">this article</a>.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id20" rules="none" nodeIndex="473"><colgroup nodeIndex="474"><col class="label" nodeIndex="475"><col nodeIndex="476"></colgroup><tbody valign="top" nodeIndex="477"><tr nodeIndex="176"><td class="label" nodeIndex="175" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id7" nodeIndex="478">[7]</a></td>
<td nodeIndex="177">You can provide the <tt class="docutils literal" nodeIndex="479"><span class="pre" nodeIndex="480">-l</span></tt> flag to <tt class="docutils literal" nodeIndex="481">objdump</tt> to add C source lines into the disassembly, making it clearer what gets compiled to what. I've omitted it here to make the output shorter.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id21" rules="none" nodeIndex="482"><colgroup nodeIndex="483"><col class="label" nodeIndex="484"><col nodeIndex="485"></colgroup><tbody valign="top" nodeIndex="486"><tr nodeIndex="179"><td class="label" nodeIndex="178" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id8">[8]</a></td>
<td nodeIndex="180">I'm looking at the left-hand side of the output of <tt class="docutils literal">objdump</tt>, where the raw memory bytes are. <tt class="docutils literal">a1 00 00 00 00</tt> means <tt class="docutils literal">mov</tt> to <tt class="docutils literal">eax</tt> with operand <tt class="docutils literal">0x0</tt>, which is interpreted by the disassembler as <tt class="docutils literal">ds:0x0</tt>.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id23" rules="none" nodeIndex="492"><colgroup nodeIndex="493"><col class="label" nodeIndex="494"><col nodeIndex="495"></colgroup><tbody valign="top" nodeIndex="496"><tr nodeIndex="185"><td class="label" nodeIndex="184" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id10">[10]</a></td>
<td nodeIndex="186">Experienced readers will probably note that I could ask GDB about <tt class="docutils literal">i shared</tt> to get the load-address of the shared library. However, <tt class="docutils literal">i shared</tt> only mentions the load location of the whole library (or, even more accurately, its entry point), and I was interested in the segments.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id24" rules="none" nodeIndex="497"><colgroup nodeIndex="498"><col class="label" nodeIndex="499"><col nodeIndex="500"></colgroup><tbody valign="top" nodeIndex="501"><tr nodeIndex="188"><td class="label" nodeIndex="187" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id11" nodeIndex="502">[11]</a></td>
<td nodeIndex="189">What, <tt class="docutils literal" nodeIndex="503">0x12e000</tt> again? Didn't I just talk about load-address randomization? It turns out the dynamic loader can be manipulated to turn this off, for purposes of debugging. This is exactly what GDB is doing.</td>
</tr></tbody></table><table class="docutils footnote ril_dataTable" frame="void" id="id25" rules="none" nodeIndex="504"><colgroup nodeIndex="505"><col class="label" nodeIndex="506"><col nodeIndex="507"></colgroup><tbody valign="top" nodeIndex="508"><tr nodeIndex="191"><td class="label" nodeIndex="190" childisonlyalink="1"><a class="fn-backref" href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id12">[12]</a></td>
<td nodeIndex="192">Unless it's passed the <tt class="docutils literal"><span class="pre">-Bsymbolic</span></tt> flag. Read all about it in the man page of <tt class="docutils literal">ld</tt>.</td>
</tr></tbody></table></div>
</div>