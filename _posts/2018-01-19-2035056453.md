---
layout: post
title: 通过POC来学习漏洞的原理
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s/ogFLjUpd2HU60raUxGNWhg

收藏时间：2018-01-19 04:48:21

<div  lang="zh">
            
                        <div id="img-content" nodeIndex="5">
                
                
                <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="10">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">xazlsec</span>
                            </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">只分享干货，不扯蛋不蹭热点，共同学习共同成长，一起踏上信息安全之路！</span>
                            </p>
                
                
                
                
                                                
                                                                
                
                <div class="rich_media_content " id="js_content" nodeIndex="12">
                    

                    

                    
                    
                    <section class="xmteditor" data-tools="新媒体管家" data-label="powered by xmt.cn" nodeIndex="161"></section><p cid="n0" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="13"><span class="md-line md-end-block md-focus" cid="n2" mdtype="line" nodeIndex="162"><span md-inline="plain" class="md-expand" nodeIndex="163">本文介绍的是 </span><span md-inline="code" spellcheck="false" nodeIndex="164"><code nodeIndex="165">easyFTPServer 1.7.0.2 ‘Http’ remote Buffer Overflow</code></span><span md-inline="plain" nodeIndex="166"> 的漏洞执行流程，通过已知的 POC 来推断程序的大概执行流程以及漏洞利用原理。</span></span></p><p cid="n3" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="14"><span class="md-line md-end-block" cid="n4" mdtype="line" nodeIndex="167"><span md-inline="plain" nodeIndex="168">Poc 和软件的下载地址:</span></span></p><blockquote cid="n5" mdtype="blockquote" nodeIndex="15"><p cid="n6" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="16"><span class="md-line md-end-block" cid="n7" mdtype="line" nodeIndex="169"><span md-inline="url" spellcheck="false" nodeIndex="170">https://pan.baidu.com/s/1dHjKFCX</span><span md-inline="plain" nodeIndex="171">  (提取码 5h7h )</span></span></p></blockquote><h3 cid="n8" mdtype="heading" class="md-end-block md-heading" nodeIndex="17"><span md-inline="plain" nodeIndex="172">0x01 了解 FTP</span></h3><p cid="n9" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="18"><span class="md-line md-end-block" cid="n10" mdtype="line" nodeIndex="173"><span md-inline="plain" nodeIndex="174">FTP 服务全称为文件传输协议服务，其工作模式采用 C/S 模式，用户想要通过 FTP 服务访问到共享的文件信息时，首先需要在自己的计算机系统上运行一个 FTP 客户端，这个客户端可以是一个 FTP 应用程序，也可以是操作系统自带的命令行程序，然后在 FTP 客户端中输入用户名和密码来登录 FTP 服务程序，成功登陆后，用户就可以获取远程计算机上共享的文件信息了。</span></span></p><p cid="n11" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="19"><span class="md-line md-end-block" cid="n12" mdtype="line" nodeIndex="175"><span md-inline="plain" nodeIndex="176">emmmm……，换句话说客户端连接远程FTP服务器需要以下几个步骤</span></span></p><p cid="n13" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="20"><span class="md-line md-end-block" cid="n14" mdtype="line" nodeIndex="177"><span md-inline="plain" nodeIndex="178">（1）建立 TCP 连接</span></span></p><p cid="n15" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="21"><span class="md-line md-end-block" cid="n16" mdtype="line" nodeIndex="179"><span md-inline="plain" nodeIndex="180">（2）客户端向 FTP 服务程序发送 USER 命令以标识用户自己的身份，然后服务程序要求客户端输入密码</span></span></p><p cid="n17" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="22"><span class="md-line md-end-block" cid="n18" mdtype="line" nodeIndex="181"><span md-inline="plain" nodeIndex="182">（3）客户端发送 PASS 命令，同时将用户密码发送给远程 FTP 服务程序</span></span></p><p cid="n19" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="23"><span class="md-line md-end-block" cid="n20" mdtype="line" nodeIndex="183"><span md-inline="plain" nodeIndex="184">（4）服务端判断并通过认证</span></span></p><p cid="n21" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="24"><span class="md-line md-end-block" cid="n22" mdtype="line" nodeIndex="185"><span md-inline="plain" nodeIndex="186">（5）客户端开始利用其它 FTP 协议进行文件操作</span></span></p><p cid="n23" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="25"><span class="md-line md-end-block" cid="n24" mdtype="line" nodeIndex="187"><span md-inline="plain" nodeIndex="188">（6）结束此次连接，用 QUIT 命令退出</span></span></p><h3 cid="n25" mdtype="heading" class="md-end-block md-heading" nodeIndex="26"><span md-inline="plain" nodeIndex="189">0x02 搭建实验环境</span></h3><p cid="n26" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="27"><span class="md-line md-end-block" cid="n27" mdtype="line" nodeIndex="190"><span md-inline="plain" nodeIndex="191">FTP 服务端: </span></span></p><blockquote cid="n28" mdtype="blockquote" nodeIndex="28"><p cid="n29" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="29"><span class="md-line md-end-block" cid="n30" mdtype="line" nodeIndex="192"><span md-inline="plain" nodeIndex="193">win xp sp3（我用的是吾爱破解论坛的虚拟机）</span></span></p></blockquote><p cid="n31" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="30"><span class="md-line md-end-block" cid="n32" mdtype="line" nodeIndex="194"><span md-inline="plain" nodeIndex="195">FTP 客户端:</span></span></p><blockquote cid="n33" mdtype="blockquote" nodeIndex="31"><p cid="n34" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="32"><span class="md-line md-end-block" cid="n35" mdtype="line" nodeIndex="196"><span md-inline="plain" nodeIndex="197">win 7 (要求 Python 环境)</span></span></p></blockquote><p cid="n36" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="33"><span class="md-line md-end-block" cid="n37" mdtype="line" nodeIndex="146"><span md-inline="plain" nodeIndex="198">把 </span><span md-inline="code" spellcheck="false" nodeIndex="199"><code nodeIndex="200">easyFTPServer 1.7.0.2</code></span><span md-inline="plain" nodeIndex="201"> 解压到 xp 上，点击运行，目录下会产生 3 个 XML 配置文件以及名为 anonymous 的文件夹，该程序默认情况下会设置一个名为 </span><span md-inline="code" spellcheck="false" nodeIndex="202"><code nodeIndex="203">anonymous</code></span><span md-inline="plain" nodeIndex="204"> 的初始用户，而 anonymous 文件夹就是该用户使用的文件目录。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/1"/></div></p><p cid="n40" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="35"><span class="md-line md-end-block" cid="n41" mdtype="line" nodeIndex="205"><span md-inline="plain" nodeIndex="206">好了，我们已经配置完服务端了。</span></span></p><p cid="n42" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="36"><span class="md-line md-end-block" cid="n43" mdtype="line" nodeIndex="207"><span md-inline="plain" nodeIndex="208">大家可能已经发现了，这个软件除了提供 21 端口的 FTP 服务之外，还提供了 8080 端口的服务，这个 8080 端口就是今天我讲解的重点，我们先访问一下 </span></span></p><blockquote cid="n44" mdtype="blockquote" nodeIndex="37"><p cid="n45" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="38"><span class="md-line md-end-block" cid="n46" mdtype="line" nodeIndex="209"><span md-inline="url" spellcheck="false" nodeIndex="210">http://192.168.1.106:8080</span></span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="39"><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/2"/></div></p><p cid="n49" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="40"><span class="md-line md-end-block" cid="n50" mdtype="line" nodeIndex="211"></span></p><p cid="n51" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="41"><span class="md-line md-end-block" cid="n52" mdtype="line" nodeIndex="212"><span md-inline="plain" nodeIndex="213">emmmm，输入 </span><span md-inline="code" spellcheck="false" nodeIndex="214"><code nodeIndex="215">anonymous，anonymous</code></span><span md-inline="plain" nodeIndex="216"> 之后界面如下</span></span><span class="md-line md-end-block" cid="n52" mdtype="line" nodeIndex="217"><span md-inline="plain" nodeIndex="218"></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="42"><div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/3"/></div></p><p cid="n55" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="43"><span class="md-line md-end-block" cid="n56" mdtype="line" nodeIndex="219"></span></p><p cid="n57" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="44"><span class="md-line md-end-block" cid="n58" mdtype="line" nodeIndex="220"><span md-inline="plain" nodeIndex="221">们就可以通过网页对 FTP 服务器上分享的文件进行下载其本质是把 FTP 分享的文件以 web 页面的方式给大家呈现了出来。</span></span></p><h3 cid="n59" mdtype="heading" class="md-end-block md-heading" nodeIndex="45"><span md-inline="plain" nodeIndex="222">0x03 poc 的简单介绍</span></h3><p cid="n60" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="46"><span class="md-line md-end-block" cid="n61" mdtype="line" nodeIndex="223"><span md-inline="plain" nodeIndex="224">本文我们不研究怎么写 poc，当然我会在最后给大家介绍一下 寻蛋（egghunter） 这种 exp 开发技术，我打算通过已经写好的 exp 来给大家反向讲解一下这个漏洞的成因及原理，个人认为这样更容易理解，具体怎么样要问各位看官了…… 我会在调试的时候把自己的思路给大家详细说明一下</span></span></p><p cid="n62" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="47"><span class="md-line md-end-block" cid="n63" mdtype="line" nodeIndex="225"><span md-inline="strong" class="" nodeIndex="226"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="227">exp 如下（Python2.7 版本）</strong></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="48"><div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/4"/></div></p><p cid="n65" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="49"><span class="md-line md-end-block" cid="n66" mdtype="line" nodeIndex="147"><span md-inline="plain" nodeIndex="228">我大概讲解一下这个 exp 的内容，本质是构造了一个 get 请求，给 path 参数一个超长的字符串里面有我们覆盖返回地址的跳板地址，而 </span><span md-inline="code" spellcheck="false" nodeIndex="229"><code nodeIndex="230">HOST</code></span><span md-inline="plain" nodeIndex="231"> 后面的字符串是我们构造的 shellcode，</span><span md-inline="code" spellcheck="false" nodeIndex="232"><code nodeIndex="233">Authorization</code></span><span md-inline="plain" nodeIndex="234"> 后接我们的用户名和密码。</span></span></p><p cid="n67" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="50"><span class="md-line md-end-block" cid="n68" mdtype="line" nodeIndex="235"><span md-inline="plain" nodeIndex="236">这样我们就可以简单的登录并把恶意的数据发送给 </span><span md-inline="code" spellcheck="false" nodeIndex="237"><code nodeIndex="238">192.168.1.106:8080</code></span><span md-inline="plain" nodeIndex="239"> 页面所在的服务端上。</span></span></p><p cid="n69" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="51"><span class="md-line md-end-block" cid="n70" mdtype="line" nodeIndex="240"><span md-inline="plain" nodeIndex="241">这里的 shellcode 是在 </span><span md-inline="code" spellcheck="false" nodeIndex="242"><code nodeIndex="243">win xp sp3</code></span><span md-inline="plain" nodeIndex="244"> 上弹出计算器，可以通过 metasploit 的 </span><span md-inline="code" spellcheck="false" nodeIndex="245"><code nodeIndex="246">msfvenom</code></span><span md-inline="plain" nodeIndex="247"> 模块进行生成，我就不演示了。</span></span></p><h3 cid="n71" mdtype="heading" class="md-end-block md-heading" nodeIndex="52"><span md-inline="plain" nodeIndex="248">0x04 执行 exp</span></h3><p cid="n72" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><span class="md-line md-end-block" cid="n73" mdtype="line" nodeIndex="249"><span md-inline="plain" nodeIndex="250">一切准备就绪，我们开始执行 exp</span></span></p><p cid="n74" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="54"><span class="md-line md-end-block" cid="n75" mdtype="line" nodeIndex="251"><span md-inline="plain" nodeIndex="252">首先，在 FTP 服务端上用 </span><span md-inline="code" spellcheck="false" nodeIndex="253"><code nodeIndex="254">OD</code></span><span md-inline="plain" nodeIndex="255"> 附加 </span><span md-inline="code" spellcheck="false" nodeIndex="256"><code nodeIndex="257">EasyFTP Server</code></span><span md-inline="plain" nodeIndex="258"> 这款软件，由于这个软件运行的时候有两个进程，我们附加它的FTP服务进程，也就是 </span><span md-inline="code" spellcheck="false" nodeIndex="259"><code nodeIndex="260">ftpbasicsvr</code></span><span md-inline="plain" nodeIndex="261"> 这个进程（这里尽量使用原版 OD ）</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55"><div id="RIL_IMG_5" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/5"/></div></p><p cid="n78" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="56"><span class="md-line md-end-block" cid="n79" mdtype="line" nodeIndex="262"><span md-inline="strong" class="" nodeIndex="263"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="264">点击附加</strong></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="57"><div id="RIL_IMG_6" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/6"/></div></p><p cid="n82" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="58"><span class="md-line md-end-block" cid="n83" mdtype="line" nodeIndex="265"><span md-inline="plain" nodeIndex="266">然后我们按 F9 让程序继续执行，即让服务端接着监听 8080 端口的请求。</span></span></p><p cid="n84" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="59"><span class="md-line md-end-block" cid="n85" mdtype="line" nodeIndex="267"><span md-inline="plain" nodeIndex="268">我们回到客户端，执行之前写好的 exp。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="60"><div id="RIL_IMG_7" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/7"/></div></p><p cid="n88" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="61"><span class="md-line md-end-block" cid="n89" mdtype="line" nodeIndex="269"><span md-inline="plain" nodeIndex="270">按下回车键，回到服务端看看发生了什么？</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="62"><div id="RIL_IMG_8" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/8"/></div></p><p cid="n92" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><span class="md-line md-end-block" cid="n93" mdtype="line" nodeIndex="271"><span md-inline="plain" nodeIndex="272">emmmmm…… </span></span><span class="md-line md-end-block" cid="n93" mdtype="line" nodeIndex="273"><span md-inline="plain" nodeIndex="274">计算器弹了出来，说明 exp 没有什么问题。</span></span></p><p cid="n94" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="64"><span class="md-line md-end-block" cid="n95" mdtype="line" nodeIndex="275"><span md-inline="plain" nodeIndex="276">那么问题来了，我想看 shellcode 的详细执行流程啊，而不是仅仅弹出一个计算器。</span></span></p><p cid="n96" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="65"><span class="md-line md-end-block" cid="n97" mdtype="line" nodeIndex="148"><span md-inline="plain" nodeIndex="277">接着我陷入了沉思：客户端和 FTP 服务端进行通信的时候，本质上是 socket 通信，只不过是端口变成了 8080 罢了，有发送就会有接收，我们在 </span><span md-inline="code" spellcheck="false" nodeIndex="278"><code nodeIndex="279">recv()</code></span><span md-inline="plain" nodeIndex="280"> 下断点不就可以截获从客户端发来的数据了吗？</span></span></p><p cid="n98" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="66"><span class="md-line md-end-block" cid="n99" mdtype="line" nodeIndex="281"><span md-inline="plain" nodeIndex="282">写过 </span><span md-inline="code" spellcheck="false" nodeIndex="283"><code nodeIndex="284">c/c++</code></span><span md-inline="plain" nodeIndex="285"> 的人都知道，socket 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="286"><code nodeIndex="287">recv()</code></span><span md-inline="plain" nodeIndex="288"> 函数是在 </span><span md-inline="code" spellcheck="false" nodeIndex="289"><code nodeIndex="290">WS2_32.dll</code></span><span md-inline="plain" nodeIndex="291"> 中的。</span></span></p><p cid="n100" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="67"><span class="md-line md-end-block" cid="n101" mdtype="line" nodeIndex="292"><span md-inline="plain" nodeIndex="293">在 OD 上直接下断 </span><span md-inline="code" spellcheck="false" nodeIndex="294"><code nodeIndex="295">bp recv</code></span><span md-inline="plain" nodeIndex="296">，然后重启 FTP 服务器，重新附加进程，客户端重新连接，OD 的状态如下：</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="68"><div id="RIL_IMG_9" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/9"/></div></p><p cid="n104" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="69"><span class="md-line md-end-block" cid="n105" mdtype="line" nodeIndex="297"><span md-inline="plain" nodeIndex="298">emmmmm…… </span></span></p><p cid="n106" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="70"><span class="md-line md-end-block" cid="n107" mdtype="line" nodeIndex="149"><span md-inline="plain" nodeIndex="299">看来我们的想法是对的，程序断在了 </span><span md-inline="code" spellcheck="false" nodeIndex="300"><code nodeIndex="301">recv()</code></span><span md-inline="plain" nodeIndex="302"> 函数的入口，注意看堆栈窗口有一堆 </span><span md-inline="code" spellcheck="false" nodeIndex="303"><code nodeIndex="304">aaaaaaaaaaa</code></span><span md-inline="plain" nodeIndex="305">，那就是我们构造的 get 请求中 path 的参数，接下来我就要说明一下这个栈溢出漏洞的根本原因了，我们可以看到函数入口这样一条汇编</span></span></p><blockquote cid="n108" mdtype="blockquote" nodeIndex="71"><p cid="n109" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="72"><span class="md-line md-end-block" cid="n110" mdtype="line" nodeIndex="306"><span md-inline="plain" nodeIndex="307">sub esp 124</span></span></p></blockquote><p cid="n111" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="73"><span class="md-line md-end-block" cid="n112" mdtype="line" nodeIndex="308"><span md-inline="plain" nodeIndex="309">就是开辟了一个 292 字节的栈空间（124 是十六进制），get 请求中的 path 参数的值，也就是 exp 中 buf 的值，就存放在这个空间中。</span></span></p><p cid="n113" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="74"><span class="md-line md-end-block" cid="n114" mdtype="line" nodeIndex="310"><span md-inline="strong" class="" nodeIndex="311"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="312">而这个漏洞产生的原因就是没有对 path 参数的值，也就是 buf 的值进行长度的校验，以致于我们可以构造超长的字符串从而覆盖这个处理函数的返回地址进而对程序执行流程进行劫持。</strong></span></span></p><p cid="n115" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="75"><span class="md-line md-end-block" cid="n116" mdtype="line" nodeIndex="150"><span md-inline="plain" nodeIndex="313">具体怎么实现的，我们拉到这个处理函数的末尾，在平栈的时候下断也就是在 </span><span md-inline="code" spellcheck="false" nodeIndex="314"><code nodeIndex="315">0040b92D</code></span><span md-inline="plain" nodeIndex="316"> 处下断，按 F9 执行:</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="76"><div id="RIL_IMG_10" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/10"/></div></p><p cid="n119" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="77"><span class="md-line md-end-block" cid="n120" mdtype="line" nodeIndex="151"><span md-inline="plain" nodeIndex="317">此时要注意堆栈，有一堆 </span><span md-inline="code" spellcheck="false" nodeIndex="318"><code nodeIndex="319">6161616161</code></span><span md-inline="plain" nodeIndex="320"> , 而 61 正是 a 的十六进制表示，说明我们构造的超长字符串已经入栈，F8 单步执行到 </span><span md-inline="code" spellcheck="false" nodeIndex="321"><code nodeIndex="322">retn 8</code></span><span md-inline="plain" nodeIndex="323">，我们看到返回地址被覆盖成了跳板地址（这里的跳板地址是 </span><span md-inline="code" spellcheck="false" nodeIndex="324"><code nodeIndex="325">ntdll.dll</code></span><span md-inline="plain" nodeIndex="326"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="327"><code nodeIndex="328">jmp esp</code></span><span md-inline="plain" nodeIndex="329">，地址可以用 OD 插件或者 msf 的模块进行搜索）</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="78"><div id="RIL_IMG_11" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/11"/></div></p><p cid="n123" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="79"><span class="md-line md-end-block" cid="n124" mdtype="line" nodeIndex="152"><span md-inline="plain" nodeIndex="330">执行完 jmp esp 后，F8 向下执行，进入 寻蛋（egghunter） 部分（这里就可以解释一下 py 脚本中在跳板地址后面为什么有 8 个 </span><span md-inline="escape" nodeIndex="331">\</span><span md-inline="plain" nodeIndex="332">x63，因为 </span><span md-inline="code" spellcheck="false" nodeIndex="333"><code nodeIndex="334">retn 8</code></span><span md-inline="plain" nodeIndex="335"> 嘛，返回的时候跳过了 8 个字节）</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="80"><div id="RIL_IMG_12" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/12"/></div></p><p cid="n127" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="81"><span class="md-line md-end-block" cid="n128" mdtype="line" nodeIndex="153"><span md-inline="plain" nodeIndex="336">来到了我们的寻蛋指令，emmmmm 关于这部分，你只需要知道的是蛋(也就是我们的 shellcode )包含四个字节的标志头. 如果寻蛋开始, 首先它会搜索整个内存直至找到重复两次找到这个标志(如果标志是 </span><span md-inline="code" spellcheck="false" nodeIndex="337"><code nodeIndex="338">`”\x44\x7A\x32\x37”</code></span><span md-inline="plain" nodeIndex="339">, 那么就搜索 </span><span md-inline="code" spellcheck="false" nodeIndex="340"><code nodeIndex="341">”\x44\x7A\x32\x37\x44\x7A\x32\x37”</code></span><span md-inline="plain" nodeIndex="342"> )。当找到这个标志, 改变执行流跳转到标志后的 shellcode 执行。</span></span></p><p cid="n129" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="82"><span class="md-line md-end-block" cid="n130" mdtype="line" nodeIndex="343"><span md-inline="plain" nodeIndex="344">接着我们对着 </span><span md-inline="code" spellcheck="false" nodeIndex="345"><code nodeIndex="346">00a2F196</code></span><span md-inline="plain" nodeIndex="347"> 按 F4，我们看寄存器 edi 的值变为了 </span><span md-inline="code" spellcheck="false" nodeIndex="348"><code nodeIndex="349">003D4960</code></span><span md-inline="plain" nodeIndex="350"> 也就是寻蛋完成了，然后按 F8 执行，跳转到了 </span><span md-inline="code" spellcheck="false" nodeIndex="351"><code nodeIndex="352">003D4960</code></span><span md-inline="plain" nodeIndex="353"> 这段空间</span></span><span class="md-line md-end-block" cid="n130" mdtype="line" nodeIndex="354"><span md-inline="plain" nodeIndex="355"></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83"><div id="RIL_IMG_13" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/13"/></div></p><p cid="n133" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="84"><span class="md-line md-end-block" cid="n134" mdtype="line" nodeIndex="154"><span md-inline="plain" nodeIndex="356">明的你已经发现了，此时执行的 shellcode 正是 py 脚本中 </span><span md-inline="code" spellcheck="false" nodeIndex="357"><code nodeIndex="358">HOST:</code></span><span md-inline="plain" nodeIndex="359"> 后边的那一部分，抛开这个跳转不谈，此时，你或许有这样的疑问</span></span></p><p cid="n135" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="85"><span class="md-line md-end-block" cid="n136" mdtype="line" nodeIndex="360"><span md-inline="code" spellcheck="false" nodeIndex="361"><code nodeIndex="362">HOST:</code></span><span md-inline="plain" nodeIndex="363"> 后面的那些我们构造的 shellcode 到底存放在哪呢？</span></span></p><p cid="n137" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="86"><span class="md-line md-end-block" cid="n138" mdtype="line" nodeIndex="155"><span md-inline="plain" nodeIndex="364">我一开始想到的是栈，因为我们构造的 path 参数的值就在栈里面，那么 HOST 这一部分也应该在里面，但我光速否决了，栈顶是 </span><span md-inline="code" spellcheck="false" nodeIndex="365"><code nodeIndex="366">00a2</code></span><span md-inline="plain" nodeIndex="367"> 开头的跟 </span><span md-inline="code" spellcheck="false" nodeIndex="368"><code nodeIndex="369">003D</code></span><span md-inline="plain" nodeIndex="370"> 相差太大。</span></span></p><p cid="n139" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="87"><span class="md-line md-end-block" cid="n140" mdtype="line" nodeIndex="371"><span md-inline="plain" nodeIndex="372">那只能是堆了……</span></span></p><p cid="n141" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="88"><span class="md-line md-end-block" cid="n142" mdtype="line" nodeIndex="156"><span md-inline="plain" nodeIndex="373">判断栈地址还是堆地址直接用快捷键 </span><span md-inline="code" spellcheck="false" nodeIndex="374"><code nodeIndex="375">ALT+M</code></span><span md-inline="plain" nodeIndex="376"> 就可以看到了，其实这个方法是后来大佬给我说的，我当时判断的方法是这样的：</span></span></p><p cid="n143" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="89"><span class="md-line md-end-block" cid="n144" mdtype="line" nodeIndex="377"><span md-inline="plain" nodeIndex="378">我先在数据窗口 </span><span md-inline="code" spellcheck="false" nodeIndex="379"><code nodeIndex="380">ctrl+G</code></span><span md-inline="plain" nodeIndex="381"> 输入 </span><span md-inline="code" spellcheck="false" nodeIndex="382"><code nodeIndex="383">003D0178</code></span></span><span class="md-line md-end-block" cid="n144" mdtype="line" nodeIndex="384"><span md-inline="code" spellcheck="false" nodeIndex="385"><code nodeIndex="386"></code></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="90"><div id="RIL_IMG_14" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/14"/></div></p><p cid="n147" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="91"><span class="md-line md-end-block" cid="n148" mdtype="line" nodeIndex="387"><span md-inline="code" spellcheck="false" nodeIndex="388"><code nodeIndex="389">003D0178</code></span><span md-inline="plain" nodeIndex="390"> 指向 </span><span md-inline="code" spellcheck="false" nodeIndex="391"><code nodeIndex="392">003D5178（chunk）</code></span><span md-inline="plain" nodeIndex="393">，我们转到 </span><span md-inline="code" spellcheck="false" nodeIndex="394"><code nodeIndex="395">003D5178</code></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="92"><div id="RIL_IMG_15" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/15"/></div></p><p cid="n151" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="93"><span class="md-line md-end-block" cid="n152" mdtype="line" nodeIndex="396"><span md-inline="plain" nodeIndex="397">发现 </span><span md-inline="code" spellcheck="false" nodeIndex="398"><code nodeIndex="399">003D5178</code></span><span md-inline="plain" nodeIndex="400"> 指向 </span><span md-inline="code" spellcheck="false" nodeIndex="401"><code nodeIndex="402">003D0178</code></span><span md-inline="plain" nodeIndex="403">，而 shellcode 的起始位置 </span><span md-inline="code" spellcheck="false" nodeIndex="404"><code nodeIndex="405">003D4960</code></span><span md-inline="plain" nodeIndex="406"> 正好处于 </span><span md-inline="code" spellcheck="false" nodeIndex="407"><code nodeIndex="408">003D0688</code></span><span md-inline="plain" nodeIndex="409"> 到 </span><span md-inline="code" spellcheck="false" nodeIndex="410"><code nodeIndex="411">003D5178</code></span><span md-inline="plain" nodeIndex="412"> 之间，所以这段 shellcode 确实在堆中……</span></span></p><p cid="n153" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="94"><span class="md-line md-end-block" cid="n154" mdtype="line" nodeIndex="413"><span md-inline="plain" nodeIndex="414">emmmm…… </span></span><span class="md-line md-end-block" cid="n154" mdtype="line" nodeIndex="415"><span md-inline="plain" nodeIndex="416">跟大佬的方法一比，还是对 OD 有点不熟练啊……</span></span></p><p cid="n155" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="95"><span class="md-line md-end-block" cid="n156" mdtype="line" nodeIndex="417"><span md-inline="plain" nodeIndex="418">接下来我又产生了一个问题：</span><span md-inline="strong" class="" nodeIndex="419"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="420"><span md-inline="plain" nodeIndex="421">FTP 服务端是什么时候把 </span><span md-inline="code" spellcheck="false" nodeIndex="422"><code nodeIndex="423">HOST:</code></span><span md-inline="plain" nodeIndex="424"> 后面的 shellcode 写到堆中的呢？</span></strong></span></span></p><p cid="n157" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="96"><span class="md-line md-end-block" cid="n158" mdtype="line" nodeIndex="157"><span md-inline="plain" nodeIndex="425">要解决这个问题，我们要以一个开发者的思维来考虑，当一个 get 请求来的时候，我们肯定会创建一个堆区来保存 </span><span md-inline="code" spellcheck="false" nodeIndex="426"><code nodeIndex="427">path，Host，Authorization</code></span><span md-inline="plain" nodeIndex="428"> 这些字段的值，据我的开发经验 </span><span md-inline="code" spellcheck="false" nodeIndex="429"><code nodeIndex="430">c/c++</code></span><span md-inline="plain" nodeIndex="431"> 对堆使用的函数</span></span></p><p cid="n159" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="97"><span class="md-line md-end-block" cid="n160" mdtype="line" nodeIndex="432"><span md-inline="plain" nodeIndex="433">（1）一个是 </span><span md-inline="code" spellcheck="false" nodeIndex="434"><code nodeIndex="435">malloc()</code></span><span md-inline="plain" nodeIndex="436"> ，动态分配，涉及到堆的分配</span></span></p><p cid="n161" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="98"><span class="md-line md-end-block" cid="n162" mdtype="line" nodeIndex="437"><span md-inline="plain" nodeIndex="438">（2）一个是 </span><span md-inline="code" spellcheck="false" nodeIndex="439"><code nodeIndex="440">HeapCreate()</code></span><span md-inline="plain" nodeIndex="441"> ，创建一个堆，紧接着用 </span><span md-inline="code" spellcheck="false" nodeIndex="442"><code nodeIndex="443">HeapAlloc()</code></span><span md-inline="plain" nodeIndex="444"> 方法分配堆空间</span></span></p><p cid="n163" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="99"><span class="md-line md-end-block" cid="n164" mdtype="line" nodeIndex="445"><span md-inline="plain" nodeIndex="446">我倾向于第二种，所以我对 </span><span md-inline="code" spellcheck="false" nodeIndex="447"><code nodeIndex="448">HeapCreate()</code></span><span md-inline="plain" nodeIndex="449"> 下了一个断点( </span><span md-inline="code" spellcheck="false" nodeIndex="450"><code nodeIndex="451">bp HeapCreate</code></span><span md-inline="plain" nodeIndex="452"> )，该函数位于 </span><span md-inline="code" spellcheck="false" nodeIndex="453"><code nodeIndex="454">kernel32.dll</code></span><span md-inline="plain" nodeIndex="455"> 中，重新运行，客户端建立连接，发现 OD 并没有断在该函数上……</span></span></p><p cid="n165" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="100"><span class="md-line md-end-block" cid="n166" mdtype="line" nodeIndex="456"><span md-inline="plain" nodeIndex="457">emmmm…… </span></span><span class="md-line md-end-block" cid="n166" mdtype="line" nodeIndex="458"><span md-inline="plain" nodeIndex="459">难道我想错了？</span></span></p><p cid="n167" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="101"><span class="md-line md-end-block" cid="n168" mdtype="line" nodeIndex="158"><span md-inline="plain" nodeIndex="460">我接着陷入了沉思： </span><span md-inline="code" spellcheck="false" nodeIndex="461"><code nodeIndex="462">HeapCreate()</code></span><span md-inline="plain" nodeIndex="463"> 返回的句柄会不会是一个全局变量，而且在我附加到进程之前就已经进行初始化了，所以才没有断下来，那么我在 </span><span md-inline="code" spellcheck="false" nodeIndex="464"><code nodeIndex="465">HeapAlloc()</code></span><span md-inline="plain" nodeIndex="466"> 下断不就可以了吗？因为开发者肯定会在数据到服务端的时候才进行堆分配并赋值的！</span></span></p><p cid="n169" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="102"><span class="md-line md-end-block" cid="n170" mdtype="line" nodeIndex="467"><span md-inline="plain" nodeIndex="468">接着我把目标转向了 </span><span md-inline="code" spellcheck="false" nodeIndex="469"><code nodeIndex="470">HeapAlloc()</code></span><span md-inline="plain" nodeIndex="471">。这里要注意一下在 OD 直接对 </span><span md-inline="code" spellcheck="false" nodeIndex="472"><code nodeIndex="473">HeapAlloc()</code></span><span md-inline="plain" nodeIndex="474"> 下断是不行的，因为 </span><span md-inline="code" spellcheck="false" nodeIndex="475"><code nodeIndex="476">kernel32.dll</code></span><span md-inline="plain" nodeIndex="477"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="478"><code nodeIndex="479">HeapAlloc()</code></span><span md-inline="plain" nodeIndex="480"> 函数执行时紧接着会调用 </span><span md-inline="code" spellcheck="false" nodeIndex="481"><code nodeIndex="482">ntdll.dll</code></span><span md-inline="plain" nodeIndex="483"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="484"><code nodeIndex="485">RtlAllocateHeap()</code></span><span md-inline="plain" nodeIndex="486"> 所以我们直接对 </span><span md-inline="code" spellcheck="false" nodeIndex="487"><code nodeIndex="488">RtlAllocateHeap()</code></span><span md-inline="plain" nodeIndex="489"> 下断（</span><span md-inline="code" spellcheck="false" nodeIndex="490"><code nodeIndex="491">bp RtlAllocateHeap</code></span><span md-inline="plain" nodeIndex="492">），重启服务器，重新建立连接之后</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="103"><div id="RIL_IMG_16" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/16"/></div></p><p cid="n173" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="104"><span class="md-line md-end-block" cid="n174" mdtype="line" nodeIndex="493"><span md-inline="plain" nodeIndex="494">程序断到了 </span><span md-inline="code" spellcheck="false" nodeIndex="495"><code nodeIndex="496">RtlAllocateHeap()</code></span><span md-inline="plain" nodeIndex="497"> 的入口处，紧接着在数据窗口转到 </span><span md-inline="code" spellcheck="false" nodeIndex="498"><code nodeIndex="499">003D4960</code></span><span md-inline="plain" nodeIndex="500"> ，观察数据窗口，一直按 F9，会产生第一次突变</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="105"><div id="RIL_IMG_17" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/17"/></div></p><p cid="n177" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="106"><span class="md-line md-end-block" cid="n178" mdtype="line" nodeIndex="501"><span md-inline="plain" nodeIndex="502">此时已经把 path 参数的值写入堆中，然后接着按 F9，会产生第二次突变。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="107"><div id="RIL_IMG_18" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/18"/></div></p><p cid="n181" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="108"><span class="md-line md-end-block" cid="n182" mdtype="line" nodeIndex="159"><span md-inline="plain" nodeIndex="503">exp 中 </span><span md-inline="code" spellcheck="false" nodeIndex="504"><code nodeIndex="505">Host:</code></span><span md-inline="plain" nodeIndex="506"> 的值，也就是弹出计算器的 shellcode 已经分配到堆中了，整个流程也就分析完了。</span></span></p><h3 cid="n183" mdtype="heading" class="md-end-block md-heading" nodeIndex="109"><span md-inline="plain" nodeIndex="507">0x05 小结</span></h3><p cid="n184" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="110"><span class="md-line md-end-block" cid="n185" mdtype="line" nodeIndex="508"><span md-inline="plain" nodeIndex="509">该漏洞是通过 http 的 get 请求提交的超长字符串淹没程序的返回地址，进而控制程序流程，再使用寻蛋技术使程序跳向堆中进行执行我们已经构造好的 shellcode。</span></span></p><h3 cid="n186" mdtype="heading" class="md-end-block md-heading" nodeIndex="111"><span md-inline="plain" nodeIndex="510">0x06 关于寻蛋技术</span></h3><p cid="n187" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="112"><span class="md-line md-end-block" cid="n188" mdtype="line" nodeIndex="511"><span md-inline="plain" nodeIndex="512">我这里粗略的讲一下寻蛋技术的概要，通过前面的溯源我们应该都清楚了缓冲区溢出是怎么工作的，以及我们怎么劫持一个程序的执行流程，那么问题来了，如果像这个漏洞一样栈的空间不足放不下那么大的 shellcode 怎么办？</span></span></p><p cid="n189" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="113"><span class="md-line md-end-block" cid="n190" mdtype="line" nodeIndex="160"><span md-inline="plain" nodeIndex="513">很明显我们通过把 shellcode 放到堆里面，换句话说就是布置 shellcode 在不同的内存区域，如果离的很近那么我们直接用 </span><span md-inline="code" spellcheck="false" nodeIndex="514"><code nodeIndex="515">jmp offerset</code></span><span md-inline="plain" nodeIndex="516">。</span></span></p><p cid="n191" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="114"><span class="md-line md-end-block" cid="n192" mdtype="line" nodeIndex="517"><span md-inline="plain" nodeIndex="518">如果离的远，就像本例一样，一个在栈，一个在堆。那么我们就需要一个新的技术来找到它，这便是寻蛋技术的由来。蛋指的是 shellcode 的前四个字节，就相当于一个标志头。寻蛋开始时，首先它会搜索整个内存(栈/堆/…)直至找到重复两次找到这个标志。</span></span></p><p cid="n193" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="115"><span class="md-line md-end-block" cid="n194" mdtype="line" nodeIndex="519"><span md-inline="plain" nodeIndex="520">当找到这个标志, 改变执行流跳转到标志后的 shellcode 执行。相信大家结合这个实例一定会对寻蛋技术有一个更深的体会。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="116"><div id="RIL_IMG_19" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/19"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="117"><br nodeIndex="521"></p>
                </div>
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" nodeIndex="118"></div>

                
                                <p class=" _RIL_KEEPER_CLASS_" nodeIndex="122">
                        
                        <a class="reward_access" id="js_reward_link" href=""><span class="icon-reward"></span><span id="js_reward_link_text">赞赏</span></a>
                        
                    </p><p class="tips_global reward_user_tips _RIL_KEEPER_CLASS_" nodeIndex="124"><a href="" id="js_reward_total"></a>人赞赏</p><div id="RIL_IMG_20" class="RIL_IMG"><img src="/media/posts_images/2018-01-19-2035056453/20"/></div>
                                <p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="127">长按二维码向我转账</p><p class="reward_tips _RIL_KEEPER_CLASS_" nodeIndex="128"></p><p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="129">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                                            </div>
                        
                        


                    </div>