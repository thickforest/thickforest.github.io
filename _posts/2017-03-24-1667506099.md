---
layout: post
title: PHP网站渗透中的奇技淫巧：检查相等时的漏洞
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s/GCFUcNxAPe985nf9pnQ9Dw

收藏时间：2017-03-24 13:11:57

<div  lang="zh">
                <div id="img-content" class="rich_media_area_primary" nodeIndex="6">
                    
                    <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                                <label class="profile_meta_label">微信号</label>
                                <span class="profile_meta_value">freebuf</span>
                                </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="12">
                                <label class="profile_meta_label">功能介绍</label>
                                <span class="profile_meta_value">国内关注度最高的全球互联网安全新媒体</span>
                                </p>
                    
                    
                    
                    
                                                            
                                                            
                    
                    <div class="rich_media_content " id="js_content" nodeIndex="13">
                        
                       
                        

                        
                        
                        <p class=" _RIL_KEEPER_CLASS_" nodeIndex="14"><span nodeIndex="141">*本文原创作者：sarleon，属Freebuf原创奖励计划，未经许可禁止转载</span><br nodeIndex="142"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="15"><span nodeIndex="143">PHP是现在网站中最为常用的后端语言之一，是一种类型系统 动态、弱类型的面向对象式编程语言。可以嵌入HTML文本中，是目前最流行的web后端语言之一，并且可以和Web Server 如apache和nginx方便的融合。目前，已经占据了服务端市场的极大占有量。</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="16">但是，弱类型，一些方便的特性由于新手程序员的不当使用，造成了一些漏洞，这篇文章就来介绍一下一些渗透中可以用的特性。<br nodeIndex="144"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="17">上面都是废话，下面我们进入正题</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="18"><span nodeIndex="145">1.弱类型的比较==导致的漏洞</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="19">注：这些漏洞适用于所有版本的php</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="20">先来复习一下基本的语法：php中有如下两种比较符号：两个等号和三个等号（这一点和Javascript）有些类似</p><blockquote nodeIndex="21"><pre nodeIndex="22"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="23"><code nodeIndex="146"><span nodeIndex="147">$a==$b
$a===$b</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="24">我们来一下php官方手册的说法</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="25"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/1"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="26">明确的看到，两个等于号的等于会在比较的时候进行类型转换的比较。</p><blockquote nodeIndex="27"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="28">如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。此规则也适用于 switch 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对.</p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="29">明确的写出了 <span nodeIndex="148">如果一个数值和一个字符串比较，那么会将字符串转换为数值</span>（而不是相反，将数值转化为字符串）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="30">然而，php是如何将一个字符串转化为数值的呢，我们继续查看php手册</p><blockquote nodeIndex="31"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="32">当一个字符串被当作一个数值来取值，其结果和类型如下：如果该字符串没有包含 ‘.’，’e’ 或 ‘E’ 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 ‘e’ 或 ‘E’ 后面跟着一个或多个数字构成。</p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="33">这是官方手册上面的几个例子</p><blockquote nodeIndex="34"><pre nodeIndex="35"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="36"><code nodeIndex="149"><span nodeIndex="150"><?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
?></span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="37"><span nodeIndex="151">我们大概可以总结出如下的规则</span>：当一个字符串被转换为数值时</p><blockquote nodeIndex="38"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="39"><span nodeIndex="152">如果一个字符串为 “合法数字+e+合法数字”类型，将会解释为科学计数法的浮点数</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="40"><span nodeIndex="153">如果一个字符串为 “合法数字+ 不可解释为合法数字的字符串”类型，将会被转换为该合法数字的值，后面的字符串将会被丢弃</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="41"><span nodeIndex="154">如果一个字符串为“不可解释为合法数字的字符串+任意”类型，则被转换为0！ 为0…为0</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="42"><span nodeIndex="155"></span></p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="44"><li nodeIndex="43"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="45"><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/2"/></div></p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="46"><span nodeIndex="156">当然，上面的那些等式对于===都是false的，原本一些应该用===的地方误用了==，导致了可以注入的地方。</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="47"><span nodeIndex="157">示例代码 1：利用转为数字后相等的漏洞</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="48"><div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/3"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="49">但是我们看到，最终比较两者的哈希的时候，使用的是<span nodeIndex="158">等于</span> 而不是 <span nodeIndex="159">全等于</span> ，因此可以利用一下这个漏洞</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="50">再回头看一 <code nodeIndex="160">md5()</code> 函数</p><blockquote nodeIndex="51"><pre nodeIndex="52"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><code nodeIndex="161"><span nodeIndex="162">string md5 ( string $str [, bool $raw_output = false ] )</span></code></p></pre></blockquote><blockquote nodeIndex="54"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55">str原始字符串。raw_output如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。</p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="56">可以知道，第二个参数为true的时候，显示16位的结果，而为false和没有第二个参数时，为32位的16进制码（16位的结果是把32位的作为ASCII码进行解析）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="57">16进制的数据中是含有e的，可以构建使得两个数字比较的，这里有一个现成的例子：</p><blockquote nodeIndex="58"><pre nodeIndex="59"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="60"><code nodeIndex="163"><span nodeIndex="164">md5('240610708') 
//0e462097431906509019562988736854.md5('QNKCDZO') 
//0e830400451993494058024219903391</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="61">可以看到，这两个字符串一个只包含数字，一个只包含字母，虽然两个的哈希不一样，但是都是一个形式：0e 纯数字这种格式的字符串在判断相等的时候会被认为是科学计数法的数字，先做字符串到数字的转换。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="62">转换后都成为了0的好多好多次方，都是0，相等。（大家可以自己尝试一下）因此</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/4"/></div></p><h2 nodeIndex="64">示例代码2: 利用 类’a'==0的漏洞</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="65"><div id="RIL_IMG_5" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/5"/></div></p><blockquote nodeIndex="66"><pre nodeIndex="67"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="68"><code nodeIndex="165"><span nodeIndex="166">{"key":"your input"}</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="69">我们该如何破解？想”a”==0这个漏洞，之用我们使<code nodeIndex="167">$json->key</code>是一个数字类型的变量就可以，怎么做到呢？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="70">php的<code nodeIndex="168">json_decode()</code>函数会根据json数据中的数据类型来将其转换为php中的相应类型的数据，也就是说，如果我们在json中传一个string类型，那么该变量就是string，如果传入的是number，则该变量为number。因此，我们如果传入一个数字，就可以使之相等。网页中的表单可能限制了所有的输入都是string，即使输入数字，传入的东西也是</p><blockquote nodeIndex="71"><pre nodeIndex="72"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="73"><code nodeIndex="169"><span nodeIndex="170">{"key":"0"}</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="74">这是一个字符串0，我们需要让他为数字类型，用burp拦截，把两个双引号去掉，变成这样：</p><blockquote nodeIndex="75"><pre nodeIndex="76"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="77"><code nodeIndex="171"><span nodeIndex="172">{"key":0}</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="78">即可。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="79">值得讨论的一点是，在这种方法的漏洞利用中，很难在直接表单类型的POST的数据中使用，这是为什么呢，这个和HTTP协议有关。首先，我们看一下，在POST给服务器的数据中，有几种类型，也就是HTTP header中的Content-Type:</p><blockquote nodeIndex="80"><pre nodeIndex="81"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="82"><code nodeIndex="173"><span nodeIndex="174">application/x-www-form-urlencoded
multipart/form-data
application/json
application/xml</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83">第一个application/x-www-form-urlencoded，是一般表单形式提交的content-type第二个，是包含文件的表单。第三，四个，分别是json和xml，一般是js当中上传的.</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="84">但是因为在直接的POST的payload当中是无法区分字符串和数字的，因为在其中并没有引号出现，举一个抓包的例子</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="85"><div id="RIL_IMG_6" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/6"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="86">可以看到，payload是放在http包的最后面的，而且都是以没有引号的形式传递的，并没有办法区分到底是字符串还是数字。因此，PHP将POST的数据全部保存为字符串形式，也就没有办法注入数字类型的数据了而JSON则不一样，JSON本身是一个完整的字符串，经过解析之后可能有字符串，数字，布尔等多种类型。<br nodeIndex="175"></p><h2 nodeIndex="87">2. strcmp漏洞</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="88">注：这一个漏洞适用与5.3之前版本的php</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="89">我们首先看一下这个函数,这个函数是用于比较字符串的函数</p><blockquote nodeIndex="90"><pre nodeIndex="91"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="92"><code nodeIndex="176"><span nodeIndex="177">int strcmp ( string $str1 , string $str2 )</span></code></p></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="93">参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="94">可知，传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，<span nodeIndex="178">显示了报错的警告信息后，将return 0 !!!!</span> 也就是虽然报了错，但却判定其相等了。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="95">这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。但是我们仍然可以使用这个漏洞对使用老版本php的网站进行渗透测试。看一段示例代码：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="96"><div id="RIL_IMG_7" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/7"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="97">对于这段代码，我们能用什么办法绕过验证呢， 只要我们<code nodeIndex="179">$_POST['password']</code>是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢。<br nodeIndex="180"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="98">其实php为了可以上传一个数组，会把结尾带一对中括号的变量，例如 <code nodeIndex="181">xxx[]</code>的name（就是$_POST中的key），当作一个名字为<code nodeIndex="182">xxx</code>的数组构造类似如下的request</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="99"><div id="RIL_IMG_8" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/8"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100"><span nodeIndex="183">即可使得上述代码绕过验证成功。</span></p><h2 nodeIndex="101">3 总结</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="102">这一类型的漏洞的特点主要就是利用PHP中 的类型特性来绕过验证。由于 == 和 === 有着明显的区分，因此，估计短期内PHP的作者并不会调整对于这两个符号的策略。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="103">而对于开发市场而言，随着培训机构的增多，后端程序员尤其是<span nodeIndex="184">php后端程序员的门槛越来越低，其水平必定也是良莠不齐</span>，这些二把刀程序员可能带来更多的<span nodeIndex="185">此类对于特性的不当使用导致的漏洞</span>，因此这类漏洞仍然是非常具有利用价值的。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="104">总结一下，对于开发人员，需要坚持几个习惯：</p><blockquote nodeIndex="105"><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="107"><li nodeIndex="106"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="108"><span>认真阅读PHP manual，不能以其他语言的经验来完全带入php进行编码</span></p></li><li nodeIndex="109"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="110"><span>在使用一个运算符或者函数之前，详细的查看文档，搞清楚函数在什么样的条件下，会有怎样的行为。</span></p></li></ul></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="111">记住保证安全的几句箴言：<span nodeIndex="186">任何用户输入都是不可信的！</span>对于web应用来说，<span nodeIndex="187">前端（浏览器端）的安全限制只能起到防止一般用户的误输入行为，完全不可能对于黑帽子的行为有任何的防御作用</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="112">因此，在防御这个漏洞的过程中，保证几件事情：</p><blockquote nodeIndex="113"><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="115"><li nodeIndex="114"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="116"><span>在所有可能的地方，都使用</span><code><span>===</span></code><span>来代替</span><code><span>==</span></code></p></li><li nodeIndex="117"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="118"><span>对于用户输入做过滤和类型检查</span></p></li><li nodeIndex="119"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="120"><span>尽量使用新版本的php，apache</span></p></li></ul></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="121">基本上就可以完美的防御这一类的漏洞。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="122">而对于渗透测试人员，在代码审计的过程中，对于有<code nodeIndex="188">==</code>,<code nodeIndex="189">strcmp</code>的比较也应极为敏感 。在黑盒渗透的时候也可以对于代码进行猜测，结合信息搜集过程中的一些版本特性，利用这些漏洞来绕过验证。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="123"><span nodeIndex="190">*本文原创作者：sarleon，属Freebuf原创奖励计划，未经许可禁止转载</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="124"><div id="RIL_IMG_9" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/9"/></div></p>
                    </div>
                    <p id="js_preview_reward_wording" class="tips_global reward_tips _RIL_KEEPER_CLASS_" nodeIndex="127"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="128">
                            <a class="reward_access" id="js_preview_reward_link" href="">赞赏</a>
                        </p></div><p class="discuss_icon_tips rich_split_tips tr _RIL_KEEPER_CLASS_" nodeIndex="136" childisonlyalink="1">
                        <a href="" id="js_preview_cmt_write">写留言<div id="RIL_IMG_10" class="RIL_IMG"><img src="/media/posts_images/2017-03-24-1667506099/10"/></div></a>
                      </p></div>