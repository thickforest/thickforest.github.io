---
layout: post
title: 闲话文件上传漏洞
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s/D7_pbwEo0wRkxV79lD9E_A

收藏时间：2017-03-15 12:33:32

<div  lang="zh">
                <div id="img-content" class="rich_media_area_primary" nodeIndex="6">
                    
                    <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                                <label class="profile_meta_label">微信号</label>
                                <span class="profile_meta_value">freebuf</span>
                                </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="12">
                                <label class="profile_meta_label">功能介绍</label>
                                <span class="profile_meta_value">国内关注度最高的全球互联网安全新媒体</span>
                                </p>
                    
                    
                    
                    
                                                            
                                                            
                    
                    <div class="rich_media_content " id="js_content" nodeIndex="13">
                        

                        
                        
                        <p class=" _RIL_KEEPER_CLASS_" nodeIndex="14"><span nodeIndex="257">* 原创作者：sarleon，本文属FreeBuf原创奖励计划，未经许可禁止转载</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="15"><span nodeIndex="258">文件上传漏洞是web安全中经常利用到的一种漏洞形式。这种类型的攻击从大的类型上来说，是攻击 数据与代码分离原则 的一种攻击。</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="16">一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码</p><blockquote nodeIndex="17"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="18">造成文件上传漏洞的原因是</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="19">对于上传文件的后缀名（扩展名）没有做较为严格的限制</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="20">对于上传文件的MIMETYPE 没有做检查</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="21">权限上没有对于上传的文件的文件权限，（尤其是对于shebang类型的文件）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="22">对于web server对于上传文件或者指定目录的行为没有做限制</p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="23">下面就闲话一些文件上传漏洞的防御方式和攻击者的绕过方式</p><h2 nodeIndex="24">1.前端限制</h2><blockquote nodeIndex="25"><pre nodeIndex="26"><code class="hljs javascript" nodeIndex="28"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="27"><span nodeIndex="259">function check(){</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="29"><span nodeIndex="260">        var filename=document.getElementById("file");</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="30"><span nodeIndex="261">        var str=filename.value.split(".");</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="31"><span nodeIndex="262">        var ext=str[str.length-1];</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="32"><span nodeIndex="263">        if(ext=='jpg'||ext=='png'||ext=='jpeg'||ext=='gif'){</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="33"><span nodeIndex="264">            return true;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34"><span nodeIndex="265">        }else{</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="35"><span nodeIndex="266">            alert("这不是图片！")</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="36"><span nodeIndex="267">            return false;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="37"><span nodeIndex="268">        }</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="38"><span nodeIndex="269">        return false;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="39"><span nodeIndex="270">    }</span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="40">在表单中使用onsumbit=check()调用js函数来检查上传文件的扩展名。这种限制实际上没有任何用处，任何攻击者都可以轻而易举的破解。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="41">只能用于对于用户完全信任的情况下，很难称之为一种安全措施只能称之是一种防止用户误操作上传的措施。</p><h3 nodeIndex="42">反制：</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="43">随便的编辑一下页面/用burpsuite/写个小脚本就可以突破之，无须多言</p><h2 nodeIndex="44">2.检查扩展名</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="45">顾名思义，就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="46">在这里，还有一点是值得一提的，在检查扩展名是否合法的时候，有两种策略</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="47"><span nodeIndex="271">黑名单策略，文件扩展名在黑名单中的为不合法，示例代码</span></p><blockquote nodeIndex="48"><pre nodeIndex="49"><code class="hljs ruby" nodeIndex="51"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="50"><span nodeIndex="272">$postfix = end(explode('.','$_POST['filename']);</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="52"><span nodeIndex="273">if($postfix=='php'||$postfix=='asp'||$postfix=='sh'){</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><span nodeIndex="274">  echo "invalid file type";</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="54"><span nodeIndex="275">  return;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55"><span nodeIndex="276">}</span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="56"><span nodeIndex="277">白名单策略，文件扩展名不在白名单中的均为不合法</span></p><blockquote nodeIndex="57"><pre nodeIndex="58"><code class="hljs ruby" nodeIndex="60"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="59"><span nodeIndex="278">$postfix = end(explode('.','$_POST['filename']);</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="61"><span nodeIndex="279">if($postfix=='jpg'||$postfix=='png'||$postfix=='gif'){</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="62"><span nodeIndex="280">  //save the file and do something next</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><span nodeIndex="281">} else {</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="64"><span nodeIndex="282">  echo "invalid file type";</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="65"><span nodeIndex="283">  return;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="66"><span nodeIndex="284">}</span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="67">白名单策略是更加安全的，通过限制上传类型为只有我们接受的类型，可以较好的保证安全，因为黑名单我们可以使用各种方法来进行注入和突破<br nodeIndex="285"></p><h3 nodeIndex="68">反制</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="69">在一些 webserver 中，存在解析漏洞</p><blockquote nodeIndex="70"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="71">1.老版本的IIS中的目录解析漏洞，如果网站目录中有一个 /.asp/目录，那么此目录下面的一切内容都会被当作asp脚本来解析</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="72">2.老板本的IIS中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="73">3.旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="74">4.nginx空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="75">5.apache的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的</p></blockquote><h2 nodeIndex="76">3.检查HTTP Header中的Content-Type</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="77">HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型不过这仍然是不安全的,因为HTTP header可以被发出者或者中间人任意的修改，不过加上一层防护也是可以有一定效果的</p><h3 nodeIndex="78">反制</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="79">使用各种各样的工具（如burpsuite）强行篡改Header就可以，太容易将header中的</p><blockquote nodeIndex="80"><pre nodeIndex="81"><code nodeIndex="286"><span nodeIndex="287">Content-Type: application/php</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="82">或者其他类型</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83">改为<br nodeIndex="288"></p><blockquote nodeIndex="84"><pre nodeIndex="85"><code nodeIndex="289"><span nodeIndex="290">Content-Type: image/jpg</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="86"><br nodeIndex="291"></p><blockquote nodeIndex="87"><pre nodeIndex="88"><code nodeIndex="292"><span nodeIndex="293">Content-Type: image/png</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="89"><br nodeIndex="294"></p><blockquote nodeIndex="90"><pre nodeIndex="91"><code nodeIndex="295"><span nodeIndex="296">Content-Type: text/plain</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="92">等这些web程序允许的泪洗改附上常用的MIMETYPE表</p><blockquote nodeIndex="93"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="94">text/plain（纯文本）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="95">text/html（HTML文档）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="96">text/javascript（js代码）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="97">application/xhtml+xml（XHTML文档）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="98">image/gif（GIF图像）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="99">image/jpeg（JPEG图像）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100">image/png（PNG图像）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="101">video/mpeg（MPEG动画）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="102">application/octet-stream（二进制数据）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="103">application/pdf（PDF文档）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="104">application/(编程语言) 该种语言的代码</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="105">application/msword（Microsoft Word文件）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="106">message/rfc822（RFC 822形式）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="107">multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="108">application/x-www-form-urlencoded（POST方法提交的表单）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="109">multipart/form-data（POST提交时伴随文件上传的表单）</p></blockquote><h2 nodeIndex="110">4.分析文件头内容来检查文件类型</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="111">与方法2不同，还有一种检查类型的方式是使用对于文件内容的验证机制，这种方法利用的是每一个特定类型的文件都会有不太一样的开头或者标志位。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="112">可以通过比如php的exif_imagetype()函数，一个通过这种方法来过滤的示例代码如下：</p><blockquote nodeIndex="113"><pre nodeIndex="114"><code class="hljs markdown" nodeIndex="116"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="115"> <span nodeIndex="297">if (! exif_imagetype($_FILES['uploadedfile']['tmp_name'])) {</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="117"><span nodeIndex="298">        echo "File is not an image";</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="118"><span nodeIndex="299">        return;</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="119"><span nodeIndex="300">    }</span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="120">也可以自己编写函数来进行识别，图片文件通常有称作幻数的头字节，我们来看一下几种图片文件的幻数：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="121">（注意！下面是二进制而不是文本格式的数据）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="122">JPG</p><blockquote nodeIndex="123"><pre nodeIndex="124"><code nodeIndex="301"><span nodeIndex="302">FF D8 FF E0 00 10 4A 46 49 46</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="125">GIF</p><blockquote nodeIndex="126"><pre nodeIndex="127"><code nodeIndex="303"><span nodeIndex="304">47 49 46 38 39 61</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="128">(相当于文本的GIF89a)</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="129">PNG</p><blockquote nodeIndex="130"><pre nodeIndex="131"><code nodeIndex="305"><span nodeIndex="306">89 50 4E 47</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="132">通过检查头几位字节，可以分辨是否是图片文件</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="133">如果是其他类型的二进制文件，也有响应的头字节，如下表</p><h3 nodeIndex="134">反制</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="135">给上传脚本加上相应的幻数头字节就可以，php引擎会将 <?之前的内容当作html文本，不解释而跳过之，后面的代码仍然能够得到执行比如下面：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="136">（一般不限制图片文件格式的时候使用GIF的头比较方便，因为全都是文本可打印字符。）</p><blockquote nodeIndex="137"><pre nodeIndex="138"><code class="hljs xml" nodeIndex="140"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="139"><span nodeIndex="307">GIF89a</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="141"><span nodeIndex="308"><?php</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="142"><span nodeIndex="309">do_something();</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="143"><span nodeIndex="310">?></span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="144">如果是其他类型的二进制文件，也有响应的头字节，如下表</p><table width="850" class=" _RIL_KEEPER_CLASS_ ril_dataTable" nodeIndex="311"><colgroup nodeIndex="312"><col width="NaN%" nodeIndex="313"><col width="NaN%" nodeIndex="314"></colgroup><thead nodeIndex="315"><tr nodeIndex="316"><th nodeIndex="317"><span nodeIndex="318">格式</span></th><th nodeIndex="319"><span nodeIndex="320">文件头</span></th></tr></thead><tbody nodeIndex="321"><tr nodeIndex="146"><td height="30" nodeIndex="145"><span nodeIndex="322">TIFF (tif)</span></td><td height="30" nodeIndex="147"><span nodeIndex="323">49492A00</span></td></tr><tr nodeIndex="149"><td height="30" nodeIndex="148"><span nodeIndex="324">Windows Bitmap (bmp)</span></td><td height="30" nodeIndex="150"><span nodeIndex="325">424D</span></td></tr><tr nodeIndex="152"><td height="30" nodeIndex="151"><span nodeIndex="326">CAD (dwg)</span></td><td height="30" nodeIndex="153"><span nodeIndex="327">41433130</span></td></tr><tr nodeIndex="155"><td height="30" nodeIndex="154"><span nodeIndex="328">Adobe Photoshop (psd)</span></td><td height="30" nodeIndex="156"><span nodeIndex="329">38425053</span></td></tr><tr nodeIndex="158"><td height="30" nodeIndex="157"><span nodeIndex="330">Rich Text Format (rtf)</span></td><td height="30" nodeIndex="159"><span nodeIndex="331">7B5C727466</span></td></tr><tr nodeIndex="161"><td height="30" nodeIndex="160"><span nodeIndex="332">MS Word/Excel (xls.or.doc)</span></td><td height="30" nodeIndex="162"><span nodeIndex="333">D0CF11E0</span></td></tr><tr nodeIndex="164"><td height="30" nodeIndex="163"><span nodeIndex="334">MS Access (mdb)</span></td><td height="30" nodeIndex="165"><span nodeIndex="335">5374616E64617264204A</span></td></tr><tr nodeIndex="167"><td height="30" nodeIndex="166"><span nodeIndex="336">ZIP Archive (zip)，</span></td><td height="30" nodeIndex="168"><span nodeIndex="337">504B0304</span></td></tr><tr nodeIndex="170"><td height="30" nodeIndex="169"><span nodeIndex="338">RAR Archive (rar)，</span></td><td height="30" nodeIndex="171"><span nodeIndex="339">52617221</span></td></tr><tr nodeIndex="173"><td height="30" nodeIndex="172"><span nodeIndex="340">Wave (wav)，</span></td><td height="30" nodeIndex="174"><span nodeIndex="341">57415645</span></td></tr><tr nodeIndex="176"><td height="30" nodeIndex="175"><span nodeIndex="342">AVI (avi)，</span></td><td height="30" nodeIndex="177"><span nodeIndex="343">41564920</span></td></tr><tr nodeIndex="179"><td height="30" nodeIndex="178"><span nodeIndex="344">Real Media (rm)，</span></td><td height="30" nodeIndex="180"><span nodeIndex="345">2E524D46</span></td></tr><tr nodeIndex="182"><td height="30" nodeIndex="181"><span nodeIndex="346">MPEG (mpg)，</span></td><td height="30" nodeIndex="183"><span nodeIndex="347">000001BA</span></td></tr><tr nodeIndex="185"><td height="30" nodeIndex="184"><span nodeIndex="348">MPEG (mpg)，</span></td><td height="30" nodeIndex="186"><span nodeIndex="349">000001B3</span></td></tr><tr nodeIndex="188"><td height="30" nodeIndex="187"><span nodeIndex="350">Quicktime (mov)，</span></td><td height="30" nodeIndex="189"><span nodeIndex="351">6D6F6F76</span></td></tr><tr nodeIndex="191"><td height="30" nodeIndex="190"><span nodeIndex="352">Adobe Acrobat (pdf)，</span></td><td height="30" nodeIndex="192"><span nodeIndex="353">255044462D312E</span></td></tr><tr nodeIndex="194"><td height="30" nodeIndex="193"><span nodeIndex="354">Windows Media (asf)，</span></td><td height="30" nodeIndex="195"><span nodeIndex="355">3026B2758E66CF11</span></td></tr><tr nodeIndex="197"><td height="30" nodeIndex="196"><span nodeIndex="356">MIDI (mid)，</span></td><td height="30" nodeIndex="198"><span nodeIndex="357">4D546864</span></td></tr></tbody></table><h2 nodeIndex="199">5.限制Web Server对于特定类型文件的行为</h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="200">导致文件上传漏洞的根本原因在于服务把用户上传的本应是数据的内容当作了代码，一般来说，用户上传的内容都会被存储到特定的一个文件夹下。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="201">比如我们很多人习惯于放在 ./upload/ 下面要防止数据被当作代码执行，我们可以限制web server对于特定文件夹的行为。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="202">大多数服务端软件都可以支持用户对于特定类型文件的行为的自定义，以Apache为例：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="203">在默认情况下，对与 .php文件Apache会当作代码来执行，对于 html,css,js文件，则会直接由HTTP Response交给客户端程序对于一些资源文件，比如txt，doc，rar等等，则也会以文件下载的方式传送的客户端。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="204">我们希望用户上传的东西仅仅当作资源和数据而不能当作代码</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="205">因此可以使用服务器程序的接口来进行限制</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="206">以Apache为例,我们可以利用 .htaccess 文件机制来对web server行为进行限制</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="207">在这里插一句，如果不是专门的文件下载目录，请务必关掉文件夹浏览的权限，以防止嗅探和可能的越权，也是使用.htaccess文件，在其中加上一句</p><blockquote nodeIndex="208"><pre nodeIndex="209"><code nodeIndex="358"><span nodeIndex="359">Options All -Indexes</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="210">即可。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="211"><span nodeIndex="360">禁止脚本执行有多种方式可以实现，而且分别有不同的效果，我们分别来看一下</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="212">1.指定特定扩展名的文件的处理方式,原理是指定Response的Content-Type可以加上如下几行</p><blockquote nodeIndex="213"><pre nodeIndex="214"><code nodeIndex="361"><span nodeIndex="362">AddType text/plain .pl .py .php</span></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="215">这种情况下，以上几种脚本文件会被当作纯文本来显示出来，你也可以换成其他的Content-Type</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="216">2.如果要完全禁止特定扩展名的文件被访问，用下面的几行</p><blockquote nodeIndex="217"><pre nodeIndex="218"><code class="hljs css" nodeIndex="220"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="219"><span nodeIndex="363">Options -ExecCGI</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="221"><span nodeIndex="364">AddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi识别</span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="222">在这种情况下，以上几种类型的文件被访问的时候，会返回403 Forbidden的错误</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="223">3.也可以强制web服务器对于特定文件类型的处理，与第一条不同的是， 下面的方法直接强行让apache将文件识别为你指定的类型，而第一种是让浏览器</p><blockquote nodeIndex="224"><pre nodeIndex="225"><code class="hljs dts" nodeIndex="227"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="226"><span nodeIndex="365"><FilesMatch "\.(php|pl|py|jsp|asp|htm|shtml|sh|cgi)$"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="228"><span nodeIndex="366">ForceType text/plain</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="229"><span nodeIndex="367"></FilesMatch></span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="230">看代码就可以很明白的知道，符合上面正则的全部被认为是纯文本，也可以继续往里面加入其他类型。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="231">4.只允许访问特定类型的文件</p><blockquote nodeIndex="232"><pre nodeIndex="233"><code class="hljs apache" nodeIndex="235"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="234"><span nodeIndex="368"><Files ^(*.jpeg|*.jpg|*.png|*.gif)></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="236"><span nodeIndex="369">order deny,allow</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="237"><span nodeIndex="370">deny from all</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="238"><span nodeIndex="371"></Files></span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="239">在一个上传图片的文件夹下面，就可以加上这段代码，使得该文件夹里面只有图片扩展名的文件才可以被访问，其他类型都是拒绝访问。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="240">这又是一个白名单的处理方案</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="241">永远记得，白名单是最有保障的安全措施</p><h3 nodeIndex="242">反制</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="243">可以通过 move_uploaded_file 函数把自己写的.htaccess 文件上传，覆盖掉服务器上的文件，来定义文件类型和执行权限如果做到了这一点，将获得相当大的权限。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="244"><span nodeIndex="372">* 原创作者：sarleon，本文属FreeBuf原创奖励计划，未经许可禁止转载</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="245"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2017-03-15-1653525571/1"/></div></p>
                    </div>
                    </div></div>