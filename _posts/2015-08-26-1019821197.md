---
layout: post
title: 为什么人人都该懂点LLVM
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s?__biz=MjM5NjQ4MjYwMQ==&mid=209153082&idx=1&sn=f7e89ee4a5f3457c6ba6c0a9f103ba57&scene=0#rd

收藏时间：2015-08-26 10:01:58

<div  ><div id="img-content" nodeIndex="5"><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="10">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">linux-cn</span>
                            </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">十万级技术订阅号，依托于『Linux中国』（https://linux.cn/）社区，专注于 Linux 学习、技术研究、开源思想传播。</span>
                            </p>
                                                
                
                <div class="rich_media_content " id="js_content" nodeIndex="13">
                    

                    

                    
                    
                    <p class=" _RIL_KEEPER_CLASS_" nodeIndex="14">只要你和程序打交道，了解编译器架构就会令你受益无穷——无论是分析程序效率，还是模拟新的处理器和操作系统。通过本文介绍，即使你对编译器原本一知半解，也能开始用LLVM，来完成有意思的工作。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="15"> </p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="16"><a class="target-fix" nodeIndex="439"></a></p><h3 nodeIndex="17">LLVM是什么？</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="18">LLVM是一个好用、好玩，而且超前的系统语言（比如C和C++语言）编译器。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="19">当然，因为LLVM实在太强大，你会听到许多其他特性（它可以是个JIT；支持了一大批非类C语言；还是App Store上的一种新的发布方式等等）。这些都是真的，不过就这篇文章而言，还是上面的定义更重要。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="20">下面是一些让LLVM与众不同的原因：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="22"><li nodeIndex="21"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="23">LLVM的“中间表示”（IR）是一项大创新。LLVM的程序表示方法真的“可读”（如果你会读汇编）。虽然看上去这没什么要紧，但要知道，其他编译器的中间表示大多是种内存中的复杂数据结构，以至于很难写出来，这让其他编译器既难懂又难以实现。</p></li><li nodeIndex="24"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="25">然而LLVM并非如此。其架构远比其他编译器要模块化得多。这种优点可能部分来自于它的最初实现者。</p></li><li nodeIndex="26"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="27">尽管LLVM给我们这些狂热的学术黑客提供了一种研究工具的选择，它还是一款有大公司做后台的工业级编译器。这意味着你不需要去在“强大的编译器”和“可玩的编译器”之间做妥协——不像你在Java世界中必须在HotSpot和Jikes之间权衡那样。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="28"><a class="target-fix" nodeIndex="440"></a></p><h3 nodeIndex="29">为什么人人需要懂点儿LLVM？</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="30">是，LLVM是一款酷炫的编译器，但是如果不做编译器研究，还有什么理由要管它？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="31">答：只要你和程序打交道，了解编译器架构就会令你受益，而且从我个人经验来看，非常有用。利用它，可以分析程序要多久一次来完成某项工作；改造程序，使其更适用于你的系统，或者模拟一个新的处理器架构或操作系统——只需稍加改动，而不需要自己烧个芯片，或者写个内核。对于计算机科学研究者来说，编译器远比他们想象中重要。建议你先试试LLVM，而不用hack下面这些工具（除非你真有重要的理由）：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="33"><li nodeIndex="32"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34">架构模拟器；</p></li><li nodeIndex="35"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="36">动态二进制分析工具，比如Pin；</p></li><li nodeIndex="37"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="38">源代码变换（简单的比如sed，复杂一些的比如抽象语法树的分析和序列化）；</p></li><li nodeIndex="39"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="40">修改内核来干预系统调用；</p></li><li nodeIndex="41"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="42">任何和虚拟机管理程序相似的东西。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="43">就算一个编译器不能完美地适合你的任务，相比于从源码到源码的翻译工作，它可以节省你九成精力。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="44">下面是一些巧妙利用了LLVM，而又不是在做编译器的研究项目：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="46"><li nodeIndex="45"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="47">UIUC的Virtual Ghost，展示了你可以用编译器来保护挂掉的系统内核中的进程。</p></li><li nodeIndex="48"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="49">UW的CoreDet利用LLVM实现了多线程程序的确定性。</p></li><li nodeIndex="50"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="51">在我们的近似计算工作中，我们使用LLVM流程来给程序注入错误信息，以模仿一些易出错的硬件。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="52">重要的话说三遍：LLVM不是只用来实现编译优化的！LLVM不是只用来实现编译优化的！LLVM不是只用来实现编译优化的！</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><a class="target-fix" nodeIndex="441"></a></p><h3 nodeIndex="54">组成部分</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55">LLVM架构的主要组成部分如下（事实上也是所有现代编译器架构）：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="56">前端，流程（Pass），后端</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="57"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="58">下面分别来解释：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="60"><li nodeIndex="59"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="61">前端获取你的源代码然后将它转变为某种中间表示。这种翻译简化了编译器其他部分的工作，这样它们就不需要面对比如C++源码的所有复杂性了。作为一个豪迈人，你很可能不想再做这部分工作；可以不加改动地使用Clang来完成。</p></li><li nodeIndex="62"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="63">“流程”将程序在中间表示之间互相变换。一般情况下，流程也用来优化代码：流程输出的（中间表示）程序和它输入的（中间表示）程序相比在功能上完全相同，只是在性能上得到改进。这部分通常是给你发挥的地方。你的研究工具可以通过观察和修改编译过程流中的IR来完成任务。</p></li><li nodeIndex="64"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="65">后端部分可以生成实际运行的机器码。你几乎肯定不想动这部分了。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="66">虽然当今大多数编译器都使用了这种架构，但是LLVM有一点值得注意而与众不同：整个过程中，程序都使用了同一种中间表示。在其他编译器中，可能每一个流程产出的代码都有一种独特的格式。LLVM在这一点上对hackers大为有利。我们不需要担心我们的改动该插在哪个位置，只要放在前后端之间某个地方就足够了。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="67"><a class="target-fix" nodeIndex="442"></a></p><h3 nodeIndex="68">开始</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="69">让我们开干吧。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="70"><a class="target-fix" nodeIndex="443"></a></p><h4 nodeIndex="444">获取LLVM</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="71">首先需要安装LLVM。Linux的诸发行版中一般已经装好了LLVM和Clang的包，你直接用便是。但你还是需要确认一下机子里的版本，是不是有所有你要用到的头文件。在OS X系统中，和XCode一起安装的LLVM就不是那么完整。还好，用CMake从源码构建LLVM也没有多难。通常你只需要构建LLVM本身，因为你的系统提供的Clang已经够用（只要版本是匹配的，如果不是，你也可以自己构建Clang）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="72">具体在OS X上，Brandon Holt有一个不错的指导文章。用Homebrew也可以安装LLVM。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="73"><a class="target-fix" nodeIndex="445"></a></p><h4 nodeIndex="446">去读手册</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="74">你需要对文档有所了解。我找到了一些值得一看的链接：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="76"><li nodeIndex="75"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="77"><a target="_blank">自动生成的Doxygen文档页</a>非常重要。要想搞定LLVM，你必须要以这些API的文档维生。这些页面可能不太好找，所以我推荐你直接用Google搜索。只要你在搜索的函数或者类名后面加上“LLVM”，你一般就可以用Google找到正确的文档页面了。（如果你够勤奋，你甚至可以“训练”你的Google，使得在不输入LLVM的情况下它也可以把LLVM的相关结果推到最前面）虽然听上去有点逗，不过你真的需要这样找LLVM的API文档——反正我没找到其他的好方法。</p></li><li nodeIndex="78"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="79"><a target="_blank">《语言参考手册》</a>也非常有用，如果你曾被LLVM IR dump里面的语法搞糊涂的话。</p></li><li nodeIndex="80"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="81"><a target="_blank">《开发者手册》</a>描述了一些LLVM特有的数据结构的工具，比如高效字符串，vector和map的替代品等等。它还描述了一些快速类型检查工具 <code>isa</code>、<code>cast</code>和<code>dyn_cast</code>），这些你不管在哪都要跑。 <br>◾如果你不知道你的流程可以做什么，读<a target="_blank">《编写LLVM流程》</a> 。不过因为你只是个研究人员而不是浸淫于编译器的大牛，本文的观点可能和这篇教程在一些细节上有所不同。（最紧急的是，别再用基于Makefile的构建系统了。直接开始用CMake构建你的程序吧，读读<a target="_blank">《“源代码外”指令》</a>）尽管上面这些是解决流程问题的官方材料，</p></li><li nodeIndex="82"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83">不过在在线浏览LLVM代码时，这个<a target="_blank">GitHub镜像</a>有时会更方便。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="84"><a class="target-fix" nodeIndex="447"></a></p><h3 nodeIndex="85">写一个流程</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="86">使用LLVM来完成高产研究通常意味着你要写一些自定义流程。这一节会指导你构建和运行一个简单的流程来变换你的程序。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="87"><a class="target-fix" nodeIndex="448"></a></p><h4 nodeIndex="449">框架</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="88">我已经准备好了<a target="_blank" nodeIndex="450">模板仓库</a>，里面有些没用的LLVM流程。我推荐先用这个模板。因为如果完全从头开始，配好构建的配置文件可是相当痛苦的事。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="89">首先从GitHub上下载<a target="_blank" nodeIndex="451">llvm-pass-skeleton仓库</a>：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="90"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="92"><li nodeIndex="91"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="93"><code><span class="pln">$ git clone git@github</span><span class="pun">.</span><span class="pln">com</span><span class="pun">:</span><span class="pln">sampsyo</span><span class="pun">/</span><span class="pln">llvm</span><span class="pun">-</span><span class="kwd">pass</span><span class="pun">-</span><span class="pln">skeleton</span><span class="pun">.</span><span class="pln">git</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="94">主要的工作都是在<code nodeIndex="452">skeleton/Skeleton.cpp</code>中完成的。把它打开。这里是我们的业务逻辑：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="95"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="97"><li nodeIndex="96"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="98"><code><span class="kwd">virtual</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> runOnFunction</span><span class="pun">(</span><span class="typ">Function</span><span class="pln"> </span><span class="pun">&</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span></code></p></li><li nodeIndex="99"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100"><code><span class="pln">Ferrs</span><span class="pun">()</span><span class="pln"> </span><span class="pun"><<</span><span class="pln"> </span><span class="str">"I saw a function called "</span><span class="pln"> </span><span class="pun"><<</span><span class="pun">.</span><span class="pln">FgetName</span><span class="pun">()</span><span class="pln"> </span><span class="pun"><<</span><span class="pln"> </span><span class="str">"!\n"</span><span class="pun">;</span></code></p></li><li nodeIndex="101"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="102"><code><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> </span></code></p></li><li nodeIndex="103"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="104"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="105">LLVM流程有很多种，我们现在用的这一种叫<a target="_blank" nodeIndex="453">函数流程（function pass）</a>（这是一个不错的入手点）。正如你所期望的，LLVM会在编译每个函数的时候先唤起这个方法。现在它所做的只是打印了一下函数名。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="106">细节：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="108"><li nodeIndex="107"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="109">errs()是一个LLVM提供的C++输出流，我们可以用它来输出到控制台。</p></li><li nodeIndex="110"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="111">函数返回false说明它没有改动函数F。之后，如果我们真的变换了程序，我们需要返回一个true。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="112"><a class="target-fix" nodeIndex="454"></a></p><h4 nodeIndex="455">构建</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="113">通过CMake来构建这个流程：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="114"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="116"><li nodeIndex="115"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="117"><code><span class="pln">$ cd llvm</span><span class="pun">-</span><span class="kwd">pass</span><span class="pun">-</span><span class="pln">skeleton </span></code></p></li><li nodeIndex="118"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="119"><code><span class="pln">$ mkdir build </span></code></p></li><li nodeIndex="120"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="121"><code><span class="pln">$ cd build </span></code></p></li><li nodeIndex="122"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="123"><code><span class="pln">$ cmake </span><span class="pun">..</span><span class="pln">  </span><span class="com"># Generate the Makefile. </span></code></p></li><li nodeIndex="124"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="125"><code><span class="pln">$ make  </span><span class="com"># Actually build the pass.</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="126">如果LLVM没有全局安装,你需要告诉CMake LLVM的位置.你可以把环境变量<code nodeIndex="456">LLVM_DIR</code>的值修改为通往<code nodeIndex="457">share/llvm/cmake/</code>的路径。比如这是一个使用Homebrew安装LLVM的例子：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="127"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="129"><li nodeIndex="128"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="130"><code><span class="pln">$ LLVM_DIR</span><span class="pun">=</span><span class="str">/usr/</span><span class="kwd">local</span><span class="pun">/</span><span class="pln">opt</span><span class="pun">/</span><span class="pln">llvm</span><span class="pun">/</span><span class="pln">share</span><span class="pun">/</span><span class="pln">llvm</span><span class="pun">/</span><span class="pln">cmake cmake </span><span class="pun">..</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="131">构建流程之后会产生一个库文件，你可以在<code nodeIndex="458">build/skeleton/libSkeletonPass.so</code>或者类似的地方找到它，具体取决于你的平台。下一步我们载入这个库来在真实的代码中运行这个流程。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="132"><a class="target-fix" nodeIndex="459"></a></p><h4 nodeIndex="460">运行</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="133">想要运行你的新流程，用<code nodeIndex="461">clang</code>编译你的C代码，同时加上一些奇怪的flag来指明你刚刚编译好的库文件：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="134"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="136"><li nodeIndex="135"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="137"><code><span class="pln">$ clang </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> </span><span class="pun">-</span><span class="pln">load </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> build</span><span class="pun">/</span><span class="pln">skeleton</span><span class="pun">/</span><span class="pln">libSkeletonPass</span><span class="pun">.*</span><span class="pln"> something</span><span class="pun">.</span><span class="pln">c </span></code></p></li><li nodeIndex="138"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="139"><code><span class="pln">I saw a </span><span class="kwd">function</span><span class="pln"> called main</span><span class="pun">!</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="140"><code nodeIndex="462">-Xclang -load -Xclang path/to/lib.so</code>这是你在Clang中载入并激活你的流程所用的所有代码。所以当你处理较大的项目的时候，你可以直接把这些参数加到Makefile的CFLAGS里或者你构建系统的对应的地方。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="141">（通过单独调用<code nodeIndex="463">clang</code>，你也可以每次只跑一个流程。这样需要用LLVM的opt命令。这是<a target="_blank" nodeIndex="464">官方文档里的合法方式</a>，但在这里我就不赘述了。）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="142">恭喜你，你成功hack了一个编译器！接下来，我们要扩展这个hello world水平的流程，来做一些好玩的事情。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="143"><a class="target-fix" nodeIndex="465"></a></p><h3 nodeIndex="144">理解LLVM的中间表示</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="145">想要使用LLVM里的程序，你需要知道一点中间表示的组织方法。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="146"></p><blockquote nodeIndex="147"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="148">模块（Module），函数（Function），代码块（BasicBlock），指令（Instruction） <br nodeIndex="466"><a target="_blank" nodeIndex="467">模块</a>包含了<a target="_blank" nodeIndex="468">函数</a>，函数又包含了<a target="_blank" nodeIndex="469">代码块</a>，后者又是由<a target="_blank" nodeIndex="470">指令</a>组成。除了模块以外，所有结构都是从<a target="_blank" nodeIndex="471">值</a>产生而来的。</p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="149"><a class="target-fix" nodeIndex="472"></a></p><h4 nodeIndex="473">容器</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="150">首先了解一下LLVM程序中最重要的组件： </p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="152"><li nodeIndex="151"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="153">粗略地说，模块表示了一个源文件，或者学术一点讲叫翻译单元。其他所有东西都被包含在模块之中。 </p></li><li nodeIndex="154"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="155">最值得注意的是，模块容纳了函数，顾名思义，后者就是一段段被命名的可执行代码。（在C++中，函数function和方法method都相应于LLVM中的函数。） </p></li><li nodeIndex="156"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="157">除了声明名字和参数之外，函数主要会做为代码块的容器。代码块和它在编译器中的概念差不多，不过目前我们把它看做是一段连续的指令。 </p></li><li nodeIndex="158"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="159">而说到指令，就是一条单独的代码命令。这一种抽象基本上和RISC机器码是类似的：比如一个指令可能是一次整数加法，可能是一次浮点数除法，也可能是向内存写入。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="160">大部分LLVM中的内容——包括函数，代码块，指令——都是继承了一个名为值的基类的C++类。值是可以用于计算的任何类型的数据，比如数或者内存地址。全局变量和常数（或者说字面值，立即数，比如5）都是值。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="161"><a class="target-fix" nodeIndex="474"></a></p><h4 nodeIndex="475">指令</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="162">这是一个写成人类可读文本的LLVM中间表示的指令的例子。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="163"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="165"><li nodeIndex="164"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="166"><code><span class="pun">%</span><span class="lit">5</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> add i32 </span><span class="pun">%</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="167">这个指令将两个32位整数相加（可以通过类型<code nodeIndex="476">i32</code>推断出来）。它将4号寄存器（写作<code nodeIndex="477">%4</code>）中的数和字面值2（写作<code nodeIndex="478">2</code>）求和，然后放到5号寄存器中。这就是为什么我说LLVM IR读起来像是RISC机器码：我们甚至连术语都是一样的，比如寄存器，不过我们在LLVM里有无限多个寄存器。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="168">在编译器内，这条指令被表示为<a target="_blank" nodeIndex="479">指令</a>C++类的一个实例。这个对象有一个操作码表示这是一次加法，一个类型，以及一个操作数的列表，其中每个元素都指向另外一个值（Value）对象。在我们的例子中，它指向了一个代表整数2的<a target="_blank" nodeIndex="480">常量</a>对象和一个代表5号寄存器的<a target="_blank" nodeIndex="481">指令</a>对象。（因为LLVM IR使用了<a target="_blank" nodeIndex="482">静态单次分配格式</a>，寄存器和指令事实上是一个而且是相同的，寄存器号是人为的字面表示。）</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="169">另外，如果你想看你自己程序的LLVM IR，你可以直接使用Clang：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="170"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="172"><li nodeIndex="171"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="173"><code><span class="pln">$ clang </span><span class="pun">-</span><span class="pln">emit</span><span class="pun">-</span><span class="pln">llvm </span><span class="pun">-</span><span class="pun">-</span><span class="pln">o </span><span class="pun">-</span><span class="pln">Ssomething</span><span class="pun">.</span><span class="pln">c</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="174"><a class="target-fix" nodeIndex="483"></a></p><h4 nodeIndex="484">查看流程中的IR</h4><p class=" _RIL_KEEPER_CLASS_" nodeIndex="175">让我们回到我们正在做的LLVM流程。我们可以查看所有重要的IR对象，只需要用一个普适而方便的方法：<code nodeIndex="485">dump()</code>。它会打印出人可读的IR对象的表示。因为我们的流程是处理函数的，所以我们用它来迭代函数里所有的代码块，然后是每个代码块的指令集。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="176">下面是代码。你可以通过在<code nodeIndex="486">llvm-pass-skeleton</code>代码库中切换到<a target="_blank" nodeIndex="487">containers分支</a>来获得代码。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="177"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="179"><li nodeIndex="178"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="180"><code><span class="pln">errs</span><span class="pun">()</span><span class="pln"> </span><span class="pun"><<</span><span class="pln"> </span><span class="str">"Function body:\n"</span><span class="pun">;</span></code></p></li><li nodeIndex="181"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="182"><code><span class="pun">.</span><span class="kwd">Fdump</span><span class="pun">();</span><span class="pln"> </span></code></p></li><li nodeIndex="183"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="184"><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> F</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span></code></p></li><li nodeIndex="185"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="186"><code><span class="pln">Berrs</span><span class="pun">()</span><span class="pln"> </span><span class="pun"><<</span><span class="pln"> </span><span class="str">"Basic block:\n"</span><span class="pun">;</span></code></p></li><li nodeIndex="187"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="188"><code><span class="pun">.</span><span class="kwd">Bdump</span><span class="pun">();</span><span class="pln"> </span></code></p></li><li nodeIndex="189"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="190"><code><span class="pln">  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> B</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span></code></p></li><li nodeIndex="191"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="192"><code><span class="pln">Ierrs</span><span class="pun">()</span><span class="pln"> </span><span class="pun"><<</span><span class="pln"> </span><span class="str">"Instruction: "</span><span class="pun">;</span><span class="pln"> </span></code></p></li><li nodeIndex="193"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="194"><code><span class="pun">.</span><span class="kwd">Idump</span><span class="pun">();</span><span class="pln">  </span></code></p></li><li nodeIndex="195"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="196"><code><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span></code></p></li><li nodeIndex="197"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="198"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="199">使用C++ 11里的<code nodeIndex="488">auto</code>类型和foreach语法可以方便地在LLVM IR的继承结构里探索。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="200">如果你重新构建流程并通过它再跑程序，你可以看到很多IR被切分开输出，正如我们遍历它那样。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="201"><a class="target-fix" nodeIndex="489"></a></p><h3 nodeIndex="202">做些更有趣的事</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="203">当你在找寻程序中的一些模式，并有选择地修改它们时，LLVM的魔力真正展现了出来。这里是一个简单的例子：把函数里第一个二元操作符（比如+，-）改成乘号。听上去很有用对吧？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="204">下面是代码。这个版本的代码，和一个可以试着跑的示例程序一起，放在了<code nodeIndex="490">llvm-pass-skeleton</code>仓库的 <a target="_blank" nodeIndex="491">mutate分支</a>。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="205"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="207"><li nodeIndex="206"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="208"><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> F</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="209"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="210"><code><span class="pln">  </span><span class="kwd">Bfor</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> B</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="211"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="212"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">Iauto</span><span class="pun">*</span><span class="pln"> op </span><span class="pun">=</span><span class="pln"> dyn_cast</span><span class="pun"><</span><span class="typ">BinaryOperator</span><span class="pun">>(&</span><span class="pln">I</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="213"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="214"><code><span class="pln">      </span><span class="com">// Insert at the point where the instruction `op` appears.</span></code></p></li><li nodeIndex="215"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="216"><code><span class="pln">      </span><span class="typ">IRBuilder</span><span class="pun"><></span><span class="pln"> builder</span><span class="pun">(</span><span class="pln">op</span><span class="pun">);</span></code></p></li><li nodeIndex="217"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="218"><code></code></p></li><li nodeIndex="219"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="220"><code><span class="pln">      </span><span class="com">// Make a multiply with the same operands as `op`.</span></code></p></li><li nodeIndex="221"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="222"><code><span class="pln">      </span><span class="typ">Value</span><span class="pun">*</span><span class="pln"> lhs </span><span class="pun">=</span><span class="pln"> op</span><span class="pun">-></span><span class="pln">getOperand</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span></code></p></li><li nodeIndex="223"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="224"><code><span class="pln">      </span><span class="typ">Value</span><span class="pun">*</span><span class="pln"> rhs </span><span class="pun">=</span><span class="pln"> op</span><span class="pun">-></span><span class="pln">getOperand</span><span class="pun">(</span><span class="lit">1</span><span class="pun">);</span></code></p></li><li nodeIndex="225"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="226"><code><span class="pln">      </span><span class="typ">Value</span><span class="pun">*</span><span class="pln"> mul </span><span class="pun">=</span><span class="pln"> builder</span><span class="pun">.</span><span class="typ">CreateMul</span><span class="pun">(</span><span class="pln">lhs</span><span class="pun">,</span><span class="pln"> rhs</span><span class="pun">);</span></code></p></li><li nodeIndex="227"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="228"><code></code></p></li><li nodeIndex="229"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="230"><code><span class="pln">      </span><span class="com">// Everywhere the old instruction was used as an operand, use our</span></code></p></li><li nodeIndex="231"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="232"><code><span class="pln">      </span><span class="com">// new multiply instruction instead.</span></code></p></li><li nodeIndex="233"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="234"><code><span class="pln">      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> op</span><span class="pun">-></span><span class="pln">Uuses</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="235"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="236"><code><span class="pln">        </span><span class="typ">User</span><span class="pun">*</span><span class="pln"> user </span><span class="pun">=</span><span class="pun">.</span><span class="pln">UgetUser</span><span class="pun">();</span><span class="pln">  </span><span class="com">// A User is anything with operands.</span></code></p></li><li nodeIndex="237"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="238"><code><span class="pln">        user</span><span class="pun">-></span><span class="pln">setOperand</span><span class="pun">(</span><span class="pun">.</span><span class="pln">UgetOperandNo</span><span class="pun">(),</span><span class="pln"> mul</span><span class="pun">);</span></code></p></li><li nodeIndex="239"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="240"><code><span class="pln">      </span><span class="pun">}</span></code></p></li><li nodeIndex="241"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="242"><code></code></p></li><li nodeIndex="243"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="244"><code><span class="pln">      </span><span class="com">// We modified the code.</span></code></p></li><li nodeIndex="245"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="246"><code><span class="pln">      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span></code></p></li><li nodeIndex="247"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="248"><code><span class="pln">    </span><span class="pun">}</span></code></p></li><li nodeIndex="249"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="250"><code><span class="pln">  </span><span class="pun">}</span></code></p></li><li nodeIndex="251"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="252"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="253">细节如下：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="255"><li nodeIndex="254"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="256"><code>dyn_cast<T>(p)</code>构造函数是<a target="_blank">LLVM类型检查工具</a>的应用。使用了LLVM代码的一些惯例,使得动态类型检查更高效，因为编译器总要用它们。具体来说，如果<code>I</code>不是“二元操作符”，这个构造函数返回一个空指针，就可以完美应付很多特殊情况（比如这个）。</p></li><li nodeIndex="257"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="258">IRBuilder用于构造代码。它有一百万种方法来创建任何你可能想要的指令。</p></li><li nodeIndex="259"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="260">为把新指令缝进代码里，我们需要找到所有它被使用的地方，然后当做一个参数换进我们的指令里。回忆一下，每个指令都是一个值：在这里，乘法指令被当做另一条指令里的操作数，意味着乘积会成为被传进来的参数。</p></li><li nodeIndex="261"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="262">我们其实应该移除旧的指令，不过简明起见我把它略去了。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="263">现在我们编译一个这样的程序（代码库中的<a target="_blank" nodeIndex="492">example.c</a>）：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="264"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="266"><li nodeIndex="265"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="267"><code><span class="com">#include</span><span class="pln"> </span><span class="str"><stdio.h></span></code></p></li><li nodeIndex="268"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="269"><code><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">**</span><span class="pln"> argv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="270"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="271"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> num</span><span class="pun">;</span></code></p></li><li nodeIndex="272"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="273"><code><span class="pln">    scanf</span><span class="pun">(</span><span class="str">"%i"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&</span><span class="pln">num</span><span class="pun">);</span></code></p></li><li nodeIndex="274"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="275"><code><span class="pln">    printf</span><span class="pun">(</span><span class="str">"%i\n"</span><span class="pun">,</span><span class="pln"> num </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span></code></p></li><li nodeIndex="276"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="277"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></p></li><li nodeIndex="278"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="279"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="280">如果用普通的编译器，这个程序的行为和代码并没有什么差别；但我们的插件会让它将输入翻倍而不是加2。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="281"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="283"><li nodeIndex="282"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="284"><code><span class="pln">$ cc example</span><span class="pun">.</span></code></p></li><li nodeIndex="285"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="286"><code><span class="pln">$ </span><span class="pun">./</span><span class="pun">.</span><span class="kwd">acout</span></code></p></li><li nodeIndex="287"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="288"><code><span class="lit">10</span></code></p></li><li nodeIndex="289"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="290"><code><span class="lit">12</span></code></p></li><li nodeIndex="291"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="292"><code><span class="pln">$ clang </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> </span><span class="pun">-</span><span class="pln">load </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> build</span><span class="pun">/</span><span class="pln">skeleton</span><span class="pun">/</span><span class="pln">libSkeletonPass</span><span class="pun">.</span><span class="pln">so example</span><span class="pun">.</span></code></p></li><li nodeIndex="293"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="294"><code><span class="pln">$ </span><span class="pun">./</span><span class="pun">.</span><span class="kwd">acout</span></code></p></li><li nodeIndex="295"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="296"><code><span class="lit">10</span></code></p></li><li nodeIndex="297"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="298"><code><span class="lit">20</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="299">很神奇吧！</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="300"><a class="target-fix" nodeIndex="493"></a></p><h3 nodeIndex="301">链接动态库</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="302">如果你想调整代码做一些大动作，用<a target="_blank" nodeIndex="494">IRBuilder</a>来生成LLVM指令可能就比较痛苦了。你可能需要写一个C语言的运行时行为，然后把它链接到你正在编译的程序上。这一节将会给你展示如何写一个运行时库，它可以将所有二元操作的结果记录下来，而不仅仅是闷声修改值。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="303">这里是LLVM流程的代码，也可以在<code nodeIndex="495">llvm-pass-skeleton</code>代码库的<a target="_blank" nodeIndex="496">rtlib分支</a>找到它。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="304"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="306"><li nodeIndex="305"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="307"><code><span class="com">// Get the function to call from our runtime library.</span></code></p></li><li nodeIndex="308"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="309"><code><span class="typ">LLVMContext</span><span class="pun">&</span><span class="pln"> </span><span class="typ">Ctx</span><span class="pln"> </span><span class="pun">=</span><span class="pun">.</span><span class="pln">FgetContext</span><span class="pun">();</span></code></p></li><li nodeIndex="310"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="311"><code><span class="typ">Constant</span><span class="pun">*</span><span class="pln"> logFunc </span><span class="pun">=</span><span class="pun">.</span><span class="pln">FgetParent</span><span class="pun">()-></span><span class="pln">getOrInsertFunction</span><span class="pun">(</span></code></p></li><li nodeIndex="312"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="313"><code><span class="pln">  </span><span class="str">"logop"</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Type</span><span class="pun">::</span><span class="pln">getVoidTy</span><span class="pun">(</span><span class="typ">Ctx</span><span class="pun">),</span><span class="pln"> </span><span class="typ">Type</span><span class="pun">::</span><span class="pln">getInt32Ty</span><span class="pun">(</span><span class="typ">Ctx</span><span class="pun">),</span><span class="pln"> NULL</span></code></p></li><li nodeIndex="314"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="315"><code><span class="pun">);</span></code></p></li><li nodeIndex="316"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="317"><code></code></p></li><li nodeIndex="318"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="319"><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> F</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="320"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="321"><code><span class="pln">  </span><span class="kwd">Bfor</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&</span><span class="pun">:</span><span class="pln"> B</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="322"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="323"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">Iauto</span><span class="pun">*</span><span class="pln"> op </span><span class="pun">=</span><span class="pln"> dyn_cast</span><span class="pun"><</span><span class="typ">BinaryOperator</span><span class="pun">>(&</span><span class="pln">I</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="324"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="325"><code><span class="pln">      </span><span class="com">// Insert *after* `op`.</span></code></p></li><li nodeIndex="326"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="327"><code><span class="pln">      </span><span class="typ">IRBuilder</span><span class="pun"><></span><span class="pln"> builder</span><span class="pun">(</span><span class="pln">op</span><span class="pun">);</span></code></p></li><li nodeIndex="328"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="329"><code><span class="pln">      builder</span><span class="pun">.</span><span class="typ">SetInsertPoint</span><span class="pun">(&</span><span class="pun">,</span><span class="pln"> </span><span class="pun">++</span><span class="pln">Bbuilder</span><span class="pun">.</span><span class="typ">GetInsertPoint</span><span class="pun">());</span></code></p></li><li nodeIndex="330"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="331"><code></code></p></li><li nodeIndex="332"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="333"><code><span class="pln">      </span><span class="com">// Insert a call to our function.</span></code></p></li><li nodeIndex="334"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="335"><code><span class="pln">      </span><span class="typ">Value</span><span class="pun">*</span><span class="pln"> args</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">op</span><span class="pun">};</span></code></p></li><li nodeIndex="336"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="337"><code><span class="pln">      builder</span><span class="pun">.</span><span class="typ">CreateCall</span><span class="pun">(</span><span class="pln">logFunc</span><span class="pun">,</span><span class="pln"> args</span><span class="pun">);</span></code></p></li><li nodeIndex="338"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="339"><code></code></p></li><li nodeIndex="340"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="341"><code><span class="pln">      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span></code></p></li><li nodeIndex="342"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="343"><code><span class="pln">    </span><span class="pun">}</span></code></p></li><li nodeIndex="344"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="345"><code><span class="pln">  </span><span class="pun">}</span></code></p></li><li nodeIndex="346"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="347"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="348">你需要的工具包括<a target="_blank" nodeIndex="497">Module::getOrInsertFunction</a>和<a target="_blank" nodeIndex="498">IRBuilder::CreateCall</a>。前者给你的运行时函数<code nodeIndex="499">logop</code>增加了一个声明（类似于在C程序中声明<code nodeIndex="500">void logop(int i);</code>而不提供实现）。相应的函数体可以在定义了<code nodeIndex="501">logop</code>函数的运行时库（代码库中的<a target="_blank" nodeIndex="502">rtlib.c</a>）找到。</p><pre class="prettyprint linenums prettyprinted" nodeIndex="349"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="351"><li nodeIndex="350"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="352"><code><span class="com">#include</span><span class="pln"> </span><span class="str"><stdio.h></span></code></p></li><li nodeIndex="353"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="354"><code><span class="kwd">void</span><span class="pln"> logop</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></p></li><li nodeIndex="355"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="356"><code><span class="pln">iprintf</span><span class="pun">(</span><span class="str">"computed: %i\n"</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">);</span></code></p></li><li nodeIndex="357"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="358"><code><span class="pun">}</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="359">要运行这个程序，你需要链接你的运行时库：</p><pre class="prettyprint linenums prettyprinted" nodeIndex="360"><ol class="linenums list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="362"><li nodeIndex="361"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="363"><code><span class="pln">$ cc </span><span class="pun">-</span><span class="pln">c rtlib</span><span class="pun">.</span><span class="pln">c</span></code></p></li><li nodeIndex="364"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="365"><code><span class="pln">$ clang </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> </span><span class="pun">-</span><span class="pln">load </span><span class="pun">-</span><span class="typ">Xclang</span><span class="pln"> build</span><span class="pun">/</span><span class="pln">skeleton</span><span class="pun">/</span><span class="pln">libSkeletonPass</span><span class="pun">.</span><span class="pln">so </span><span class="pun">-</span><span class="pln">c example</span><span class="pun">.</span><span class="pln">c</span></code></p></li><li nodeIndex="366"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="367"><code><span class="pln">$ cc example</span><span class="pun">.</span><span class="pln">o rtlib</span><span class="pun">.</span></code></p></li><li nodeIndex="368"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="369"><code><span class="pln">$ </span><span class="pun">./</span><span class="pun">.</span><span class="kwd">aoout</span></code></p></li><li nodeIndex="370"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="371"><code><span class="lit">12</span></code></p></li><li nodeIndex="372"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="373"><code><span class="pln">computed</span><span class="pun">:</span><span class="pln"> </span><span class="lit">14</span></code></p></li><li nodeIndex="374"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="375"><code><span class="lit">14</span></code></p></li></ol></pre><p class=" _RIL_KEEPER_CLASS_" nodeIndex="376">如果你希望的话，你也可以在编译成机器码之前就缝合程序和运行时库。llvm-link工具——你可以把它简单看做IR层面的ld的等价工具，可以帮助你完成这项工作。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="377"><a class="target-fix" nodeIndex="503"></a></p><h3 nodeIndex="378">注记（Annotation）</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="379">大部分工程最终是要和开发者进行交互的。你会希望有一套<span nodeIndex="504">注记（annotations）</span>，来帮助你从程序里传递信息给LLVM流程。这里有一些构造注记系统的方法：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="381"><li nodeIndex="380"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="382">一个实用而取巧的方法是使用<span>魔法函数</span>。先在一个头文件里声明一些空函数，用一些奇怪的、基本是独特的名字命名。在源代码中引入这个头文件，然后调用这些什么都没有做的函数。然后，在你的流程里，查找唤起了函数的<a target="_blank">CallInst指令</a>，然后利用它们去触发你真正要做的“魔法”。比如说，你可能想调用<code>__enable_instrumentation()</code>和<code>__disable_instrumentation()</code>，让程序将代码改写限制在某些具体的区域。</p></li><li nodeIndex="383"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="384">如果想让程序员给函数或者变量声明加记号，Clang的<code>__attribute__((annotate("foo")))</code>语法会发射一个<a target="_blank">元数据</a>和任意字符串，可以在流程中处理它。Brandon Holt（又是他）有篇<a target="_blank">文章</a>讲解了这个技术的背景。如果你想标记一些表达式，而非声明，一个没有文档，同时很不幸受限了的<code>__builtin_annotation(e, "foo")</code><a target="_blank">内建方法</a>可能会有用。</p></li><li nodeIndex="385"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="386">可以自由修改Clang使它可以翻译你的新语法。不过我不推荐这个。</p></li><li nodeIndex="387"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="388">如果你需要标记类型——我相信大家经常没意识到就这么做了——我开发了一个名为<a target="_blank">Quala</a>的系统。它给Clang打了补丁，以支持自定义的类型检查和可插拔的类型系统，到Java的<a target="_blank">JSR-308</a>。如果你对这个项目感兴趣，并且想合作，请联系我。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="389">我希望能在以后的文章里展开讨论这些技术。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="390"><a class="target-fix" nodeIndex="505"></a></p><h3 nodeIndex="391">其他</h3><p class=" _RIL_KEEPER_CLASS_" nodeIndex="392">LLVM非常庞大。下面是一些我没讲到的话题：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="394"><li nodeIndex="393"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="395">使用LLVM中的一大批古典编译器分析；</p></li><li nodeIndex="396"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="397">通过hack后端来生成任意的特殊机器指令（架构师们经常想这么干）；</p></li><li nodeIndex="398"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="399">利用<a target="_blank">debug info</a>连接源代码中的行和列到IR中的每一处；</p></li><li nodeIndex="400"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="401">开发[Clang前端插件]。(<a target="_blank">http://clang.llvm.org/docs/ClangPlugins.html</a>)</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="402">我希望我给你讲了足够的背景来支持你完成一个好项目了。探索构建去吧！如果这篇文章对你帮助，也请<a target="_blank" nodeIndex="506">让我知道</a>。</p><hr nodeIndex="507"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="403">感谢UW的架构与系统组，围观了我的这篇文章并且提了很多很赞的问题。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="404">以及感谢以下的读者：</p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="406"><li nodeIndex="405"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="407"><a target="_blank">Emery Berger</a>指出了动态二进制分析工具，比如Pin，仍然是你在观察系统结构中具体内容（比如寄存器，内存继承和指令编码等）的好帮手；</p></li><li nodeIndex="408"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="409"><a target="_blank">Brandon Holt</a>发了一篇<a target="_blank">《LLVM debug 技巧》</a>，包括如何用GraphViz绘制控制流图；</p></li><li nodeIndex="410"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="411"><a target="_blank">John Regehr</a>在评论中提到把软件搭在LLVM上的缺点：API不稳定性。LLVM内部几乎每版都要大换，所以你需要不断维护你的项目。<a target="_blank">Alex Bradbury</a>的<a target="_blank">LLVM周报</a>是个跟进LLVM生态圈的好资源。</p></li></ul><p class="copyright _RIL_KEEPER_CLASS_" nodeIndex="412"><span class="z" nodeIndex="508">原文：<a target="_blank" nodeIndex="509">http://adriansampson.net/blog/llvm.html</a></span><span class="y" nodeIndex="510">作者： Adrian Sampson</span><br class="clear" nodeIndex="511"><span class="z" nodeIndex="512">译文：<a target="_blank" nodeIndex="513">http://geek.csdn.net/news/detail/37785</a></span><span class="y" nodeIndex="514">译者： 张洵恺</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="413"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2015-08-26-1019821197/1"/></div><br nodeIndex="515"></p>
                </div>
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" nodeIndex="414"></div>

                
                                <p id="js_preview_reward_wording" class="tips_global reward_tips _RIL_KEEPER_CLASS_" nodeIndex="416"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="417">
                        <a class="reward_access" id="js_preview_reward_link" href=""><span class="icon-reward"></span>赞赏</a>

                    </p>
                <p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="419">长按二维码向我转账</p><p id="js_preview_reward_ios_wording" class="reward_tips _RIL_KEEPER_CLASS_" nodeIndex="420"></p><p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="421">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2015-08-26-1019821197/2"/></div>
                            </div>
                        
                        


                    </div>