---
layout: post
title: Keyless SSL: The Nitty Gritty Technical Details
categories:
- Pocket
tags:
---
原文地址：https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/

收藏时间：2017-06-30 06:36:41

<div  lang="en">
<div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/1"/></div>
<p nodeIndex="22">We announced <a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" nodeIndex="238">Keyless SSL</a> yesterday to an overwhelmingly positive response. We read through the comments on this blog, <a href="http://www.reddit.com/r/programming/comments/2grd1d/cloudflare_annouces_keyless_ssl/" nodeIndex="239">Reddit</a>, <a href="https://news.ycombinator.com/item?id=8334933" nodeIndex="240">Hacker News</a>, and people seem interested in knowing more and getting deeper into the technical details. In this blog post we go into extraordinary detail to answer questions about how Keyless SSL was designed, how it works, and why it’s secure. Before we do so, we need some background about how encryption works on the Internet. If you’re already familiar, feel free to <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/#makingitkeyless" nodeIndex="241">skip ahead</a>.</p>
<h3 id="tls" nodeIndex="23">TLS</h3>
<p nodeIndex="24">Transport Layer Security (TLS) is the workhorse of web security. It lets websites prove their identity to web browsers, and protects all information exchanged from prying eyes using encryption. The TLS protocol has been around for years, but it’s still mysterious to even hardcore tech enthusiasts. Understanding the fundamentals of TLS is the key to understanding Keyless SSL.</p>
<h3 id="dualgoals" nodeIndex="25">Dual goals</h3>
<p nodeIndex="26">TLS has two main goals: confidentiality and authentication. Both are critically important to securely communicating on the Internet.</p>
<p nodeIndex="27">Communication is considered confidential when two parties are confident that nobody else can understand their conversation. Confidentiality can be achieved using symmetric encryption: use a key known only to the two parties involved to encrypt messages before sending them. In TLS, this symmetric encryption is typically done using a strong block cipher like <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard" nodeIndex="242">AES</a>. Older browsers and platforms might use a cipher like <a href="http://en.wikipedia.org/wiki/Triple_DES" nodeIndex="243">Triple DES</a> or the stream cipher <a href="http://en.wikipedia.org/wiki/RC4" nodeIndex="244">RC4</a>, <a href="http://blog.cloudflare.com/killing-rc4-the-long-goodbye/" nodeIndex="245">which is now considered insecure</a>.</p>
<p nodeIndex="28">The other crucial goal of TLS is authentication. Authentication is a way to ensure the person on the other end is who they say they are. This is accomplished with public keys. Websites use certificates and public key cryptography to prove their identity to web browsers. And browsers need two things to trust a certificate: proof that the other party is the owner of the certificate, and proof that the certificate is trusted.</p>
<p nodeIndex="29">A website certificate contains a public key, and if the website can prove that it controls the associated private key, that’s proof that they are the owner of the certificate. A browser considers a certificate trusted if the certificate was granted by a trusted certificate authority, and contains the site’s domain name. More technical details of how trust works with web certificates is described in <a href="http://blog.cloudflare.com/introducing-cfssl/" nodeIndex="246">a previous blog post</a> about our open source SSL toolkit, CFSSL.</p>
<p nodeIndex="30">In the context of the web, confidentiality and authentication are achieved through the process of establishing a shared key and proving ownership of a certificate. TLS does this through a series of messages called a “handshake”.</p>
<h3 id="whatsinahandshake" nodeIndex="31">What’s in a handshake?</h3>
<div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/2"/></div>
<p nodeIndex="33">The TLS protocol evolved from the Secure Sockets Layer (SSL) protocol which was developed by Netscape in the mid-1990s. In 1999, the Internet Engineering Task Force (IETF) standardized a new protocol called TLS, which is an updated version of SSL. In fact, TLS is so similar to SSL that TLS 1.0 uses the SSL protocol version number 3.1. This may seem confusing at first, but makes sense since TLS is just a minor update to SSL 3.0. Subsequent versions of TLS have followed this pattern. Since TLS is an evolution of the SSL protocol, people still use the terms TLS and SSL somewhat interchangeably.</p>
<p nodeIndex="34">There are two main types of handshakes in TLS: one based on <a href="http://en.wikipedia.org/wiki/RSA_(cryptosystem)" nodeIndex="248">RSA</a>, and one based on <a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" nodeIndex="249">Diffie-Hellman</a>. RSA and Diffie-Hellman were the two algorithms which ushered in the era of modern cryptography, and brought cryptography to the masses. These two handshakes differ only in how the two goals of key establishment and authentication are achieved:</p>
<div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/3"/></div>
<p nodeIndex="36">The RSA and DH handshakes both have their advantages and disadvantages. The RSA handshake only uses one public key algorithm operation, RSA. A DH handshake with an RSA certificate requires the same RSA operation, but with an additional DH operation. Given that the certificate is RSA, the RSA handshake is faster to compute. Public key algorithms like RSA and DH use a lot of CPU and are the slowest part of the TLS handshake. A laptop can only perform a couple hundred RSA encryptions a second versus around ten million per second of the symmetric cipher AES.</p>
<p nodeIndex="37">The DH handshake requires two algorithms to run, but the advantage it brings is that it allows key establishment to happen independently of the server’s private key. This gives the connection <a href="http://blog.cloudflare.com/staying-on-top-of-tls-attacks/" nodeIndex="251">forward secrecy</a>, a useful property that protects conversations from being decrypted after the fact if the private key is somehow exposed. The DH version of the handshake also opens up the possibility of using non-RSA certificates that can improve performance, including <a href="http://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/" nodeIndex="252">ECDSA keys</a>. Elliptic curves provide the same security with less computational overhead. A DH handshake with and elliptic curve DSA certificate and elliptic curve Diffie-Hellman key agreement can be faster than a one-operation RSA handshake.</p>
<p nodeIndex="38">CloudFlare supports both handshakes, but, as we will describe later, the type of handshake used is chosen by the server. CloudFlare will choose a DH handshake whenever we can.</p>
<h3 id="tlsglossary" nodeIndex="39">TLS Glossary</h3>
<p nodeIndex="40">Before we walk through the steps of the handshake, here are a couple definitions.</p>
<p nodeIndex="41"><strong nodeIndex="253">1. Session key</strong> This is the end result of a handshake. It’s a key for a symmetric cipher, and allows the client and server to encrypt messages to each other.</p>
<p nodeIndex="42"><strong nodeIndex="254">2. Client random</strong> This is a sequence of 32 bytes created by the client. It’s unique for each connection, and is supposed to contain a four-byte timestamp followed by 28 random bytes. Recently, Google Chrome switched to using 32 bytes of random in order to prevent client fingerprinting. These random values are often called a <a href="http://en.wikipedia.org/wiki/Cryptographic_nonce" nodeIndex="255">nonce</a>.</p>
<p nodeIndex="43"><strong nodeIndex="256">3. Server random</strong> A server random is the same as the client random except generated by the server.</p>
<p nodeIndex="44"><strong nodeIndex="257">4. Pre-master secret</strong> This is a 48-byte blob of data. It can be combined with both the client random and the server random to create the session key using a “pseudorandom function” (PRF).</p>
<p nodeIndex="45"><strong nodeIndex="258">5. Cipher suite</strong> This is a unique identifier for combining algorithms making up a TLS connection. It defines one algorithm for each of the following:</p>
<ul nodeIndex="47"><li nodeIndex="46">key establishment (typically a Diffie-Hellman variant or RSA)</li>
<li nodeIndex="48">authentication (the certificate type)</li>
<li nodeIndex="49">confidentiality (a symmetric cipher)</li>
<li nodeIndex="50">integrity (a hash function)</li>
</ul><p nodeIndex="51">For example “AES128-SHA” defines a session that uses:</p>
<ul nodeIndex="53"><li nodeIndex="52">RSA for key establishment (implied)</li>
<li nodeIndex="54">RSA for authentication (implied)</li>
<li nodeIndex="55">128-bit <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard" nodeIndex="259">Advanced Encryption Standard</a> in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" nodeIndex="260">Cipher Block Chaining (CBC) mode</a> for confidentiality</li>
<li nodeIndex="56">160-bit <a href="http://en.wikipedia.org/wiki/SHA-1" nodeIndex="261">Secure Hashing Algorithm (SHA)</a> for integrity</li>
</ul><p nodeIndex="57">A more daunting, but valid cipher suite is “ECDHE-ECDSA-AES256-GCM-SHA384” which defines a session that uses:</p>
<ul nodeIndex="59"><li nodeIndex="58">Elliptic Curve Diffie-Hellman Ephemeral (<a href="http://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" nodeIndex="262">ECDHE</a>) key exchange for key establishment</li>
<li nodeIndex="60">Elliptic Curve Digital Signature Algorithms (<a href="http://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" nodeIndex="263">ECDSA</a>) for authentication</li>
<li nodeIndex="61">256-bit <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard" nodeIndex="264">Advanced Encryption Standard</a> in <a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode" nodeIndex="265">Galois/Counter mode (GCM)</a> for confidentiality</li>
<li nodeIndex="62">384-bit <a href="http://en.wikipedia.org/wiki/SHA-2" nodeIndex="266">Secure Hashing Algorithm</a> for integrity</li>
</ul><p nodeIndex="63">With these definitions in hand, let’s walk through an RSA handshake.</p>
<h3 id="rsahandshake" nodeIndex="64">RSA handshake</h3>
<p nodeIndex="65">Note that none of the messages in the handshake are encrypted with a session key; they are all sent in the clear.</p>
<div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/4"/></div>
<p nodeIndex="67"><strong nodeIndex="269">Message 1: “Client Hello”</strong></p>
<p nodeIndex="68">The client hello contains the protocol version that the client wants to use, and some other information to get the handshake started including the client random and a list of cipher suites. Modern browsers also include the hostname they are looking for, called the <a href="http://en.wikipedia.org/wiki/Server_Name_Indication" nodeIndex="270">Server Name Indication (SNI)</a>. SNI lets the web server host multiple domains on the same IP address.</p>
<p nodeIndex="69"><strong nodeIndex="271">Message 2: “Server Hello”</strong></p>
<p nodeIndex="70">After receiving the client hello, the server picks the parameters for the handshake going forward. The choice of cipher suite determines what type of handshake is performed. The server “hello” message contains the server random, the server’s chosen cipher suite, and the server’s certificate. The certificate contains the server’s public key and domain name.</p>
<p nodeIndex="71">Note: CloudFlare’s cipher suite preferences are posted publicly on our <a href="https://github.com/cloudflare/sslconfig" nodeIndex="272">Github page</a>.</p>
<p nodeIndex="72"><strong nodeIndex="273">Message 3: “Client Key Exchange”</strong></p>
<p nodeIndex="73">After validating that the certificate is trusted and belongs to the site they are trying to reach, the client creates a random pre-master secret. This secret is encrypted with the public key from the certificate, and sent to the server.</p>
<p nodeIndex="74">Upon receiving this message, the server uses its private key to decrypt this pre-master secret. Now that both sides have the pre-master secret, and both client and server randoms, they can both derive the same session key. Then they exchange a short message to indicate that the next message they send will be encrypted.</p>
<p nodeIndex="75">The handshake is officially complete when the client and server exchange “Finished” messages. The actual text is literally: “client finished” or “server finished” encrypted with the session key. Any subsequent communication between the two parties are encrypted with the session key.</p>
<p nodeIndex="76">This handshake is elegant because it combines key exchange and authentication in one step. The logic is that if the server can correctly derive the session key, then they must have access to the private key, and, therefore, be the owner of the certificate.</p>
<p nodeIndex="77">The downside of this handshake is that the messages secured by it are only as safe as the private key. Suppose a third party has recorded the handshake and the subsequent communication. If that party gets access to the private key in the future, they will be able to decrypt the premaster secret and derive the session key. With that they can decrypt the entire message. This is true even if the certificate is expired or revoked. This leads us to another form of handshake that can provide confidentiality even if the private key is compromised.</p>
<h3 id="ephemeraldiffiehellmanhandshake" nodeIndex="78">Ephemeral Diffie-Hellman handshake</h3>

<p nodeIndex="80">The ephemeral Diffie-Hellman handshake is an alternative form of the TLS handshake. It uses two different mechanisms: one for establishing a shared pre-master secret, and one for authenticating the server. The key feature that this relies on is the Diffie-Hellman key agreement algorithm.</p>
<p nodeIndex="81">In Diffie-Hellman, two parties with different secrets exchange messages to obtain a shared secret. This handshake relies on the simple fact that exponents are commutative. Specifically that taking a number to the power of a, and the result to the power of b, is the same as taking the same number to the power of b, and the result to the power of a.</p>
<p nodeIndex="82">The algorithm works like this:</p>
<ul nodeIndex="84"><li nodeIndex="83">person a has secret a, sends g<sup nodeIndex="275">a</sup> to person b</li>
<li nodeIndex="85">person b has secret b, sends g<sup nodeIndex="276">b</sup> to person a</li>
<li nodeIndex="86">person a computes (g<sup nodeIndex="277">b</sup>)<sup nodeIndex="278">a</sup></li>
<li nodeIndex="87">person b computes (g<sup nodeIndex="279">a</sup>)<sup nodeIndex="280">b</sup></li>
<li nodeIndex="88">Both person a and b end up with g<sup nodeIndex="281">ab</sup>, which is their shared secret</li>
</ul><p nodeIndex="89">This doesn't work well with regular numbers because g<sup nodeIndex="282">ab</sup> can get really large, and there are efficient ways to take the nth root of a number. However, we can change the problem space and make it work. This is done by restricting the computation to numbers of a fixed size by always dividing the result of a computation by big prime number and taking the remainder. This is called modular arithmetic. Taking an nth root in modular arithmetic is called the <a href="http://en.wikipedia.org/wiki/Discrete_logarithm" nodeIndex="283">discrete logarithm problem</a> and is considered a hard problem.</p>
<p nodeIndex="90">Another variant of the Diffie-Hellman key agreement uses Elliptic Curves, ECDHE. For more information on Elliptic Curves, check out <a href="http://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/" nodeIndex="284">this primer</a> we published last year. A shared secret can be derived using either of these fixed-size Diffie-Hellman key agreement algorithms.</p>
<p nodeIndex="91">Now let’s go through a Diffie-Hellman handshake:</p>
<div id="RIL_IMG_5" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/5"/></div>
<p nodeIndex="93"><strong nodeIndex="287">Message 1: “Client Hello”</strong></p>
<p nodeIndex="94">Just like in the RSA case, the client hello contains the protocol version, the client random, a list of cipher suites, and, optionally, the SNI extension. If the client speaks ECDHE, they include the list of curves they support. If this is omitted, or there is a mismatch, it can be <a href="http://terinstock.com/blog/2014/07/02/tls-with-erlang.html" nodeIndex="288">tricky to debug</a>.</p>
<p nodeIndex="95"><strong nodeIndex="289">Message 2: “Server Hello”</strong></p>
<p nodeIndex="96">After receiving the client hello, the server picks the parameters for the handshake going forward, including the curve for ECDHE. The server “hello” message contains the server random, the server’s chosen cipher suite, and the server’s certificate.</p>
<p nodeIndex="97">The RSA and Diffie-Hellman handshakes start to differ at this point with a new message type.</p>
<p nodeIndex="98"><strong nodeIndex="290">Message 3: “Server Key Exchange”</strong></p>
<p nodeIndex="99">In order to start the Diffie-Hellman key exchange, the server needs to pick some starting parameters and send them to the client---this corresponds to the g<sup nodeIndex="291">a</sup> we described above. The server also needs a way to prove that it has control of the private key, so the server computes a digital signature of all the messages up to this point. Both the Diffie-Hellman parameters and the signature are sent in this message.</p>
<p nodeIndex="100"><strong nodeIndex="292">Message 4: “Client Key Exchange”</strong></p>
<p nodeIndex="101">After validating that the certificate is trusted, and belongs to the site they are trying to reach, the client validates the digital signature sent from the server. They also send the client half of the Diffie-Hellman handshake (corresponding to g<sup nodeIndex="293">b</sup> above).</p>
<p nodeIndex="102">At this point, both sides can compute the pre-master secret from the Diffie-Hellman parameters (corresponding to g<sup nodeIndex="294">ab</sup> above). With the pre-master secret and both client and server randoms, they can derive the same session key. They then exchange a short message to indicate that they the next message they send will be encrypted.</p>
<p nodeIndex="103">Just like in the RSA handshake, this handshake is officially complete when the client and server exchange “Finished” messages. Any subsequent communication between the two parties are encrypted with the session key.</p>
<h3 id="makingitkeyless" nodeIndex="104">Making it keyless</h3>
<p nodeIndex="105">Yesterday we announced <a href="http://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" nodeIndex="295">Keyless SSL</a>, CloudFlare’s solution that allows sites to use CloudFlare without requiring them to give up custody of their private keys.</p>
<p nodeIndex="106">One takeaway from the handshake diagrams above is that the private key is only used once in each handshake. This allows us to split the TLS handshake geographically, with most of the handshake happening at CloudFlare’s edge while moving the private key operations to a remote key server. This key server can be put on the customer’s infrastructure, giving them exclusive access to the private key.</p>
<p nodeIndex="107">Once the secure tunnel is established, the RSA handshake looks like this:</p>
<div id="RIL_IMG_6" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/6"/></div>
<p nodeIndex="109">The DH handshake looks like this:</p>
<div id="RIL_IMG_7" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/7"/></div>
<p nodeIndex="111">Extending the TLS handshake in this way required changes to the NGINX server and OpenSSL to make the private key operation both remote and non-blocking (so NGINX can continue with other requests while waiting for the key server). Both the NGINX/OpenSSL changes, the protocol between the CloudFlare’s server, and the key server were audited by iSEC Partners and Matasano Security. They found the security of Keyless SSL equivalent to on-premise SSL. Keyless SSL has also been studied by academic researchers from both provable security and performance angles.</p>
<p nodeIndex="112">The key server can run on Linux (packaged for Red Hat/CentOS, Debian and Ubuntu, and others), other UNIX operating systems (including FreeBSD), and Microsoft Windows Server. Customers also get access to a <a href="https://github.com/cloudflare/keyless" nodeIndex="300">reference implementation</a> written in C, so they can build their own compatible key server.</p>
<p nodeIndex="113">The key server will soon be integrated with hardware security module (HSM) vendors and key management solutions (such as Venafi) to provide customers with additional ways to control how the keys are managed in their infrastructure.</p>
<p nodeIndex="114">Keyless SSL supports multiple key servers for the same certificate. Key servers are stateless, allowing customers to use off-the-shelf hardware and scale the deployment of key servers linearly with traffic. By running multiple key servers and load balancing via DNS, the customer’s site can be kept highly available.</p>
<h3 id="protectingtheoracle" nodeIndex="115">Protecting the oracle</h3>
<div id="RIL_IMG_8" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/8"/></div>
<p nodeIndex="117">For Keyless SSL to be secure, the connection from CloudFlare’s edge to the key server also needs to be secure. The key server can act as a cryptographic oracle by performing private key operations for anyone who can contact it. Ensuring that only CloudFlare can ask the key server to perform operations is crucial to the security of Keyless SSL.</p>
<p nodeIndex="118">We secure the connection from CloudFlare to the key server with mutually authenticated TLS. Previously, we described TLS handshakes that were only authenticated in one direction: the client validated the server. In mutually authenticated TLS, both client and server have certificates and authenticate each other. The key server authenticates CloudFlare and CloudFlare authenticates the key server.</p>
<p nodeIndex="119">In Keyless SSL, the key server only allows connections from clients with a certificate signed by a CloudFlare internal certificate authority. We use certificates granted by our own certificate authority for both sides of this connection. We have strict controls over how these certificates are granted and use the <a href="http://en.wikipedia.org/wiki/X.509#Extensions_informing_a_specific_usage_of_a_certificate" nodeIndex="302">X.509 Extended Key Usage</a> option to ensure that certificates are only used as intended. This prevents any party that doesn’t have a CloudFlare granted certificate from communicating with the key server. Customers also have the option to add firewall rules to limit incoming connections to those from <a href="https://www.cloudflare.com/ips" nodeIndex="303">CloudFlare’s IP space</a>.</p>
<p nodeIndex="120">Additionally, we restrict the cipher suite for this connection to one of the following:</p>
<ul nodeIndex="122"><li nodeIndex="121">ECDHE-ECDSA-AES256-GCM-SHA384</li>
<li nodeIndex="123">ECDHE-RSA-AES256-GCM-SHA384</li>
</ul><p nodeIndex="124">These are two of the strongest ciphers available in OpenSSL and guarantee the connection between CloudFlare and the keyserver has perfect forward secrecy.</p>
<h3 id="othersecurityconsiderations" nodeIndex="125">Other security considerations</h3>
<p nodeIndex="126">The key server itself can be modified to work with hardware security module (HSM), providing additional hardware security for customers who want to protect the key server from undiscovered software vulnerabilities similar to <a href="http://blog.cloudflare.com/searching-for-the-prime-suspect-how-heartbleed-leaked-private-keys/" nodeIndex="304">Heartbleed</a>.</p>
<p nodeIndex="127">The key server is not subject to padding oracle attacks like that of <a href="http://en.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack" nodeIndex="305">Bleichenbacher</a> because it uses constant size responses. Side-channel attacks such as timing attacks are ineffective as long as the underlying cryptographic library used on the key server is immune. We use OpenSSL in our reference implementation which has been hardened against such attacks.</p>
<h3 id="performanceenhancements" nodeIndex="128">Performance enhancements</h3>
<p nodeIndex="129">CloudFlare is designed to make sites faster: it should take less time to connect to a site on CloudFlare than the same site off CloudFlare. This is also the case with Keyless SSL. Connecting to a site with Keyless SSL should be faster than connecting to the same site with CloudFlare disabled. People have asked how can that be, given that the Keyless SSL requires an additional connection to the key server. The answer lies in geography.</p>
<p nodeIndex="130">CloudFlare’s data centers are geographically distributed in 20 countries around the world and are located within less than 20ms of 95% of the Internet’s active population. This allows visitors to communicate with a CloudFlare server that is closest to them on the network. Messages sent between visitor and CloudFlare don’t have to travel far, so the connection latency is smaller. This proximity effect is one of the ways that CloudFlare accelerates websites.</p>
<p nodeIndex="131">In the Keyless SSL diagrams above, all the messages except one are traveling over the short link between CloudFlare and the visitor. The only long round trip is the one to the key server.</p>
<div id="RIL_IMG_9" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/9"/></div>
<p nodeIndex="133">Consider the scenario where a visitor in San Francisco wants to visit a site hosted in London over TLS. Without CloudFlare, the TLS handshake requires two round-trips from San Francisco to London. With Keyless SSL and a keyserver hosted in London, the visitor will end up in CloudFlare’s nearby <a href="http://blog.cloudflare.com/and-then-there-were-threecloudflares-new-data/" nodeIndex="308">San Jose</a> data center. In this scenario, only one of the messages has to travel to London and back. Messages have to travel a shorter distance, resulting in a faster handshake.</p>
<p nodeIndex="134">The reason we only require one round-trip to the key server is persistent connections. Once CloudFlare has connected to a key server, it keeps the connection ready for any new visitors to the site. The first connection to a Keyless SSL powered site is fast, but the major performance improvement comes when a visitor returns to the site.</p>
<h3 id="abbreviatedhandshake" nodeIndex="135">Abbreviated handshake</h3>
<p nodeIndex="136">TLS provides an excellent performance feature called “session resumption”. If a client has previously established a session with the server, and is trying to connect again, they can use an abbreviated handshake. There are two mechanisms to do so: session IDs and session tickets.</p>
<p nodeIndex="137">Session IDs require the server to keep the session state (i.e. the session key) ready in case a previous session needs to be resumed. In the case of session tickets, the server sends a session ticket (consisting of the session key encrypted with a ticket key) to the client during the initial handshake. When resuming a session, the client sends the encrypted key back to the server who decrypts it and resumes the session. There is no need to use the private key for session resumption.</p>
<p nodeIndex="138">Firefox and Chrome are the major browsers that support session tickets. All other modern browsers support resumption via session IDs. One of the challenges faced when using these techniques at scale is load balancing. In order for a server to resume a connection, it needs to have the previously established session key. If the visitor tries to resume a connection with a new server, that server needs to get the original session key somehow.</p>
<p nodeIndex="139">The main problem with session resumption is that is was not meant to scale to load-balanced servers. If a client starts a session on one server, it cannot resume that session on another server. This is not a failing of the protocol, just a missing feature in open source web servers.</p>
<p nodeIndex="140">With Keyless SSL, we are introducing advanced session resumption capabilities to solve this problem. This includes worldwide session resumption via session tickets and session resumption within a data center via session IDs. Session resumption allows repeat visitors to have lightning fast connection times because there is no need to go back to the key server to resume a connection.</p>
<h3 id="sessionticketresumption" nodeIndex="141">Session ticket resumption</h3>
<p nodeIndex="142">With session tickets, we can resume a session from any machine on our network. This required significant engineering work that we are opening up to the community.</p>
<div id="RIL_IMG_10" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/10"/></div>
<p nodeIndex="144">Twitter <a href="https://blog.twitter.com/2013/forward-secrecy-at-twitter" nodeIndex="311">recently announced</a> that they are using session ticket keys rotated every 12 hours. We are upping the ante by rotating session ticket keys every hour. We built a centralized session ticket key generator that issues new keys every hour for distribution across our global network. Each key persists for a user-configurable amount of time (defaulting to 96 hours), after which it is permanently deleted. To distribute the keys, we added a TLS layer to the key-value store <a href="http://blog.cloudflare.com/kyoto_tycoon_with_postgresql/" nodeIndex="312">Kyoto Tycoon</a> so that replication is fully encrypted with mutually authenticated TLS and pinned to CloudFlare’s CA. With Kyoto Tycoon, ticket keys are replicated globally within seconds to every one of our edge machines. In keeping with our <a href="http://blog.cloudflare.com/keeping-our-open-source-promise/" nodeIndex="313">open source philosophy</a>, we plan on open sourcing our changes to Kyoto Tycoon. With the ticket keys available on every server, we can resume any connection on any machine in our entire network.</p>
<p nodeIndex="145">The rotation of ticket keys helps us maintain perfect forward secrecy for our customers while reducing latency for returning visitors using Firefox and Chrome.</p>
<h3 id="sessionidresumption" nodeIndex="146">Session ID resumption</h3>
<p nodeIndex="147">We can also resume sessions across multiple machines with a session ID. Unlike with session tickets, we can only resume sessions within a datacenter. This turns out to be good enough for 99.99% of users because CloudFlare’s Anycast network directs requests to the nearest data center. Browsers don’t typically move between cities very often, so most resumption requests end up in the same place. And, in the worst case, such as if you access a site from your phone in one city and then fly to another, your client will simply setup a new session.</p>
<div id="RIL_IMG_11" class="RIL_IMG"><img src="/media/posts_images/2017-06-30-718426718/11"/></div>
<p nodeIndex="149">We can resume sessions using an ID by caching session keys within a datacenter. For each new connection, we cache an encrypted versions of the session key in a centralized location, indexed by session ID. If a new request come in with a session ID that has been seen before, we look it up in the central store that can be accessed from all the servers in any data center. These session keys do not leave the datacenter and persist for a user-configurable amount of time, again defaulting to 96 hours. Session ID caching lets us use an abbreviated handshake for almost all resumed connection attempts in browsers other than Chrome or Firefox.</p>
<p nodeIndex="150">Other technically sophisticated organizations also use session resumption. Google, for instance, uses a similar technique to resume sessions across its infrastructure. <strong nodeIndex="316">Note:</strong> <em nodeIndex="317">All CloudFlare customers with SSL enabled now get the benefits of this advanced session resumption, even if they are not using Keyless SSL.</em></p>
<h3 id="opensource" nodeIndex="151">Open Source</h3>
<p nodeIndex="152">CloudFlare developed a lot of code when building Keyless SSL and have contributed major portions of it back to the community:</p>
<p nodeIndex="153"><strong nodeIndex="318">Strict SSL:</strong> this code allows upstream connections from NGINX to validate TLS connections, needed for validating the identity of the key server. <a href="http://mailman.nginx.org/pipermail/nginx-announce/2014.txt" nodeIndex="319">This change</a> was merged into NGINX.</p>
<p nodeIndex="154"><strong nodeIndex="320">Session tickets:</strong> we added support for session ticket in NGINX. <a href="http://mailman.nginx.org/pipermail/nginx-devel/2013-October/004370.html" nodeIndex="321">This change</a> was merged into NGINX.</p>
<p nodeIndex="155"><strong nodeIndex="322">CFSSL:</strong> we recently open sourced the tool we use for our internal certificate authority. It is available on <a href="http://blog.cloudflare.com/introducing-cfssl/" nodeIndex="323">GitHub</a>.</p>
<p nodeIndex="156"><strong nodeIndex="324">Kyoto Tycoon:</strong> we are soon open sourcing our changes to Kyoto Tycoon, a high performance key value store we use extensively, to allow mutually authenticated replication.</p>
<p nodeIndex="157"><strong nodeIndex="325">Key Server:</strong> The reference implementation of the Keyless SSL key server is now available on <a href="https://github.com/cloudflare/keyless" nodeIndex="326">Github</a>.</p>
<h3 id="whyitmatters" nodeIndex="158">Why it matters</h3>
<p nodeIndex="159">Keyless SSL is a big advancement allowing website owners to use a service like CloudFlare to make their website faster and more secure, while retaining control of their private keys. As we said in the <a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" nodeIndex="327">previous post announcing it</a>, Sebastien was able to build the initial Keyless SSL prototype overnight. Making sure it was secure, fast, and could scale is what took us two years of engineering. Now, with persistent connections and advanced session resumption techniques, using Keyless SSL is not only safe, it’s blazing fast!</p>
</div>