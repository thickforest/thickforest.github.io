---
layout: post
title: 浅析usb转serial串口设备在linux内核中枚举创建及生成tty设备的全过
categories:
- Pocket
tags:
---
原文地址：http://blog.csdn.net/bugouyonggan/article/details/9720869

收藏时间：2015-05-27 09:12:12

<div  lang="en"><p brd="1" nodeIndex="38">1.usb_register和usb_register_driver用来注册一个interface接口驱动for_devices = 0;    <br nodeIndex="354">
2.usb_register_device_driver用来注册一个usb设备驱动,for_devices = 1;用来解析设备描述符,    <br nodeIndex="355">
进而生成配置描述符下的功能接口,尝试匹配usb_register_driver注册的接口驱动来驱动该usb设备的功能接口.</p>
<p brd="1" nodeIndex="39">在整个kernel中,只有usb_init即 [subsys_initcall(usb_init)]一处调用了usb_register_device_driver函数,    <br nodeIndex="356">
usb_register_device_driver(&usb_generic_driver, THIS_MODULE);所以所有通过hub_thread检测到插入的usb设备也都将调用到    <br nodeIndex="357">
generic_probe设备枚举函数,我们这里需要提到一些usb通信方面的知识,以便我们能够透彻理解kernel中usb代码,    <br nodeIndex="358">
一个插入到HUB上的usb设备使用4种描述符来描述自己,    <br nodeIndex="359">
(1) 设备描述符    <br nodeIndex="360">
(2) 配置描述符    <br nodeIndex="361">
(3) 接口描述符    <br nodeIndex="362">
(4) 端点描述符    <br nodeIndex="363">
一个usb设备只能有1个设备描述符,1个设备描述符可以有多个配置描述符,然后每个配置描述符下面又可以有多个接口描述符用来    <br nodeIndex="364">
具体描述一个设备在该配置下的一个或多个独立功能,每个接口下面又由端点描述符来具体声明该功能接口在usb物理通信中使用哪几个    <br nodeIndex="365">
端点管道来执行usb物理信道的实际收发工作.    <br nodeIndex="366">
所以一个usb设备的具体功能是由接口描述符来描述的,因此我们开发的usb driver也就几乎99.9%都在使用usb_register函数来实现一个    <br nodeIndex="367">
接口对应的驱动,进而驱动usb设备上该接口对应的具体功能,比如UMS.    <br nodeIndex="368">
当kernel使用generic_probe()函数完成插入到 HUB上的usb设备的合法检验之后,将调用设置配置描述符操作usb_set_configuration,    <br nodeIndex="369">
生成该配置描述符下面若干个接口描述符对应的dev设备,    <br nodeIndex="370">
usb_set_configuration    <br nodeIndex="371">
==> device_add(&intf->dev);    <br nodeIndex="372">
// 这样该接口dev将扫描usb_bus_type总线上的所有drivers驱动,kernel尝试为该接口dev找到驱动它的driver.    <br nodeIndex="373">
如下几个函数中都会调用到 usb_set_configuration    <br nodeIndex="374">
usb_authorize_device // 以sysfs中attr性质存在,这样用户空间的程序就可以通过attr属性文件来强制控制接口驱动的关联.    <br nodeIndex="375">
usb_deauthorize_device    <br nodeIndex="376">
driver_set_config_work    <br nodeIndex="377">
proc_setconfig    <br nodeIndex="378">
set_bConfigurationValue    <br nodeIndex="379">
generic_disconnect    <br nodeIndex="380">
generic_probe</p>
<p brd="1" nodeIndex="40">usb 设备的检测工作是通过内核线程hub_thread完成的.    <br nodeIndex="381">
usb_hub_init==>khubd_task = kthread_run(hub_thread, NULL, "khubd"); // 创建内核线程hub_thread,监控hub上usb设备的插拔情况    <br nodeIndex="382">
hub_thread    <br nodeIndex="383">
==& gt;hub_events    <br nodeIndex="384">
==>hub_port_connect_change==>udev =usb_alloc_dev // 添加usb设备    <br nodeIndex="385">
==>hub_port_connect_change==> usb_new_device(udev)==>device_add(&udev->dev); // 将检测到的usb设备添加到usb_bus_type总线上,    <br nodeIndex="386">
// 该dev的type值为usb_device_type,最后函数执行device_add==>bus_add_device实现具体添加操作    <br nodeIndex="387">
// bus_add_device将调用上面 usb_register_device_driver(&usb_generic_driver, THIS_MODULE);注册的唯一一个设备描述符解析驱动    <br nodeIndex="388">
// usb_generic_driver==>generic_probe来完成接口设备生成和相应的接口设备驱动关联动作 .    <br nodeIndex="389">
usb_add_hcd==>usb_alloc_dev // 添加HCD    <br nodeIndex="390">
usb_alloc_dev    <br nodeIndex="391">
==>dev->dev.bus = &usb_bus_type;设置dev为usb总线上的设备    <br nodeIndex="392">
==>dev-> dev.type = &usb_device_type;设置该dev为usb设备而非接口</p>
<p brd="1" nodeIndex="41">driver_register或者device_register    <br nodeIndex="393">
调用 driver_attach或者bus_attach_device==>device_attach    <br nodeIndex="394">
来为设备尝试匹配驱动或者为驱动尝试添加设备,不论是哪一种情况,都将    <br nodeIndex="395">
执行到:driver_probe_device函数.    <br nodeIndex="396">
int driver_probe_device(struct device_driver *drv, struct device *dev)    <br nodeIndex="397">
{    <br nodeIndex="398">
int ret = 0;</p>
<p brd="1" nodeIndex="42">if (!device_is_registered(dev)) // 1.设备已经完成了注册到bus总线工作    <br nodeIndex="399">
return -ENODEV;    <br nodeIndex="400">
if (drv->bus->match && !drv->bus->match(dev, drv)) // 2.执行bus提供的match操作 usb_device_match    <br nodeIndex="401">
goto done;</p>
<p brd="1" nodeIndex="43">pr_debug("bus: '%s': %s: matched device %s with driver %s\n",    <br nodeIndex="402">
drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);</p>
<p brd="1" nodeIndex="44">ret = really_probe(dev, drv); // bus的match通过检验,这里做进一步的probe检验,    <br nodeIndex="403">
// 如果bus提供了probe,那么执行 bus->probe(dev);    <br nodeIndex="404">
// 否则执行driver提供的probe函数 drv->probe(dev);</p>
<p brd="1" nodeIndex="45">done:    <br nodeIndex="405">
return ret;    <br nodeIndex="406">
}</p>
<p brd="1" nodeIndex="46">usb_register(&mct_u232_driver);    <br nodeIndex="407">
==>usb_register_driver    <br nodeIndex="408">
new_driver->drvwrap.for_devices = 0; // 仅仅用来驱动interface接口,所以上面hub_port_connect_change由usb_alloc_dev生成的usb设备不会调用该 usb接口驱动    <br nodeIndex="409">
new_driver->drvwrap.driver.bus = &usb_bus_type;    <br nodeIndex="410">
new_driver->drvwrap.driver.probe = usb_probe_interface; // 当检测到usb设备插入后,将调用usb_probe_interface进行细致处理    <br nodeIndex="411">
// 提供为device_driver提供probe处理函数,因为bus总线usb_bus_type不提供probe操作    <br nodeIndex="412">
==>driver_register(&new_driver->drvwrap.driver); // 将驱动添加到usb bus总线管理的driver驱动链表上</p>
<p brd="1" nodeIndex="47">usb_device_match==> is_usb_device    <br nodeIndex="413">
static inline int is_usb_device(const struct device *dev)    <br nodeIndex="414">
{    <br nodeIndex="415">
return dev->type == &usb_device_type;    <br nodeIndex="416">
}</p>
<p brd="1" nodeIndex="48">开看看驱动 hub_thread==>usb_alloc_dev创建的插入到HUB上的usb设备的probe函数generic_probe.    <br nodeIndex="417">
subsys_initcall(usb_init);    <br nodeIndex="418">
==>usb_init    <br nodeIndex="419">
==>usb_register_device_driver(&usb_generic_driver, THIS_MODULE);    <br nodeIndex="420">
struct usb_device_driver usb_generic_driver = {    <br nodeIndex="421">
.name = "usb",    <br nodeIndex="422">
.probe = generic_probe,    <br nodeIndex="423">
.disconnect = generic_disconnect,    <br nodeIndex="424">
#ifdef CONFIG_PM    <br nodeIndex="425">
.suspend = generic_suspend,    <br nodeIndex="426">
.resume = generic_resume,    <br nodeIndex="427">
#endif    <br nodeIndex="428">
.supports_autosuspend = 1,    <br nodeIndex="429">
};    <br nodeIndex="430">
==>generic_probe    <br nodeIndex="431">
==>usb_set_configuration // 生成该设置配置描述下的所有接口描述符所描述的接口dev对象    <br nodeIndex="432">
==>ret = device_add(&intf->dev);</p>
<p brd="1" nodeIndex="49">int usb_set_configuration(struct usb_device *dev, int configuration)    <br nodeIndex="433">
{    <br nodeIndex="434">
int i, ret;    <br nodeIndex="435">
struct usb_host_config *cp = NULL;    <br nodeIndex="436">
struct usb_interface **new_interfaces = NULL;    <br nodeIndex="437">
int n, nintf;</p>
<p brd="1" nodeIndex="50">if (dev->authorized == 0 || configuration == -1)    <br nodeIndex="438">
configuration = 0;    <br nodeIndex="439">
else {    <br nodeIndex="440">
for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {    <br nodeIndex="441">
if (dev->config[i].desc.bConfigurationValue ==    <br nodeIndex="442">
configuration) {    <br nodeIndex="443">
cp = &dev->config[i];    <br nodeIndex="444">
break;    <br nodeIndex="445">
}    <br nodeIndex="446">
}    <br nodeIndex="447">
}    <br nodeIndex="448">
if ((!cp && configuration != 0))    <br nodeIndex="449">
return -EINVAL;</p>
<p brd="1" nodeIndex="51">/* The USB spec says configuration 0 means unconfigured.    <br nodeIndex="450">
* But if a device includes a configuration numbered 0,    <br nodeIndex="451">
* we will accept it as a correctly configured state.    <br nodeIndex="452">
* Use -1 if you really want to unconfigure the device.    <br nodeIndex="453">
*/    <br nodeIndex="454">
if (cp && configuration == 0)    <br nodeIndex="455">
dev_warn(&dev->dev, "config 0 descriptor??\n");</p>
<p brd="1" nodeIndex="52">/* Allocate memory for new interfaces before doing anything else,    <br nodeIndex="456">
* so that if we run out then nothing will have changed. */    <br nodeIndex="457">
n = nintf = 0;    <br nodeIndex="458">
if (cp) {    <br nodeIndex="459">
nintf = cp->desc.bNumInterfaces;    <br nodeIndex="460">
new_interfaces = kmalloc(nintf * sizeof(*new_interfaces),    <br nodeIndex="461">
GFP_KERNEL);    <br nodeIndex="462">
if (!new_interfaces) {    <br nodeIndex="463">
dev_err(&dev->dev, "Out of memory\n");    <br nodeIndex="464">
return -ENOMEM;    <br nodeIndex="465">
}</p>
<p brd="1" nodeIndex="53">for (; n < nintf; ++n) {    <br nodeIndex="466">
new_interfaces[n] = kzalloc(    <br nodeIndex="467">
sizeof(struct usb_interface),    <br nodeIndex="468">
GFP_KERNEL);    <br nodeIndex="469">
if (!new_interfaces[n]) {    <br nodeIndex="470">
dev_err(&dev->dev, "Out of memory\n");    <br nodeIndex="471">
ret = -ENOMEM;    <br nodeIndex="472">
free_interfaces:    <br nodeIndex="473">
while (--n >= 0)    <br nodeIndex="474">
kfree(new_interfaces[n]);    <br nodeIndex="475">
kfree(new_interfaces);    <br nodeIndex="476">
return ret;    <br nodeIndex="477">
}    <br nodeIndex="478">
}</p>
<p brd="1" nodeIndex="54">i = dev->bus_mA - cp->desc.bMaxPower * 2;    <br nodeIndex="479">
if (i < 0)    <br nodeIndex="480">
dev_warn(&dev->dev, "new config #%d exceeds power "    <br nodeIndex="481">
"limit by %dmA\n",    <br nodeIndex="482">
configuration, -i);    <br nodeIndex="483">
}</p>
<p brd="1" nodeIndex="55">/* Wake up the device so we can send it the Set-Config request */    <br nodeIndex="484">
ret = usb_autoresume_device(dev);    <br nodeIndex="485">
if (ret)    <br nodeIndex="486">
goto free_interfaces;</p>
<p brd="1" nodeIndex="56">/* if it's already configured, clear out old state first.    <br nodeIndex="487">
* getting rid of old interfaces means unbinding their drivers.    <br nodeIndex="488">
*/    <br nodeIndex="489">
if (dev->state != USB_STATE_ADDRESS)    <br nodeIndex="490">
usb_disable_device(dev, 1); /* Skip ep0 */</p>
<p brd="1" nodeIndex="57">ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),    <br nodeIndex="491">
USB_REQ_SET_CONFIGURATION, 0, configuration, 0,    <br nodeIndex="492">
NULL, 0, USB_CTRL_SET_TIMEOUT);    <br nodeIndex="493">
if (ret < 0) {    <br nodeIndex="494">
/* All the old state is gone, so what else can we do?    <br nodeIndex="495">
* The device is probably useless now anyway.    <br nodeIndex="496">
*/    <br nodeIndex="497">
cp = NULL;    <br nodeIndex="498">
}</p>
<p brd="1" nodeIndex="58">dev->actconfig = cp;    <br nodeIndex="499">
if (!cp) {    <br nodeIndex="500">
usb_set_device_state(dev, USB_STATE_ADDRESS);    <br nodeIndex="501">
usb_autosuspend_device(dev);    <br nodeIndex="502">
goto free_interfaces;    <br nodeIndex="503">
}    <br nodeIndex="504">
usb_set_device_state(dev, USB_STATE_CONFIGURED);</p>
<p brd="1" nodeIndex="59">/* Initialize the new interface structures and the    <br nodeIndex="505">
* hc/hcd/usbcore interface/endpoint state.    <br nodeIndex="506">
*/    <br nodeIndex="507">
for (i = 0; i < nintf; ++i) {    <br nodeIndex="508">
struct usb_interface_cache *intfc;    <br nodeIndex="509">
struct usb_interface *intf;    <br nodeIndex="510">
struct usb_host_interface *alt;</p>
<p brd="1" nodeIndex="60">cp->interface[i] = intf = new_interfaces[i];    <br nodeIndex="511">
intfc = cp->intf_cache[i];    <br nodeIndex="512">
intf->altsetting = intfc->altsetting;    <br nodeIndex="513">
intf->num_altsetting = intfc->num_altsetting;    <br nodeIndex="514">
intf->intf_assoc = find_iad(dev, cp, i);    <br nodeIndex="515">
kref_get(&intfc->ref);</p>
<p brd="1" nodeIndex="61">alt = usb_altnum_to_altsetting(intf, 0);</p>
<p brd="1" nodeIndex="62">/* No altsetting 0? We'll assume the first altsetting.    <br nodeIndex="516">
* We could use a GetInterface call, but if a device is    <br nodeIndex="517">
* so non-compliant that it doesn't have altsetting 0    <br nodeIndex="518">
* then I wouldn't trust its reply anyway.    <br nodeIndex="519">
*/    <br nodeIndex="520">
if (!alt)    <br nodeIndex="521">
alt = &intf->altsetting[0];</p>
<p brd="1" nodeIndex="63">intf->cur_altsetting = alt;    <br nodeIndex="522">
usb_enable_interface(dev, intf);    <br nodeIndex="523">
intf->dev.parent = &dev->dev;    <br nodeIndex="524">
intf->dev.driver = NULL;    <br nodeIndex="525">
intf->dev.bus = &usb_bus_type; // 位于usb_bus_type总线    <br nodeIndex="526">
intf->dev.type = &usb_if_device_type; // 为接口设备,这样在usb_device_match中将去和接口驱动去匹配    <br nodeIndex="527">
intf->dev.dma_mask = dev->dev.dma_mask;    <br nodeIndex="528">
device_initialize(&intf->dev);    <br nodeIndex="529">
mark_quiesced(intf);    <br nodeIndex="530">
sprintf(&intf->dev.bus_id[0], "%d-%s:%d.%d",    <br nodeIndex="531">
dev->bus->busnum, dev->devpath,    <br nodeIndex="532">
configuration, alt->desc.bInterfaceNumber);    <br nodeIndex="533">
}    <br nodeIndex="534">
kfree(new_interfaces);</p>
<p brd="1" nodeIndex="64">if (cp->string == NULL)    <br nodeIndex="535">
cp->string = usb_cache_string(dev, cp->desc.iConfiguration);</p>
<p brd="1" nodeIndex="65">/* Now that all the interfaces are set up, register them    <br nodeIndex="536">
* to trigger binding of drivers to interfaces. probe()    <br nodeIndex="537">
* routines may install different altsettings and may    <br nodeIndex="538">
* claim() any interfaces not yet bound. Many class drivers    <br nodeIndex="539">
* need that: CDC, audio, video, etc.    <br nodeIndex="540">
*/    <br nodeIndex="541">
for (i = 0; i < nintf; ++i) {    <br nodeIndex="542">
struct usb_interface *intf = cp->interface[i];</p>
<p brd="1" nodeIndex="66">dev_dbg(&dev->dev,    <br nodeIndex="543">
"adding %s (config #%d, interface %d)\n",    <br nodeIndex="544">
intf->dev.bus_id, configuration,    <br nodeIndex="545">
intf->cur_altsetting->desc.bInterfaceNumber);    <br nodeIndex="546">
ret = device_add(&intf->dev); // 将接口设备添加bus总线上同时到sysfs系统中.    <br nodeIndex="547">
if (ret != 0) {    <br nodeIndex="548">
dev_err(&dev->dev, "device_add(%s) --> %d\n",    <br nodeIndex="549">
intf->dev.bus_id, ret);    <br nodeIndex="550">
continue;    <br nodeIndex="551">
}    <br nodeIndex="552">
usb_create_sysfs_intf_files(intf);    <br nodeIndex="553">
}</p>
<p brd="1" nodeIndex="67">usb_autosuspend_device(dev);    <br nodeIndex="554">
return 0;    <br nodeIndex="555">
}</p>
<p brd="1" nodeIndex="68">如下是一个整体代码流程:    <br nodeIndex="556">
driver_probe_device    <br nodeIndex="557">
int driver_probe_device(struct device_driver *drv, struct device *dev)    <br nodeIndex="558">
{    <br nodeIndex="559">
int ret = 0;</p>
<p brd="1" nodeIndex="69">if (!device_is_registered(dev)) // 1.设备已经完成了注册到bus总线工作    <br nodeIndex="560">
return -ENODEV;    <br nodeIndex="561">
if (drv->bus->match && !drv->bus->match(dev, drv)) // 2.执行bus提供的match操作 usb_device_match    <br nodeIndex="562">
goto done;</p>
<p brd="1" nodeIndex="70">pr_debug("bus: '%s': %s: matched device %s with driver %s\n",    <br nodeIndex="563">
drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);</p>
<p brd="1" nodeIndex="71">ret = really_probe(dev, drv); // bus的match通过检验,这里做进一步的probe检验,    <br nodeIndex="564">
// 如果bus提供了probe,那么执行 bus->probe(dev);    <br nodeIndex="565">
// 否则执行driver提供的probe函数 drv->probe(dev);</p>
<p brd="1" nodeIndex="72">done:    <br nodeIndex="566">
return ret;    <br nodeIndex="567">
}    <br nodeIndex="568">
==>usb_bus_type    <br nodeIndex="569">
==>usb_device_match    <br nodeIndex="570">
static int usb_device_match(struct device *dev, struct device_driver *drv)    <br nodeIndex="571">
{    <br nodeIndex="572">
/* devices and interfaces are handled separately */    <br nodeIndex="573">
if (is_usb_device(dev)) {</p>
<p brd="1" nodeIndex="73">/* interface drivers never match devices */    <br nodeIndex="574">
if (!is_usb_device_driver(drv))    <br nodeIndex="575">
return 0;</p>
<p brd="1" nodeIndex="74">/* TODO: Add real matching code */    <br nodeIndex="576">
return 1;</p>
<p brd="1" nodeIndex="75">} else {    <br nodeIndex="577">
struct usb_interface *intf;    <br nodeIndex="578">
struct usb_driver *usb_drv;    <br nodeIndex="579">
const struct usb_device_id *id;</p>
<p brd="1" nodeIndex="76">/* device drivers never match interfaces */    <br nodeIndex="580">
if (is_usb_device_driver(drv))    <br nodeIndex="581">
return 0;</p>
<p brd="1" nodeIndex="77">intf = to_usb_interface(dev); // 转为接口dev设备    <br nodeIndex="582">
usb_drv = to_usb_driver(drv); // 转为usb驱动</p>
<p brd="1" nodeIndex="78">id = usb_match_id(intf, usb_drv->id_table); // 接口设备与usb接口驱动的id_table值表进行匹配尝试    <br nodeIndex="583">
if (id)    <br nodeIndex="584">
return 1;</p>
<p brd="1" nodeIndex="79">id = usb_match_dynamic_id(intf, usb_drv);    <br nodeIndex="585">
if (id)    <br nodeIndex="586">
return 1;    <br nodeIndex="587">
}</p>
<p brd="1" nodeIndex="80">return 0;    <br nodeIndex="588">
}    <br nodeIndex="589">
==>really_probe    <br nodeIndex="590">
static int really_probe(struct device *dev, struct device_driver *drv)    <br nodeIndex="591">
{    <br nodeIndex="592">
int ret = 0;</p>
<p brd="1" nodeIndex="81">atomic_inc(&probe_count);    <br nodeIndex="593">
pr_debug("bus: '%s': %s: probing driver %s with device %s\n",    <br nodeIndex="594">
drv->bus->name, __FUNCTION__, drv->name, dev->bus_id);    <br nodeIndex="595">
WARN_ON(!list_empty(&dev->devres_head));</p>
<p brd="1" nodeIndex="82">dev->driver = drv; // 先假定该driver就是驱动本dev的驱动,后面讲做进一步确认    <br nodeIndex="596">
if (driver_sysfs_add(dev)) {    <br nodeIndex="597">
printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",    <br nodeIndex="598">
__FUNCTION__, dev->bus_id);    <br nodeIndex="599">
goto probe_failed;    <br nodeIndex="600">
}</p>
<p brd="1" nodeIndex="83">if (dev->bus->probe) {    <br nodeIndex="601">
ret = dev->bus->probe(dev); // 如果bus总线提供probe,那么执行之    <br nodeIndex="602">
if (ret)    <br nodeIndex="603">
goto probe_failed;    <br nodeIndex="604">
} else if (drv->probe) {    <br nodeIndex="605">
ret = drv->probe(dev); // 如果driver提供probe,那么执行之,    <br nodeIndex="606">
// 我们这里就是new_driver->drvwrap.driver.probe = usb_probe_interface;    <br nodeIndex="607">
if (ret)    <br nodeIndex="608">
goto probe_failed;    <br nodeIndex="609">
}</p>
<p brd="1" nodeIndex="84">driver_bound(dev);    <br nodeIndex="610">
ret = 1;    <br nodeIndex="611">
pr_debug("bus: '%s': %s: bound device %s to driver %s\n",    <br nodeIndex="612">
drv->bus->name, __FUNCTION__, dev->bus_id, drv->name);    <br nodeIndex="613">
goto done;</p>
<p brd="1" nodeIndex="85">probe_failed:    <br nodeIndex="614">
devres_release_all(dev);    <br nodeIndex="615">
driver_sysfs_remove(dev);    <br nodeIndex="616">
dev->driver = NULL;</p>
<p brd="1" nodeIndex="86">if (ret != -ENODEV && ret != -ENXIO) {    <br nodeIndex="617">
/* driver matched but the probe failed */    <br nodeIndex="618">
printk(KERN_WARNING    <br nodeIndex="619">
"%s: probe of %s failed with error %d\n",    <br nodeIndex="620">
drv->name, dev->bus_id, ret);    <br nodeIndex="621">
}    <br nodeIndex="622">
/*    <br nodeIndex="623">
* Ignore errors returned by ->probe so that the next driver can try    <br nodeIndex="624">
* its luck.    <br nodeIndex="625">
*/    <br nodeIndex="626">
ret = 0;    <br nodeIndex="627">
done:    <br nodeIndex="628">
atomic_dec(&probe_count);    <br nodeIndex="629">
wake_up(&probe_waitqueue);    <br nodeIndex="630">
return ret;    <br nodeIndex="631">
}    <br nodeIndex="632">
==>usb_probe_interface 即:new_driver->drvwrap.driver.probe = usb_probe_interface;    <br nodeIndex="633">
/* called from driver core with dev locked */    <br nodeIndex="634">
static int usb_probe_interface(struct device *dev)    <br nodeIndex="635">
{    <br nodeIndex="636">
struct usb_driver *driver = to_usb_driver(dev->driver);    <br nodeIndex="637">
struct usb_interface *intf;    <br nodeIndex="638">
struct usb_device *udev;    <br nodeIndex="639">
const struct usb_device_id *id;    <br nodeIndex="640">
int error = -ENODEV;</p>
<p brd="1" nodeIndex="87">dev_dbg(dev, "%s\n", __FUNCTION__);</p>
<p brd="1" nodeIndex="88">if (is_usb_device(dev)) /* Sanity check */    <br nodeIndex="641">
return error;</p>
<p brd="1" nodeIndex="89">intf = to_usb_interface(dev);    <br nodeIndex="642">
udev = interface_to_usbdev(intf);</p>
<p brd="1" nodeIndex="90">if (udev->authorized == 0) {    <br nodeIndex="643">
dev_err(&intf->dev, "Device is not authorized for usage\n");    <br nodeIndex="644">
return -ENODEV;    <br nodeIndex="645">
}</p>
<p brd="1" nodeIndex="91">id = usb_match_id(intf, driver->id_table);    <br nodeIndex="646">
if (!id)    <br nodeIndex="647">
id = usb_match_dynamic_id(intf, driver);    <br nodeIndex="648">
if (id) {    <br nodeIndex="649">
dev_dbg(dev, "%s - got id\n", __FUNCTION__);</p>
<p brd="1" nodeIndex="92">error = usb_autoresume_device(udev);    <br nodeIndex="650">
if (error)    <br nodeIndex="651">
return error;</p>
<p brd="1" nodeIndex="93">/* Interface "power state" doesn't correspond to any hardware    <br nodeIndex="652">
* state whatsoever. We use it to record when it's bound to    <br nodeIndex="653">
* a driver that may start I/0: it's not frozen/quiesced.    <br nodeIndex="654">
*/    <br nodeIndex="655">
mark_active(intf);    <br nodeIndex="656">
intf->condition = USB_INTERFACE_BINDING;</p>
<p brd="1" nodeIndex="94">/* The interface should always appear to be in use    <br nodeIndex="657">
* unless the driver suports autosuspend.    <br nodeIndex="658">
*/    <br nodeIndex="659">
intf->pm_usage_cnt = !(driver->supports_autosuspend);</p>
<p brd="1" nodeIndex="95">error = driver->probe(intf, id); // 调用usb_driver驱动定义的probe函数,我们这里就是usb_serial_probe 即:mct_u232_driver.probe    <br nodeIndex="660">
if (error) {    <br nodeIndex="661">
mark_quiesced(intf);    <br nodeIndex="662">
intf->needs_remote_wakeup = 0;    <br nodeIndex="663">
intf->condition = USB_INTERFACE_UNBOUND;    <br nodeIndex="664">
} else    <br nodeIndex="665">
intf->condition = USB_INTERFACE_BOUND;</p>
<p brd="1" nodeIndex="96">usb_autosuspend_device(udev);    <br nodeIndex="666">
}</p>
<p brd="1" nodeIndex="97">return error;    <br nodeIndex="667">
}    <br nodeIndex="668">
==>usb_serial_probe 即:mct_u232_driver.probe函数    <br nodeIndex="669">
int usb_serial_probe(struct usb_interface *interface,    <br nodeIndex="670">
const struct usb_device_id *id)    <br nodeIndex="671">
{    <br nodeIndex="672">
struct usb_device *dev = interface_to_usbdev (interface);    <br nodeIndex="673">
struct usb_serial *serial = NULL;    <br nodeIndex="674">
struct usb_serial_port *port;    <br nodeIndex="675">
struct usb_host_interface *iface_desc;    <br nodeIndex="676">
struct usb_endpoint_descriptor *endpoint;    <br nodeIndex="677">
struct usb_endpoint_descriptor *interrupt_in_endpoint[MAX_NUM_PORTS];    <br nodeIndex="678">
struct usb_endpoint_descriptor *interrupt_out_endpoint[MAX_NUM_PORTS];    <br nodeIndex="679">
struct usb_endpoint_descriptor *bulk_in_endpoint[MAX_NUM_PORTS];    <br nodeIndex="680">
struct usb_endpoint_descriptor *bulk_out_endpoint[MAX_NUM_PORTS];    <br nodeIndex="681">
struct usb_serial_driver *type = NULL;    <br nodeIndex="682">
int retval;    <br nodeIndex="683">
int minor;    <br nodeIndex="684">
int buffer_size;    <br nodeIndex="685">
int i;    <br nodeIndex="686">
int num_interrupt_in = 0;    <br nodeIndex="687">
int num_interrupt_out = 0;    <br nodeIndex="688">
int num_bulk_in = 0;    <br nodeIndex="689">
int num_bulk_out = 0;    <br nodeIndex="690">
int num_ports = 0;    <br nodeIndex="691">
int max_endpoints;</p>
<p brd="1" nodeIndex="98">lock_kernel(); /* guard against unloading a serial driver module */    <br nodeIndex="692">
type = search_serial_device(interface); // 遍历usb_serial_driver_list链表,搜索与该interface匹配上的串口驱动,    <br nodeIndex="693">
// usb_serial_driver_list链表元素由函数usb_serial_driver_list添加    <br nodeIndex="694">
// 我们这里将返回type = &mct_u232_device;[luther.gliethtp]    <br nodeIndex="695">
/*    <br nodeIndex="696">
static struct usb_serial_driver *search_serial_device(struct usb_interface *iface)    <br nodeIndex="697">
{    <br nodeIndex="698">
const struct usb_device_id *id;    <br nodeIndex="699">
struct usb_serial_driver *drv;</p>
<p brd="1" nodeIndex="99">list_for_each_entry(drv, &usb_serial_driver_list, driver_list) {    <br nodeIndex="700">
id = get_iface_id(drv, iface);    <br nodeIndex="701">
if (id)    <br nodeIndex="702">
return drv;    <br nodeIndex="703">
}    <br nodeIndex="704">
return NULL;    <br nodeIndex="705">
}    <br nodeIndex="706">
==>usb_serial_register // 添加serial驱动到usb_serial_driver_list链表上    <br nodeIndex="707">
static struct usb_serial_driver mct_u232_device = {...};    <br nodeIndex="708">
usb_serial_register(&mct_u232_device); // 注册mct_u232串口驱动到usb_serial_driver_list链表上    <br nodeIndex="709">
int usb_serial_register(struct usb_serial_driver *driver)    <br nodeIndex="710">
{    <br nodeIndex="711">
int retval;</p>
<p brd="1" nodeIndex="100">fixup_generic(driver); // 填入driver没有定义的默认方法</p>
<p brd="1" nodeIndex="101">if (!driver->description)    <br nodeIndex="712">
driver->description = driver->driver.name;</p>
<p brd="1" nodeIndex="102">// Add this device to our list of devices    <br nodeIndex="713">
list_add(&driver->driver_list, &usb_serial_driver_list); // 将mct_u232_device添加到usb_serial_driver_list链表上</p>
<p brd="1" nodeIndex="103">retval = usb_serial_bus_register(driver);    <br nodeIndex="714">
if (retval) {    <br nodeIndex="715">
err("problem %d when registering driver %s", retval, driver->description);    <br nodeIndex="716">
list_del(&driver->driver_list);    <br nodeIndex="717">
}    <br nodeIndex="718">
else    <br nodeIndex="719">
info("USB Serial support registered for %s", driver->description);</p>
<p brd="1" nodeIndex="104">return retval;    <br nodeIndex="720">
}    <br nodeIndex="721">
int usb_serial_bus_register(struct usb_serial_driver *driver)    <br nodeIndex="722">
{    <br nodeIndex="723">
int retval;</p>
<p brd="1" nodeIndex="105">driver->driver.bus = &usb_serial_bus_type;    <br nodeIndex="724">
spin_lock_init(&driver->dynids.lock);    <br nodeIndex="725">
INIT_LIST_HEAD(&driver->dynids.list);</p>
<p brd="1" nodeIndex="106">retval = driver_register(&driver->driver);</p>
<p brd="1" nodeIndex="107">return retval;    <br nodeIndex="726">
}    <br nodeIndex="727">
*/    <br nodeIndex="728">
if (!type) {    <br nodeIndex="729">
unlock_kernel();    <br nodeIndex="730">
dbg("none matched");    <br nodeIndex="731">
return -ENODEV;    <br nodeIndex="732">
}</p>
<p brd="1" nodeIndex="108">serial = create_serial (dev, interface, type); // 创建serial串口设备    <br nodeIndex="733">
/*    <br nodeIndex="734">
static struct usb_serial * create_serial (struct usb_device *dev,    <br nodeIndex="735">
struct usb_interface *interface,    <br nodeIndex="736">
struct usb_serial_driver *driver)    <br nodeIndex="737">
{    <br nodeIndex="738">
struct usb_serial *serial;</p>
<p brd="1" nodeIndex="109">serial = kzalloc(sizeof(*serial), GFP_KERNEL); // 全0空间    <br nodeIndex="739">
if (!serial) {    <br nodeIndex="740">
dev_err(&dev->dev, "%s - out of memory\n", __FUNCTION__);    <br nodeIndex="741">
return NULL;    <br nodeIndex="742">
}    <br nodeIndex="743">
serial->dev = usb_get_dev(dev); // 该serial对应的usb设备描述符对应的设备结构体    <br nodeIndex="744">
serial->type = driver; // 该serial对应的driver    <br nodeIndex="745">
serial->interface = interface; // 该serial对应的interface    <br nodeIndex="746">
kref_init(&serial->kref);    <br nodeIndex="747">
mutex_init(&serial->disc_mutex);</p>
<p brd="1" nodeIndex="110">return serial;    <br nodeIndex="748">
}    <br nodeIndex="749">
*/    <br nodeIndex="750">
if (!serial) {    <br nodeIndex="751">
unlock_kernel();    <br nodeIndex="752">
dev_err(&interface->dev, "%s - out of memory\n", __FUNCTION__);    <br nodeIndex="753">
return -ENOMEM;    <br nodeIndex="754">
}</p>
<p brd="1" nodeIndex="111">/* if this device type has a probe function, call it */    <br nodeIndex="755">
if (type->probe) { // mct_u232_device串口驱动没有probe函数    <br nodeIndex="756">
const struct usb_device_id *id;</p>
<p brd="1" nodeIndex="112">if (!try_module_get(type->driver.owner)) {    <br nodeIndex="757">
unlock_kernel();    <br nodeIndex="758">
dev_err(&interface->dev, "module get failed, exiting\n");    <br nodeIndex="759">
kfree (serial);    <br nodeIndex="760">
return -EIO;    <br nodeIndex="761">
}</p>
<p brd="1" nodeIndex="113">id = get_iface_id(type, interface);    <br nodeIndex="762">
retval = type->probe(serial, id);    <br nodeIndex="763">
module_put(type->driver.owner);</p>
<p brd="1" nodeIndex="114">if (retval) {    <br nodeIndex="764">
unlock_kernel();    <br nodeIndex="765">
dbg ("sub driver rejected device");    <br nodeIndex="766">
kfree (serial);    <br nodeIndex="767">
return retval;    <br nodeIndex="768">
}    <br nodeIndex="769">
}</p>
<p brd="1" nodeIndex="115">/* descriptor matches, let's find the endpoints needed */    <br nodeIndex="770">
/* check out the endpoints */    <br nodeIndex="771">
iface_desc = interface->cur_altsetting; // 当前接口对应的接口描述符信息    <br nodeIndex="772">
for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) { // 为该接口dev设备收集端点通信管道    <br nodeIndex="773">
endpoint = &iface_desc->endpoint[i].desc;</p>
<p brd="1" nodeIndex="116">if (usb_endpoint_is_bulk_in(endpoint)) {    <br nodeIndex="774">
/* we found a bulk in endpoint */    <br nodeIndex="775">
dbg("found bulk in on endpoint %d", i);    <br nodeIndex="776">
bulk_in_endpoint[num_bulk_in] = endpoint; // 批量IN端点    <br nodeIndex="777">
++num_bulk_in;    <br nodeIndex="778">
}</p>
<p brd="1" nodeIndex="117">if (usb_endpoint_is_bulk_out(endpoint)) {    <br nodeIndex="779">
/* we found a bulk out endpoint */    <br nodeIndex="780">
dbg("found bulk out on endpoint %d", i);    <br nodeIndex="781">
bulk_out_endpoint[num_bulk_out] = endpoint; // 批量OUT端点    <br nodeIndex="782">
++num_bulk_out;    <br nodeIndex="783">
}</p>
<p brd="1" nodeIndex="118">if (usb_endpoint_is_int_in(endpoint)) {    <br nodeIndex="784">
/* we found a interrupt in endpoint */    <br nodeIndex="785">
dbg("found interrupt in on endpoint %d", i);    <br nodeIndex="786">
interrupt_in_endpoint[num_interrupt_in] = endpoint; // 中断IN端点    <br nodeIndex="787">
++num_interrupt_in;    <br nodeIndex="788">
}</p>
<p brd="1" nodeIndex="119">if (usb_endpoint_is_int_out(endpoint)) {    <br nodeIndex="789">
/* we found an interrupt out endpoint */    <br nodeIndex="790">
dbg("found interrupt out on endpoint %d", i);    <br nodeIndex="791">
interrupt_out_endpoint[num_interrupt_out] = endpoint; // 中断OUT端点    <br nodeIndex="792">
++num_interrupt_out;    <br nodeIndex="793">
}    <br nodeIndex="794">
}</p>
<p brd="1" nodeIndex="120">#if defined(CONFIG_USB_SERIAL_PL2303) || defined(CONFIG_USB_SERIAL_PL2303_MODULE)    <br nodeIndex="795">
// 执行PL2303 usb转串口设备的IN端点信息特殊处理    <br nodeIndex="796">
/* BEGIN HORRIBLE HACK FOR PL2303 */    <br nodeIndex="797">
/* this is needed due to the looney way its endpoints are set up */    <br nodeIndex="798">
if (((le16_to_cpu(dev->descriptor.idVendor) == PL2303_VENDOR_ID) &&    <br nodeIndex="799">
(le16_to_cpu(dev->descriptor.idProduct) == PL2303_PRODUCT_ID)) ||    <br nodeIndex="800">
((le16_to_cpu(dev->descriptor.idVendor) == ATEN_VENDOR_ID) &&    <br nodeIndex="801">
(le16_to_cpu(dev->descriptor.idProduct) == ATEN_PRODUCT_ID)) ||    <br nodeIndex="802">
((le16_to_cpu(dev->descriptor.idVendor) == ALCOR_VENDOR_ID) &&    <br nodeIndex="803">
(le16_to_cpu(dev->descriptor.idProduct) == ALCOR_PRODUCT_ID))) {    <br nodeIndex="804">
if (interface != dev->actconfig->interface[0]) { // 如果当前PL2303 usb转串口不等于0接口,dev->actconfig->interface[0]    <br nodeIndex="805">
/* check out the endpoints of the other interface*/    <br nodeIndex="806">
iface_desc = dev->actconfig->interface[0]->cur_altsetting; // 那么将0接口中的中断IN端点添加到该serial设备中    <br nodeIndex="807">
for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {    <br nodeIndex="808">
endpoint = &iface_desc->endpoint[i].desc;    <br nodeIndex="809">
if (usb_endpoint_is_int_in(endpoint)) {    <br nodeIndex="810">
/* we found a interrupt in endpoint */    <br nodeIndex="811">
dbg("found interrupt in for Prolific device on separate interface");    <br nodeIndex="812">
interrupt_in_endpoint[num_interrupt_in] = endpoint;    <br nodeIndex="813">
++num_interrupt_in;    <br nodeIndex="814">
}    <br nodeIndex="815">
}    <br nodeIndex="816">
}</p>
<p brd="1" nodeIndex="121">/* Now make sure the PL-2303 is configured correctly.    <br nodeIndex="817">
* If not, give up now and hope this hack will work    <br nodeIndex="818">
* properly during a later invocation of usb_serial_probe    <br nodeIndex="819">
*/    <br nodeIndex="820">
if (num_bulk_in == 0 || num_bulk_out == 0) {    <br nodeIndex="821">
unlock_kernel();    <br nodeIndex="822">
dev_info(&interface->dev, "PL-2303 hack: descriptors matched but endpoints did not\n");    <br nodeIndex="823">
kfree (serial);    <br nodeIndex="824">
return -ENODEV;    <br nodeIndex="825">
}    <br nodeIndex="826">
}    <br nodeIndex="827">
/* END HORRIBLE HACK FOR PL2303 */    <br nodeIndex="828">
#endif</p>
<p brd="1" nodeIndex="122">#ifdef CONFIG_USB_SERIAL_GENERIC    <br nodeIndex="829">
if (type == &usb_serial_generic_device) {    <br nodeIndex="830">
num_ports = num_bulk_out;    <br nodeIndex="831">
if (num_ports == 0) { // 如果是usb_serial_generic_device驱动,那么批量OUT端点务必要存在,并且可用端点个数就是批量OUT端点个数.    <br nodeIndex="832">
unlock_kernel();    <br nodeIndex="833">
dev_err(&interface->dev, "Generic device with no bulk out, not allowed.\n");    <br nodeIndex="834">
kfree (serial);    <br nodeIndex="835">
return -EIO;    <br nodeIndex="836">
}    <br nodeIndex="837">
}    <br nodeIndex="838">
#endif    <br nodeIndex="839">
if (!num_ports) { // 好,不是usb_serial_generic_device驱动    <br nodeIndex="840">
/* if this device type has a calc_num_ports function, call it */    <br nodeIndex="841">
if (type->calc_num_ports) { // 是否需要调用计算函数计算端点个数    <br nodeIndex="842">
if (!try_module_get(type->driver.owner)) {    <br nodeIndex="843">
unlock_kernel();    <br nodeIndex="844">
dev_err(&interface->dev, "module get failed, exiting\n");    <br nodeIndex="845">
kfree (serial);    <br nodeIndex="846">
return -EIO;    <br nodeIndex="847">
}    <br nodeIndex="848">
num_ports = type->calc_num_ports (serial);    <br nodeIndex="849">
module_put(type->driver.owner);    <br nodeIndex="850">
}    <br nodeIndex="851">
if (!num_ports)    <br nodeIndex="852">
num_ports = type->num_ports; // 由usb转串口接口驱动定义端点个数:mct_u232_device定义num_ports为 1    <br nodeIndex="853">
}</p>
<p brd="1" nodeIndex="123">serial->num_ports = num_ports; // 端点个数    <br nodeIndex="854">
serial->num_bulk_in = num_bulk_in; // 批量IN端点个数    <br nodeIndex="855">
serial->num_bulk_out = num_bulk_out; // 批量OUT端点个数    <br nodeIndex="856">
serial->num_interrupt_in = num_interrupt_in; // 中断IN端点个数    <br nodeIndex="857">
serial->num_interrupt_out = num_interrupt_out; // 中断OUT端点个数</p>
<p brd="1" nodeIndex="124">#if 0    <br nodeIndex="858">
/* check that the device meets the driver's requirements */    <br nodeIndex="859">
if ((type->num_interrupt_in != NUM_DONT_CARE &&    <br nodeIndex="860">
type->num_interrupt_in != num_interrupt_in)    <br nodeIndex="861">
|| (type->num_interrupt_out != NUM_DONT_CARE &&    <br nodeIndex="862">
type->num_interrupt_out != num_interrupt_out)    <br nodeIndex="863">
|| (type->num_bulk_in != NUM_DONT_CARE &&    <br nodeIndex="864">
type->num_bulk_in != num_bulk_in)    <br nodeIndex="865">
|| (type->num_bulk_out != NUM_DONT_CARE &&    <br nodeIndex="866">
type->num_bulk_out != num_bulk_out)) {    <br nodeIndex="867">
dbg("wrong number of endpoints");    <br nodeIndex="868">
kfree(serial);    <br nodeIndex="869">
return -EIO;    <br nodeIndex="870">
}    <br nodeIndex="871">
#endif</p>
<p brd="1" nodeIndex="125">/* found all that we need */    <br nodeIndex="872">
dev_info(&interface->dev, "%s converter detected\n",    <br nodeIndex="873">
type->description);</p>
<p brd="1" nodeIndex="126">/* create our ports, we need as many as the max endpoints */    <br nodeIndex="874">
/* we don't use num_ports here cauz some devices have more endpoint pairs than ports */    <br nodeIndex="875">
max_endpoints = max(num_bulk_in, num_bulk_out);    <br nodeIndex="876">
max_endpoints = max(max_endpoints, num_interrupt_in);    <br nodeIndex="877">
max_endpoints = max(max_endpoints, num_interrupt_out);    <br nodeIndex="878">
max_endpoints = max(max_endpoints, (int)serial->num_ports);    <br nodeIndex="879">
serial->num_port_pointers = max_endpoints;    <br nodeIndex="880">
unlock_kernel();</p>
<p brd="1" nodeIndex="127">dbg("%s - setting up %d port structures for this device", __FUNCTION__, max_endpoints);    <br nodeIndex="881">
for (i = 0; i < max_endpoints; ++i) {    <br nodeIndex="882">
port = kzalloc(sizeof(struct usb_serial_port), GFP_KERNEL); // 申请4种端点集合结构体struct usb_serial_port    <br nodeIndex="883">
if (!port)    <br nodeIndex="884">
goto probe_error;    <br nodeIndex="885">
port->serial = serial;    <br nodeIndex="886">
spin_lock_init(&port->lock);    <br nodeIndex="887">
mutex_init(&port->mutex);    <br nodeIndex="888">
INIT_WORK(&port->work, usb_serial_port_work); // 设置工作队列work_queue    <br nodeIndex="889">
serial->port[i] = port;    <br nodeIndex="890">
}</p>
<p brd="1" nodeIndex="128">/* set up the endpoint information */    <br nodeIndex="891">
for (i = 0; i < num_bulk_in; ++i) {    <br nodeIndex="892">
endpoint = bulk_in_endpoint[i];    <br nodeIndex="893">
port = serial->port[i];    <br nodeIndex="894">
port->read_urb = usb_alloc_urb (0, GFP_KERNEL); // 申请URB控制结构体    <br nodeIndex="895">
if (!port->read_urb) {    <br nodeIndex="896">
dev_err(&interface->dev, "No free urbs available\n");    <br nodeIndex="897">
goto probe_error;    <br nodeIndex="898">
}    <br nodeIndex="899">
buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);    <br nodeIndex="900">
port->bulk_in_size = buffer_size; // 端点大小    <br nodeIndex="901">
port->bulk_in_endpointAddress = endpoint->bEndpointAddress; // 端点地址    <br nodeIndex="902">
port->bulk_in_buffer = kmalloc (buffer_size, GFP_KERNEL); // 端点管道数据缓冲区    <br nodeIndex="903">
if (!port->bulk_in_buffer) {    <br nodeIndex="904">
dev_err(&interface->dev, "Couldn't allocate bulk_in_buffer\n");    <br nodeIndex="905">
goto probe_error;    <br nodeIndex="906">
}    <br nodeIndex="907">
// 填充上面申请到的read_urb URB控制结构体    <br nodeIndex="908">
usb_fill_bulk_urb (port->read_urb, dev,    <br nodeIndex="909">
usb_rcvbulkpipe (dev,    <br nodeIndex="910">
endpoint->bEndpointAddress),    <br nodeIndex="911">
port->bulk_in_buffer, buffer_size,    <br nodeIndex="912">
serial->type->read_bulk_callback, // 在mct_u232_device中定义的批量读回调函数    <br nodeIndex="913">
port);    <br nodeIndex="914">
}</p>
<p brd="1" nodeIndex="129">for (i = 0; i < num_bulk_out; ++i) {    <br nodeIndex="915">
endpoint = bulk_out_endpoint[i];    <br nodeIndex="916">
port = serial->port[i];    <br nodeIndex="917">
port->write_urb = usb_alloc_urb(0, GFP_KERNEL);// 申请URB控制结构体    <br nodeIndex="918">
if (!port->write_urb) {    <br nodeIndex="919">
dev_err(&interface->dev, "No free urbs available\n");    <br nodeIndex="920">
goto probe_error;    <br nodeIndex="921">
}    <br nodeIndex="922">
buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);    <br nodeIndex="923">
port->bulk_out_size = buffer_size;    <br nodeIndex="924">
port->bulk_out_endpointAddress = endpoint->bEndpointAddress;    <br nodeIndex="925">
port->bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);    <br nodeIndex="926">
if (!port->bulk_out_buffer) {    <br nodeIndex="927">
dev_err(&interface->dev, "Couldn't allocate bulk_out_buffer\n");    <br nodeIndex="928">
goto probe_error;    <br nodeIndex="929">
}    <br nodeIndex="930">
// 填充上面申请到的write_urb URB控制结构体    <br nodeIndex="931">
usb_fill_bulk_urb (port->write_urb, dev,    <br nodeIndex="932">
usb_sndbulkpipe (dev,    <br nodeIndex="933">
endpoint->bEndpointAddress),    <br nodeIndex="934">
port->bulk_out_buffer, buffer_size,    <br nodeIndex="935">
serial->type->write_bulk_callback,// 在mct_u232_device中定义的批量写回调函数    <br nodeIndex="936">
port);    <br nodeIndex="937">
}</p>
<p brd="1" nodeIndex="130">if (serial->type->read_int_callback) {    <br nodeIndex="938">
for (i = 0; i < num_interrupt_in; ++i) {    <br nodeIndex="939">
endpoint = interrupt_in_endpoint[i];    <br nodeIndex="940">
port = serial->port[i];    <br nodeIndex="941">
port->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);// 申请URB控制结构体    <br nodeIndex="942">
if (!port->interrupt_in_urb) {    <br nodeIndex="943">
dev_err(&interface->dev, "No free urbs available\n");    <br nodeIndex="944">
goto probe_error;    <br nodeIndex="945">
}    <br nodeIndex="946">
buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);    <br nodeIndex="947">
port->interrupt_in_endpointAddress = endpoint->bEndpointAddress;    <br nodeIndex="948">
port->interrupt_in_buffer = kmalloc (buffer_size, GFP_KERNEL);    <br nodeIndex="949">
if (!port->interrupt_in_buffer) {    <br nodeIndex="950">
dev_err(&interface->dev, "Couldn't allocate interrupt_in_buffer\n");    <br nodeIndex="951">
goto probe_error;    <br nodeIndex="952">
}    <br nodeIndex="953">
// 填充上面申请到的interrupt_in_urb URB控制结构体    <br nodeIndex="954">
usb_fill_int_urb (port->interrupt_in_urb, dev,    <br nodeIndex="955">
usb_rcvintpipe (dev,    <br nodeIndex="956">
endpoint->bEndpointAddress),    <br nodeIndex="957">
port->interrupt_in_buffer, buffer_size,    <br nodeIndex="958">
serial->type->read_int_callback, port, // 在mct_u232_device中定义的INT中断读回调函数    <br nodeIndex="959">
endpoint->bInterval);    <br nodeIndex="960">
}    <br nodeIndex="961">
} else if (num_interrupt_in) {    <br nodeIndex="962">
dbg("the device claims to support interrupt in transfers, but read_int_callback is not defined");    <br nodeIndex="963">
}    
if (serial->type->write_int_callback) {    <br nodeIndex="966">
for (i = 0; i < num_interrupt_out; ++i) {    <br nodeIndex="967">
endpoint = interrupt_out_endpoint[i];    <br nodeIndex="968">
port = serial->port[i];    <br nodeIndex="969">
port->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);// 申请URB控制结构体    <br nodeIndex="970">
if (!port->interrupt_out_urb) {    <br nodeIndex="971">
dev_err(&interface->dev, "No free urbs available\n");    <br nodeIndex="972">
goto probe_error;    <br nodeIndex="973">
}    <br nodeIndex="974">
buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);    <br nodeIndex="975">
port->interrupt_out_size = buffer_size;    <br nodeIndex="976">
port->interrupt_out_endpointAddress = endpoint->bEndpointAddress;    <br nodeIndex="977">
port->interrupt_out_buffer = kmalloc (buffer_size, GFP_KERNEL);    <br nodeIndex="978">
if (!port->interrupt_out_buffer) {    <br nodeIndex="979">
dev_err(&interface->dev, "Couldn't allocate interrupt_out_buffer\n");    <br nodeIndex="980">
goto probe_error;    <br nodeIndex="981">
}    <br nodeIndex="982">
// 填充上面申请到的interrupt_out_urb URB控制结构体    <br nodeIndex="983">
usb_fill_int_urb (port->interrupt_out_urb, dev,    <br nodeIndex="984">
usb_sndintpipe (dev,    <br nodeIndex="985">
endpoint->bEndpointAddress),    <br nodeIndex="986">
port->interrupt_out_buffer, buffer_size,    <br nodeIndex="987">
serial->type->write_int_callback, port,// 在mct_u232_device中定义的INT中断写回调函数    <br nodeIndex="988">
endpoint->bInterval);    <br nodeIndex="989">
}    <br nodeIndex="990">
} else if (num_interrupt_out) {    <br nodeIndex="991">
dbg("the device claims to support interrupt out transfers, but write_int_callback is not defined");    <br nodeIndex="992">
}    
/* if this device type has an attach function, call it */    <br nodeIndex="995">
if (type->attach) { // mct_u232_device定义了attach方法的实现 mct_u232_startup    <br nodeIndex="996">
if (!try_module_get(type->driver.owner)) {    <br nodeIndex="997">
dev_err(&interface->dev, "module get failed, exiting\n");    <br nodeIndex="998">
goto probe_error;    <br nodeIndex="999">
}    <br nodeIndex="1000">
retval = type->attach (serial);    <br nodeIndex="1001">
module_put(type->driver.owner);    <br nodeIndex="1002">
if (retval < 0)    <br nodeIndex="1003">
goto probe_error;    <br nodeIndex="1004">
if (retval > 0) {    <br nodeIndex="1005">
/* quietly accept this device, but don't bind to a serial port    <br nodeIndex="1006">
* as it's about to disappear */    <br nodeIndex="1007">
goto exit;    <br nodeIndex="1008">
}    <br nodeIndex="1009">
}</p>
<p brd="1" nodeIndex="131">if (get_free_serial (serial, num_ports, &minor) == NULL) { // 申请次设备号,同时:serial->port[j++]->number = i;    <br nodeIndex="1010">
dev_err(&interface->dev, "No more free serial devices\n");    <br nodeIndex="1011">
goto probe_error;    <br nodeIndex="1012">
}    <br nodeIndex="1013">
serial->minor = minor; // 该serial的次设备号为minor</p>
<p brd="1" nodeIndex="132">/* register all of the individual ports with the driver core */    <br nodeIndex="1014">
for (i = 0; i < num_ports; ++i) {    <br nodeIndex="1015">
port = serial->port[i];    <br nodeIndex="1016">
port->dev.parent = &interface->dev; // 接口当然为端点端口的父object    <br nodeIndex="1017">
port->dev.driver = NULL;    <br nodeIndex="1018">
port->dev.bus = &usb_serial_bus_type; // port位于usb_serial_bus_type总线    <br nodeIndex="1019">
port->dev.release = &port_release;</p>
<p brd="1" nodeIndex="133">snprintf (&port->dev.bus_id[0], sizeof(port->dev.bus_id), "ttyUSB%d", port->number);    <br nodeIndex="1020">
dbg ("%s - registering %s", __FUNCTION__, port->dev.bus_id);    <br nodeIndex="1021">
retval = device_register(&port->dev); // 登记注册该port对应的dev设备信息,同样在bus总线usb_serial_bus_type上执行match动作.    <br nodeIndex="1022">
if (retval)    <br nodeIndex="1023">
dev_err(&port->dev, "Error registering port device, "    <br nodeIndex="1024">
"continuing\n");    <br nodeIndex="1025">
}</p>
<p brd="1" nodeIndex="134">usb_serial_console_init (debug, minor);</p>
<p brd="1" nodeIndex="135">exit:    <br nodeIndex="1026">
/* success */    <br nodeIndex="1027">
usb_set_intfdata (interface, serial);    <br nodeIndex="1028">
return 0;</p>
<p brd="1" nodeIndex="136">probe_error:    <br nodeIndex="1029">
for (i = 0; i < num_bulk_in; ++i) {    <br nodeIndex="1030">
port = serial->port[i];    <br nodeIndex="1031">
if (!port)    <br nodeIndex="1032">
continue;    <br nodeIndex="1033">
usb_free_urb(port->read_urb);    <br nodeIndex="1034">
kfree(port->bulk_in_buffer);    <br nodeIndex="1035">
}    <br nodeIndex="1036">
for (i = 0; i < num_bulk_out; ++i) {    <br nodeIndex="1037">
port = serial->port[i];    <br nodeIndex="1038">
if (!port)    <br nodeIndex="1039">
continue;    <br nodeIndex="1040">
usb_free_urb(port->write_urb);    <br nodeIndex="1041">
kfree(port->bulk_out_buffer);    <br nodeIndex="1042">
}    <br nodeIndex="1043">
for (i = 0; i < num_interrupt_in; ++i) {    <br nodeIndex="1044">
port = serial->port[i];    <br nodeIndex="1045">
if (!port)    <br nodeIndex="1046">
continue;    <br nodeIndex="1047">
usb_free_urb(port->interrupt_in_urb);    <br nodeIndex="1048">
kfree(port->interrupt_in_buffer);    <br nodeIndex="1049">
}    <br nodeIndex="1050">
for (i = 0; i < num_interrupt_out; ++i) {    <br nodeIndex="1051">
port = serial->port[i];    <br nodeIndex="1052">
if (!port)    <br nodeIndex="1053">
continue;    <br nodeIndex="1054">
usb_free_urb(port->interrupt_out_urb);    <br nodeIndex="1055">
kfree(port->interrupt_out_buffer);    <br nodeIndex="1056">
}</p>
<p brd="1" nodeIndex="137">/* free up any memory that we allocated */    <br nodeIndex="1057">
for (i = 0; i < serial->num_port_pointers; ++i)    <br nodeIndex="1058">
kfree(serial->port[i]);    <br nodeIndex="1059">
kfree (serial);    <br nodeIndex="1060">
return -EIO;    <br nodeIndex="1061">
}    <br nodeIndex="1062">
==>usb_serial_bus_type总线驱动port各种端点端口组合结构体    <br nodeIndex="1063">
device_register(&port->dev); // 登记注册该port对应的dev设备信息,同样在bus总线usb_serial_bus_type上执行match动作.    <br nodeIndex="1064">
struct bus_type usb_serial_bus_type = {    <br nodeIndex="1065">
.name = "usb-serial",    <br nodeIndex="1066">
.match = usb_serial_device_match,    <br nodeIndex="1067">
.probe = usb_serial_device_probe,    <br nodeIndex="1068">
.remove = usb_serial_device_remove,    <br nodeIndex="1069">
.drv_attrs = drv_attrs,    <br nodeIndex="1070">
};    <br nodeIndex="1071">
==>usb_serial_device_match    <br nodeIndex="1072">
static int usb_serial_device_match (struct device *dev, struct device_driver *drv)    <br nodeIndex="1073">
{    <br nodeIndex="1074">
struct usb_serial_driver *driver;    <br nodeIndex="1075">
const struct usb_serial_port *port;</p>
<p brd="1" nodeIndex="138">/*    <br nodeIndex="1076">
* drivers are already assigned to ports in serial_probe so it's    <br nodeIndex="1077">
* a simple check here.    <br nodeIndex="1078">
*/    <br nodeIndex="1079">
port = to_usb_serial_port(dev);    <br nodeIndex="1080">
if (!port)    <br nodeIndex="1081">
return 0;</p>
<p brd="1" nodeIndex="139">driver = to_usb_serial_driver(drv);</p>
<p brd="1" nodeIndex="140">if (driver == port->serial->type) // 等于mct_u232_device驱动,那么返回1    <br nodeIndex="1082">
// port->serial在serial = create_serial (dev, interface, type); 中创建.    <br nodeIndex="1083">
// serial->type = driver; // 该serial对应的driver    <br nodeIndex="1084">
return 1;</p>
<p brd="1" nodeIndex="141">return 0;    <br nodeIndex="1085">
}    <br nodeIndex="1086">
==>usb_serial_device_probe    <br nodeIndex="1087">
static int usb_serial_device_probe (struct device *dev)    <br nodeIndex="1088">
{    <br nodeIndex="1089">
struct usb_serial_driver *driver;    <br nodeIndex="1090">
struct usb_serial_port *port;    <br nodeIndex="1091">
int retval = 0;    <br nodeIndex="1092">
int minor;</p>
<p brd="1" nodeIndex="142">port = to_usb_serial_port(dev);    <br nodeIndex="1093">
if (!port) {    <br nodeIndex="1094">
retval = -ENODEV;    <br nodeIndex="1095">
goto exit;    <br nodeIndex="1096">
}</p>
<p brd="1" nodeIndex="143">driver = port->serial->type;    <br nodeIndex="1097">
if (driver->port_probe) { // mct_u232_device没有port_probe    <br nodeIndex="1098">
if (!try_module_get(driver->driver.owner)) {    <br nodeIndex="1099">
dev_err(dev, "module get failed, exiting\n");    <br nodeIndex="1100">
retval = -EIO;    <br nodeIndex="1101">
goto exit;    <br nodeIndex="1102">
}    <br nodeIndex="1103">
retval = driver->port_probe (port);    <br nodeIndex="1104">
module_put(driver->driver.owner);    <br nodeIndex="1105">
if (retval)    <br nodeIndex="1106">
goto exit;    <br nodeIndex="1107">
}</p>
<p brd="1" nodeIndex="144">retval = device_create_file(dev, &dev_attr_port_number); // 创建sysfs文件系统中对应的文件    <br nodeIndex="1108">
if (retval)    <br nodeIndex="1109">
goto exit;</p>
<p brd="1" nodeIndex="145">minor = port->number; // 在上面的get_free_serial函数中执行了serial->port[j++]->number = i;赋值操作,所以可以为 ttyUSB0,ttyUSB1,...    <br nodeIndex="1110">
// port->number就是serial_table[port->number]数组索引号    <br nodeIndex="1111">
tty_register_device (usb_serial_tty_driver, minor, dev); // 注册次设备号为minor的tty设备,该/dev/ttyUSBx设备由usb_serial_tty_driver驱动程序管理    <br nodeIndex="1112">
dev_info(&port->serial->dev->dev,    <br nodeIndex="1113">
"%s converter now attached to ttyUSB%d\n",    <br nodeIndex="1114">
driver->description, minor);</p>
<p brd="1" nodeIndex="146">exit:    <br nodeIndex="1115">
return retval;    <br nodeIndex="1116">
}    <br nodeIndex="1117">
==>tty_register_device(usb_serial_tty_driver, minor, dev);    <br nodeIndex="1118">
// usb_serial_tty_driver在usb_serial_init, 即:module_init(usb_serial_init);    <br nodeIndex="1119">
// usb_serial_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;    <br nodeIndex="1120">
// tty_set_operations(usb_serial_tty_driver, &serial_ops);    <br nodeIndex="1121">
// tty_register_driver(usb_serial_tty_driver);==>list_add(&driver->tty_drivers, &tty_drivers);将自己添加到tty_drivers链表中    <br nodeIndex="1122">
struct device *tty_register_device(struct tty_driver *driver, unsigned index,    <br nodeIndex="1123">
struct device *device)    <br nodeIndex="1124">
{    <br nodeIndex="1125">
char name[64];    <br nodeIndex="1126">
dev_t dev = MKDEV(driver->major, driver->minor_start) + index;</p>
<p brd="1" nodeIndex="147">if (index >= driver->num) {    <br nodeIndex="1127">
printk(KERN_ERR "Attempt to register invalid tty line number "    <br nodeIndex="1128">
" (%d).\n", index);    <br nodeIndex="1129">
return ERR_PTR(-EINVAL);    <br nodeIndex="1130">
}</p>
<p brd="1" nodeIndex="148">if (driver->type == TTY_DRIVER_TYPE_PTY)    <br nodeIndex="1131">
pty_line_name(driver, index, name);    <br nodeIndex="1132">
else    <br nodeIndex="1133">
tty_line_name(driver, index, name); // 非pty设备</p>
<p brd="1" nodeIndex="149">return device_create(tty_class, device, dev, name);    <br nodeIndex="1134">
// 创建sysfs文件系统下的文件,同时uevent到用户空间,创建/dev/ttyUSB0... 等    <br nodeIndex="1135">
// 对/dev/ttyUSB0...等操作方法为tty_fops    <br nodeIndex="1136">
// /dev/ttyUSB0...等在SERIAL_TTY_MAJOR ~ SERIAL_TTY_MAJOR + SERIAL_TTY_MINORS之间的设备号读写操作均由 tty_fops    <br nodeIndex="1137">
// 方法集提供,    <br nodeIndex="1138">
// tty_register_driver(usb_serial_tty_driver);    <br nodeIndex="1139">
// 比如open    <br nodeIndex="1140">
// tty_open==>tty->driver->open 即:serial_ops.serial_open    <br nodeIndex="1141">
}    <br nodeIndex="1142">
==>tty_register_driver(usb_serial_tty_driver); // 注册驱动/dev/xxx字符设备的tty驱动程序    <br nodeIndex="1143">
dev = MKDEV(driver->major, driver->minor_start);    <br nodeIndex="1144">
error = register_chrdev_region(dev, driver->num, driver->name); // 设备号从dev到dev+driver->num个字符设备都将由该driver驱动    <br nodeIndex="1145">
cdev_init(&driver->cdev, &tty_fops); // 注册该MAJOR到MINOR之间的/dev/xxx字符设备节点对应的操作函数集为 tty_fops    <br nodeIndex="1146">
cdev_add(&driver->cdev, dev, driver->num); // 添加到字符管理数值中    <br nodeIndex="1147">
static const struct file_operations tty_fops = {    <br nodeIndex="1148">
.llseek = no_llseek,    <br nodeIndex="1149">
.read = tty_read,    <br nodeIndex="1150">
.write = tty_write,    <br nodeIndex="1151">
.poll = tty_poll,    <br nodeIndex="1152">
.ioctl = tty_ioctl,    <br nodeIndex="1153">
.compat_ioctl = tty_compat_ioctl,    <br nodeIndex="1154">
.open = tty_open,    <br nodeIndex="1155">
.release = tty_release,    <br nodeIndex="1156">
.fasync = tty_fasync,    <br nodeIndex="1157">
};    <br nodeIndex="1158">
==>cdev_add    <br nodeIndex="1159">
int cdev_add(struct cdev *p, dev_t dev, unsigned count)    <br nodeIndex="1160">
{    <br nodeIndex="1161">
p->dev = dev;    <br nodeIndex="1162">
p->count = count;    <br nodeIndex="1163">
return kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, p); // 将&driver->cdev添加到cdev_map字符设备驱动管理数组中,以备下面sys_open时 kobj_lookup使用    <br nodeIndex="1164">
}</p>
<p brd="1" nodeIndex="150">看看系统调用open函数    <br nodeIndex="1165">
open("/dev/ttyUSB0")    <br nodeIndex="1166">
==>chrdev_open // sys_open将调用字符设备驱动函数集中open函数chrdev_open    <br nodeIndex="1167">
const struct file_operations def_chr_fops = {    <br nodeIndex="1168">
.open = chrdev_open,    <br nodeIndex="1169">
};    <br nodeIndex="1170">
==>kobj = kobj_lookup(cdev_map, inode->i_rdev, &idx); // 搜索上面cdev_add登记的usb_serial_tty_driver驱动 调用exact_match返回&driver->cdev.kobj    <br nodeIndex="1171">
new = container_of(kobj, struct cdev, kobj);    <br nodeIndex="1172">
inode->i_cdev = p = new; // 由上面cdev_init(&driver->cdev, &tty_fops); 初始化cdev->ops = &tty_fops    <br nodeIndex="1173">
filp->f_op = fops_get(p->ops); // 获取驱动方法集    <br nodeIndex="1174">
filp->f_op->open(inode,filp);    <br nodeIndex="1175">
==>tty_open同时在tty_drivers链表上调用get_tty_driver函数搜索,    <br nodeIndex="1176">
"/dev/ttyUSB0"设备节点号对应的tty_drivers,比如搜索到usb_serial_tty_driver驱动,    <br nodeIndex="1177">
那么它就是tty->driver了.同时生成tty:init_dev(driver, index, &tty);其中index表示该字符设备为驱动管理的第index索引处设备.    <br nodeIndex="1178">
之后init_dev==>tty = alloc_tty_struct();    <br nodeIndex="1179">
==>initialize_tty_struct(tty); // 初始化该tty的ldisc等于tty_ldisc_N_TTY即tty->ldisc = &tty_ldisc_N_TTY;    <br nodeIndex="1180">
tty_ldisc_assign(tty, tty_ldisc_get(N_TTY));为tty->ldisc绑定线路规程    <br nodeIndex="1181">
console_init==>注册tty_ldisc_N_TTY线路规程    <br nodeIndex="1182">
& nbsp; tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);    <br nodeIndex="1183">
struct tty_ldisc tty_ldisc_N_TTY = {    <br nodeIndex="1184">
.magic = TTY_LDISC_MAGIC,    <br nodeIndex="1185">
.name = "n_tty",    <br nodeIndex="1186">
.open = n_tty_open,    <br nodeIndex="1187">
.close = n_tty_close,    <br nodeIndex="1188">
.flush_buffer = n_tty_flush_buffer,    <br nodeIndex="1189">
.chars_in_buffer = n_tty_chars_in_buffer,    <br nodeIndex="1190">
.read = read_chan,    <br nodeIndex="1191">
.write = write_chan,    <br nodeIndex="1192">
.ioctl = n_tty_ioctl,    <br nodeIndex="1193">
.set_termios = n_tty_set_termios,    <br nodeIndex="1194">
.poll = normal_poll,    <br nodeIndex="1195">
.receive_buf = n_tty_receive_buf,    <br nodeIndex="1196">
.write_wakeup = n_tty_write_wakeup    <br nodeIndex="1197">
};    <br nodeIndex="1198">
==>tty->driver = driver;    <br nodeIndex="1199">
==>tty->index = idx; // 该tty在driver中的索引值    <br nodeIndex="1200">
==>tty_line_name(driver, idx, tty->name);    <br nodeIndex="1201">
==>driver->ttys[idx] = tty; // dirver管理的第index个设备指针    <br nodeIndex="1202">
==>(tty->ldisc.open)(tty); // 调用tty_ldisc_N_TTY.open即n_tty_open函数    <br nodeIndex="1203">
之后filp->private_data = tty;    <br nodeIndex="1204">
之后tty->driver->open    <br nodeIndex="1205">
==>tty-> driver->open就是usb_serial_tty_driver.open 即:serial_ops.serial_open    <br nodeIndex="1206">
==>serial_open // 执行设备实际打开操作    <br nodeIndex="1207">
static int serial_open (struct tty_struct *tty, struct file * filp)    <br nodeIndex="1208">
{    <br nodeIndex="1209">
struct usb_serial *serial;    <br nodeIndex="1210">
struct usb_serial_port *port;    <br nodeIndex="1211">
unsigned int portNumber;    <br nodeIndex="1212">
int retval;    
dbg("%s", __FUNCTION__);</p>
<p brd="1" nodeIndex="151">/* get the serial object associated with this tty pointer */    <br nodeIndex="1215">
serial = usb_serial_get_by_index(tty->index); // 就是 return serial_table[index];因为driver的串口索引就等于serial_table数组的索引.    <br nodeIndex="1216">
if (!serial) {    <br nodeIndex="1217">
tty->driver_data = NULL;    <br nodeIndex="1218">
return -ENODEV;    <br nodeIndex="1219">
}</p>
<p brd="1" nodeIndex="152">portNumber = tty->index - serial->minor; // 端口号为当前dev设备的串口索引index减去该serial设备登记的起始索引值,比如一个    <br nodeIndex="1220">
// serial设备可以有多个port,比如有3个,那么portNumber就可能等于0,1或者2.    <br nodeIndex="1221">
port = serial->port[portNumber]; // 获取'/dev/ttyUSBx'对应的port    <br nodeIndex="1222">
if (!port) {    <br nodeIndex="1223">
retval = -ENODEV;    <br nodeIndex="1224">
goto bailout_kref_put;    <br nodeIndex="1225">
}</p>
<p brd="1" nodeIndex="153">if (mutex_lock_interruptible(&port->mutex)) {    <br nodeIndex="1226">
retval = -ERESTARTSYS;    <br nodeIndex="1227">
goto bailout_kref_put;    <br nodeIndex="1228">
}    
++port->open_count;</p>
<p brd="1" nodeIndex="154">/* set up our port structure making the tty driver    <br nodeIndex="1231">
* remember our port object, and us it */    <br nodeIndex="1232">
tty->driver_data = port; // 驱动driver_data似有数据为port    <br nodeIndex="1233">
port->tty = tty; // 该port服务于该tty</p>
<p brd="1" nodeIndex="155">if (port->open_count == 1) { // 第1次打开</p>
<p brd="1" nodeIndex="156">/* lock this module before we call it    <br nodeIndex="1234">
* this may fail, which means we must bail out,    <br nodeIndex="1235">
* safe because we are called with BKL held */    <br nodeIndex="1236">
if (!try_module_get(serial->type->driver.owner)) {    <br nodeIndex="1237">
retval = -ENODEV;    <br nodeIndex="1238">
goto bailout_mutex_unlock;    <br nodeIndex="1239">
}</p>
<p brd="1" nodeIndex="157">retval = usb_autopm_get_interface(serial->interface);    <br nodeIndex="1240">
if (retval)    <br nodeIndex="1241">
goto bailout_module_put;    <br nodeIndex="1242">
/* only call the device specific open if this    <br nodeIndex="1243">
* is the first time the port is opened */    <br nodeIndex="1244">
retval = serial->type->open(port, filp); // 执行mct_u232_device.open 即:mct_u232_open    <br nodeIndex="1245">
if (retval)    <br nodeIndex="1246">
goto bailout_interface_put;    <br nodeIndex="1247">
}</p>
<p brd="1" nodeIndex="158">mutex_unlock(&port->mutex);    <br nodeIndex="1248">
return 0; // ok,至此sys_open工作就算彻底完成了</p>
<p brd="1" nodeIndex="159">bailout_interface_put:    <br nodeIndex="1249">
usb_autopm_put_interface(serial->interface);    <br nodeIndex="1250">
bailout_module_put:    <br nodeIndex="1251">
module_put(serial->type->driver.owner);    <br nodeIndex="1252">
bailout_mutex_unlock:    <br nodeIndex="1253">
port->open_count = 0;    <br nodeIndex="1254">
tty->driver_data = NULL;    <br nodeIndex="1255">
port->tty = NULL;    <br nodeIndex="1256">
mutex_unlock(&port->mutex);    <br nodeIndex="1257">
bailout_kref_put:    <br nodeIndex="1258">
usb_serial_put(serial);    <br nodeIndex="1259">
return retval;    <br nodeIndex="1260">
}</p>
<p brd="1" nodeIndex="160">tty_write    <br nodeIndex="1261">
==>do_tty_write(ld->write, tty, file, buf, count);调用线路规程tty_ldisc_N_TTY的write函数write_chan    <br nodeIndex="1262">
==> write_chan    <br nodeIndex="1263">
==>tty->driver->write(tty, b, nr);就是上面的usb_serial_tty_driver.write 即:serial_ops.serial_write    <br nodeIndex="1264">
==>serial_write将调用port-& gt;serial->type->write(port, buf, count);就是mct_u232_device的write函数    <br nodeIndex="1265">
在usb_serial_register(&mct_u232_device);中将使用 fixup_generic(driver);函数填充mct_u232_device未定义的操作函数集.    <br nodeIndex="1266">
所以mct_u232_device的write函数为usb_serial_generic_write    <br nodeIndex="1267">
==> mct_u232_device.write即:usb_serial_generic_write    <br nodeIndex="1268">
==> usb_serial_generic_write    <br nodeIndex="1269">
==>usb_submit_urb(port->write_urb, GFP_ATOMIC); // 提交一个URB    <br nodeIndex="1270">
==>usb_hcd_submit_urb(urb, mem_flags);    <br nodeIndex="1271">
==>hcd->driver->urb_enqueue(hcd, urb, mem_flags);</p>
<p brd="1" nodeIndex="161">tty_read    <br nodeIndex="1272">
==>(ld->read)(tty, file, buf, count);调用线路规程tty_ldisc_N_TTY的read函数read_chan    <br nodeIndex="1273">
==> read_chan    <br nodeIndex="1274">
在mct_u232_device中定义了mct_u232_read_int_callback,即中断IN回调函数,当usb转串口设备从usb接口接收到数据之后,    <br nodeIndex="1275">
它将执行mct_u232_read_int_callback回调函数,    <br nodeIndex="1276">
static void mct_u232_read_int_callback (struct urb *urb)    <br nodeIndex="1277">
{    <br nodeIndex="1278">
struct usb_serial_port *port = (struct usb_serial_port *)urb->context;    <br nodeIndex="1279">
struct mct_u232_private *priv = usb_get_serial_port_data(port);    <br nodeIndex="1280">
struct usb_serial *serial = port->serial;    <br nodeIndex="1281">
struct tty_struct *tty;    <br nodeIndex="1282">
unsigned char *data = urb->transfer_buffer;    <br nodeIndex="1283">
int retval;    <br nodeIndex="1284">
int status = urb->status;    <br nodeIndex="1285">
unsigned long flags;</p>
<p brd="1" nodeIndex="162">switch (status) {    <br nodeIndex="1286">
case 0:    <br nodeIndex="1287">
/* success */    <br nodeIndex="1288">
break;    <br nodeIndex="1289">
case -ECONNRESET:    <br nodeIndex="1290">
case -ENOENT:    <br nodeIndex="1291">
case -ESHUTDOWN:    <br nodeIndex="1292">
/* this urb is terminated, clean up */    <br nodeIndex="1293">
dbg("%s - urb shutting down with status: %d",    <br nodeIndex="1294">
__FUNCTION__, status);    <br nodeIndex="1295">
return;    <br nodeIndex="1296">
default:    <br nodeIndex="1297">
dbg("%s - nonzero urb status received: %d",    <br nodeIndex="1298">
__FUNCTION__, status);    <br nodeIndex="1299">
goto exit;    <br nodeIndex="1300">
}</p>
<p brd="1" nodeIndex="163">if (!serial) {    <br nodeIndex="1301">
dbg("%s - bad serial pointer, exiting", __FUNCTION__);    <br nodeIndex="1302">
return;    <br nodeIndex="1303">
}</p>
<p brd="1" nodeIndex="164">dbg("%s - port %d", __FUNCTION__, port->number);    <br nodeIndex="1304">
usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);</p>
<p brd="1" nodeIndex="165">/*    <br nodeIndex="1305">
* Work-a-round: handle the 'usual' bulk-in pipe here    <br nodeIndex="1306">
*/    <br nodeIndex="1307">
if (urb->transfer_buffer_length > 2) {    <br nodeIndex="1308">
int i;    <br nodeIndex="1309">
tty = port->tty;    <br nodeIndex="1310">
if (urb->actual_length) {    <br nodeIndex="1311">
for (i = 0; i < urb->actual_length ; ++i) {    <br nodeIndex="1312">
tty_insert_flip_char(tty, data[i], 0); // 将从usb接收到的数据放入tty缓冲区中    <br nodeIndex="1313">
}    <br nodeIndex="1314">
tty_flip_buffer_push(tty); // 唤醒pending着的read_chan函数,这样tty就收到数据了    <br nodeIndex="1315">
}    <br nodeIndex="1316">
goto exit;    <br nodeIndex="1317">
}    
/*    <br nodeIndex="1320">
* The interrupt-in pipe signals exceptional conditions (modem line    <br nodeIndex="1321">
* signal changes and errors). data[0] holds MSR, data[1] holds LSR.    <br nodeIndex="1322">
*/    <br nodeIndex="1323">
spin_lock_irqsave(&priv->lock, flags);    <br nodeIndex="1324">
priv->last_msr = data[MCT_U232_MSR_INDEX];    
/* Record Control Line states */    <br nodeIndex="1327">
mct_u232_msr_to_state(&priv->control_state, priv->last_msr);</p>
<p brd="1" nodeIndex="166">#if 0    <br nodeIndex="1328">
/* Not yet handled. See belin_sa.c for further information */    <br nodeIndex="1329">
/* Now to report any errors */    <br nodeIndex="1330">
priv->last_lsr = data[MCT_U232_LSR_INDEX];    <br nodeIndex="1331">
/*    <br nodeIndex="1332">
* fill in the flip buffer here, but I do not know the relation    <br nodeIndex="1333">
* to the current/next receive buffer or characters. I need    <br nodeIndex="1334">
* to look in to this before committing any code.    <br nodeIndex="1335">
*/    <br nodeIndex="1336">
if (priv->last_lsr & MCT_U232_LSR_ERR) {    <br nodeIndex="1337">
tty = port->tty;    <br nodeIndex="1338">
/* Overrun Error */    <br nodeIndex="1339">
if (priv->last_lsr & MCT_U232_LSR_OE) {    <br nodeIndex="1340">
}    <br nodeIndex="1341">
/* Parity Error */    <br nodeIndex="1342">
if (priv->last_lsr & MCT_U232_LSR_PE) {    <br nodeIndex="1343">
}    <br nodeIndex="1344">
/* Framing Error */    <br nodeIndex="1345">
if (priv->last_lsr & MCT_U232_LSR_FE) {    <br nodeIndex="1346">
}    <br nodeIndex="1347">
/* Break Indicator */    <br nodeIndex="1348">
if (priv->last_lsr & MCT_U232_LSR_BI) {    <br nodeIndex="1349">
}    <br nodeIndex="1350">
}    <br nodeIndex="1351">
#endif    <br nodeIndex="1352">
spin_unlock_irqrestore(&priv->lock, flags);    <br nodeIndex="1353">
exit:    <br nodeIndex="1354">
retval = usb_submit_urb (urb, GFP_ATOMIC);    <br nodeIndex="1355">
if (retval)    <br nodeIndex="1356">
err ("%s - usb_submit_urb failed with result %d",    <br nodeIndex="1357">
__FUNCTION__, retval);    <br nodeIndex="1358">
}</p>
<p brd="1" nodeIndex="167">todo ...</p>
<p brd="1" nodeIndex="168">mct_u232_device 驱动位于usb_serial_bus_type总线上,mct_u232_driver驱动位于usb_bus_type总线上,当hub发现usb新 硬件之后,会首先调用usb_bus_type总线上的mct_u232_driver驱动的probe(),也就是 usb_serial_probe(),在usb_serial_probe()中,程序会遍历usb_serial_driver_list驱动链表的 所有驱动,并usb_serial_driver_list尝试和发现的新硬件进行匹配,在计算匹配的过程中会调 用,drv->bus->match,即:usb_serial_bus_type->match()和 dev->bus->probe或者drv->probe 即:usb_serial_device_probe(),这样设备就和分别 处在两条独立总线上的mct_u232_driver驱动以及mct_u232_device驱动关联上了</p>
</div>