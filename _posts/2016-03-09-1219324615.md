---
layout: post
title: Linux 守护进程的启动方法
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=417176152&idx=1&sn=5e78612f57e3cf369e8dd126a20ea090&scene=0#wechat_redirect

收藏时间：2016-03-09 23:41:16

<div  >
            
                        <div id="img-content" nodeIndex="5">
                
                
                <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="10">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">LinuxHub</span>
                            </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">「Linux爱好者」专注分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。</span>
                            </p>
                                
                
                
                
                                                
                                                                
                
                <div class="rich_media_content " id="js_content" nodeIndex="12">
                    

                    

                    
                    
                    <p class=" _RIL_KEEPER_CLASS_" nodeIndex="13"><span nodeIndex="360">（点击</span><span nodeIndex="361">上方公众号</span><span nodeIndex="362">，可快速关注）</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="14"><span nodeIndex="363"><br nodeIndex="364"></span></p><blockquote nodeIndex="15"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="16"><span nodeIndex="365">来自：阮一峰的网络日志</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="17"><span nodeIndex="366">链接：http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="18"><br nodeIndex="367"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="19">“守护进程”（daemon）就是一直在后台运行的进程（daemon）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="20"><br nodeIndex="368"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="21">本文介绍如何将一个 Web 应用，启动为守护进程。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="22"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2016-03-09-1219324615/1"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="23"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="369"><span nodeIndex="370">一、问题的由来</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="24"><br nodeIndex="371"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="25">Web应用写好后，下一件事就是启动，让它一直在后台运行。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="26"><br nodeIndex="372"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="27">这并不容易。举例来说，下面是一个最简单的Node应用server.js，只有6行。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="28"><br nodeIndex="373"></p><blockquote nodeIndex="29"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="30"><span nodeIndex="374">var http = require('http');</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="31"><br nodeIndex="375"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="32"><span nodeIndex="376">http.createServer(function(req, res) {</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="33"><span nodeIndex="377">  res.writeHead(200, {'Content-Type': 'text/plain'});</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34"><span nodeIndex="378">  res.end('Hello World');</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="35"><span nodeIndex="379">}).listen(5000);</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="36"><br nodeIndex="380"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="37">你在命令行下启动它。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="38"><br nodeIndex="381"></p><blockquote nodeIndex="39"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="40"><span nodeIndex="382">$ node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="41"><br nodeIndex="383"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="42">看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="43"><br nodeIndex="384"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="44">怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="45"><br nodeIndex="385"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="46"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="386"><span nodeIndex="387">二、前台任务与后台任务</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="47"><br nodeIndex="388"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="48">上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="49"><br nodeIndex="389"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="50">变成守护进程的第一步，就是把它改成”后台任务”（background job）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="51"><br nodeIndex="390"></p><blockquote nodeIndex="52"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><span nodeIndex="391">$ node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="54"><br nodeIndex="392"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="55">只要在命令的尾部加上符号&，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按ctrl + z，然后执行bg命令（让最近一个暂停的”后台任务”继续执行）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="56"><br nodeIndex="393"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="57">“后台任务”有两个特点。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="58"><br nodeIndex="394"></p><ol class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="60"><li nodeIndex="59"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="61">继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。</p></li><li nodeIndex="62"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><span nodeIndex="395">不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。</span></p></li></ol><p class=" _RIL_KEEPER_CLASS_" nodeIndex="64"><br nodeIndex="396"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="65">可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="66"><br nodeIndex="397"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="67"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="398"><span nodeIndex="399">三、SIGHUP信号</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="68"><br nodeIndex="400"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="69">变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="70"><br nodeIndex="401"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="71">Linux系统是这样设计的。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="72"><br nodeIndex="402"></p><ol class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="74"><li nodeIndex="73"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="75">用户准备退出 session</p></li><li nodeIndex="76"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="77">系统向该 session 发出SIGHUP信号</p></li><li nodeIndex="78"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="79">session 将SIGHUP信号发给所有子进程</p></li><li nodeIndex="80"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="81">子进程收到SIGHUP信号后，自动退出</p></li></ol><p class=" _RIL_KEEPER_CLASS_" nodeIndex="82"><br nodeIndex="403"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="83">上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了SIGHUP信号。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="84"><br nodeIndex="404"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="85">那么，”后台任务”是否也会收到SIGHUP信号？</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="86"><br nodeIndex="405"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="87">这由 Shell 的huponexit参数决定的。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="88"><br nodeIndex="406"></p><blockquote nodeIndex="89"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="90"><span nodeIndex="407">$ shopt | grep huponexit</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="91"><br nodeIndex="408"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="92">执行上面的命令，就会看到huponexit参数的值。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="93"><br nodeIndex="409"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="94">大多数Linux系统，这个参数默认关闭（off）。因此，session 退出的时候，不会把SIGHUP信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="95"><br nodeIndex="410"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="96"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="411"><span nodeIndex="412">四、disown 命令</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="97"><br nodeIndex="413"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="98">通过”后台任务”启动”守护进程”并不保险，因为有的系统的huponexit参数可能是打开的（on）。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="99"><br nodeIndex="414"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100">更保险的方法是使用disown命令。它可以将指定任务从”后台任务”列表（jobs命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出SIGHUP信号。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="101"><br nodeIndex="415"></p><blockquote nodeIndex="102"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="103"><span nodeIndex="416">$ node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="104"><br nodeIndex="417"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="105">执行上面的命令以后，server.js进程就被移出了”后台任务”列表。你可以执行jobs命令验证，输出结果里面，不会有这个进程。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="106"><br nodeIndex="418"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="107">disown的用法如下。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="108"><br nodeIndex="419"></p><blockquote nodeIndex="109"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="110"><span nodeIndex="420"># 移出最近一个正在执行的后台任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="111"><span nodeIndex="421">$ disown</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="112"><br nodeIndex="422"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="113"><span nodeIndex="423"># 移出所有正在执行的后台任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="114"><span nodeIndex="424">$ disown -r</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="115"><br nodeIndex="425"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="116"><span nodeIndex="426"># 移出所有后台任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="117"><span nodeIndex="427">$ disown -a</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="118"><br nodeIndex="428"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="119"><span nodeIndex="429"># 不移出后台任务，但是让它们不会收到SIGHUP信号</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="120"><span nodeIndex="430">$ disown -h</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="121"><br nodeIndex="431"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="122"><span nodeIndex="432"># 根据jobId，移出指定的后台任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="123"><span nodeIndex="433">$ disown %2</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="124"><span nodeIndex="434">$ disown -h %2</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="125"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="435"><span nodeIndex="436"><br nodeIndex="437"></span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="126"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="438"><span nodeIndex="439">五、标准 I/O</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="127"><br nodeIndex="440"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="128">使用disown命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="129"><br nodeIndex="441"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="130">还是以上面的脚本为例，现在加入一行。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="131"><br nodeIndex="442"></p><blockquote nodeIndex="132"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="133"><span nodeIndex="443">var http = require('http');</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="134"><br nodeIndex="444"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="135"><span nodeIndex="445">http.createServer(function(req, res) {</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="136"><span nodeIndex="446">  console.log('server starts...'); // 加入此行</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="137"><span nodeIndex="447">  res.writeHead(200, {'Content-Type': 'text/plain'});</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="138"><span nodeIndex="448">  res.end('Hello World');</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="139"><span nodeIndex="449">}).listen(5000);</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="140"><br nodeIndex="450"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="141">启动上面的脚本，然后再执行disown命令。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="142"><br nodeIndex="451"></p><blockquote nodeIndex="143"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="144"><span nodeIndex="452">$ node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="145"><br nodeIndex="453"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="146">接着，你退出 session，访问5000端口，就会发现连不上。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="147"><br nodeIndex="454"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="148">这是因为”后台任务”的标准 I/O 继承自当前 session，disown命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="149"><br nodeIndex="455"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="150">为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="151"><br nodeIndex="456"></p><blockquote nodeIndex="152"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="153"><span nodeIndex="457">$ node server.js > stdout.txt 2> stderr.txt</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="154"><br nodeIndex="458"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="155">上面这样执行，基本上就没有问题了。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="156"><br nodeIndex="459"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="157"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="460"><span nodeIndex="461">六、nohup 命令</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="158"><br nodeIndex="462"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="159">还有比disown更方便的命令，就是nohup。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="160"><br nodeIndex="463"></p><blockquote nodeIndex="161"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="162"><span nodeIndex="464">$ nohup node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="163"><br nodeIndex="465"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="164">nohup命令对server.js进程做了三件事。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="165"><br nodeIndex="466"></p><ul class=" list-paddingleft-2 _RIL_KEEPER_CLASS_" nodeIndex="167"><li nodeIndex="166"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="168">阻止SIGHUP信号发到这个进程。</p></li><li nodeIndex="169"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="170">关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。</p></li><li nodeIndex="171"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="172">重定向标准输出和标准错误到文件nohup.out。</p></li></ul><p class=" _RIL_KEEPER_CLASS_" nodeIndex="173"><br nodeIndex="467"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="174">也就是说，nohup命令实际上将子进程与它所在的 session 分离了。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="175">注意，nohup命令不会自动把进程变为”后台任务”，所以必须加上&符号。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="176"><br nodeIndex="468"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="177"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="469"><span nodeIndex="470">七、Screen 命令与 Tmux 命令</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="178"><br nodeIndex="471"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="179">另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 Screen 命令和 Tmux 命令。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="180"><br nodeIndex="472"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="181">它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="182"><br nodeIndex="473"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="183">Screen 的用法如下。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="184"><br nodeIndex="474"></p><blockquote nodeIndex="185"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="186"><span nodeIndex="475"># 新建一个 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="187"><span nodeIndex="476">$ screen</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="188"><span nodeIndex="477">$ node server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="189"><br nodeIndex="478"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="190">然后，按下ctrl + A和ctrl + D，回到原来的 session，从那里退出登录。下次登录时，再切回去。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="191"><br nodeIndex="479"></p><blockquote nodeIndex="192"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="193"><span nodeIndex="480">$ screen -r</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="194"><br nodeIndex="481"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="195">如果新建多个后台 session，就需要为它们指定名字。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="196"><br nodeIndex="482"></p><blockquote nodeIndex="197"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="198"><span nodeIndex="483">$ screen -S name</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="199"><br nodeIndex="484"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="200"><span nodeIndex="485"># 切回指定 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="201"><span nodeIndex="486">$ screen -r name</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="202"><span nodeIndex="487">$ screen -r pid_number</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="203"><br nodeIndex="488"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="204"><span nodeIndex="489"># 列出所有 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="205"><span nodeIndex="490">$ screen -ls</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="206"><br nodeIndex="491"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="207">如果要停掉某个 session，可以先切回它，然后按下ctrl + c和ctrl + d。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="208"><br nodeIndex="492"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="209">Tmux 比 Screen 功能更多、更强大，它的基本用法如下。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="210"><br nodeIndex="493"></p><blockquote nodeIndex="211"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="212"><span nodeIndex="494">$ tmux</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="213"><span nodeIndex="495">$ node server.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="214"><br nodeIndex="496"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="215"><span nodeIndex="497"># 返回原来的session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="216"><span nodeIndex="498">$ tmux detach</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="217"><br nodeIndex="499"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="218">除了tmux detach，另一种方法是按下Ctrl + B和d ，也可以回到原来的 session。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="219"><br nodeIndex="500"></p><blockquote nodeIndex="220"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="221"><span nodeIndex="501"># 下次登录时，返回后台正在运行服务session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="222"><span nodeIndex="502">$ tmux attach</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="223"><br nodeIndex="503"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="224">如果新建多个 session，就需要为每个 session 指定名字。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="225"><br nodeIndex="504"></p><blockquote nodeIndex="226"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="227"><span nodeIndex="505"># 新建 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="228"><span nodeIndex="506">$ tmux new -s session_name</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="229"><br nodeIndex="507"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="230"><span nodeIndex="508"># 切换到指定 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="231"><span nodeIndex="509">$ tmux attach -t session_name</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="232"><br nodeIndex="510"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="233"><span nodeIndex="511"># 列出所有 session</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="234"><span nodeIndex="512">$ tmux list-sessions</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="235"><br nodeIndex="513"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="236"><span nodeIndex="514"># 退出当前 session，返回前一个 session </span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="237"><span nodeIndex="515">$ tmux detach</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="238"><br nodeIndex="516"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="239"><span nodeIndex="517"># 杀死指定 session</span></p></blockquote><blockquote nodeIndex="240"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="241"><span nodeIndex="518">$ tmux kill-session -t session-name</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="242"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="519"><span nodeIndex="520"><br nodeIndex="521"></span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="243"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="522"><span nodeIndex="523">八、Node 工具</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="244"><br nodeIndex="524"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="245">对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：forever，nodemon 和 pm2。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="246"><br nodeIndex="525"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="247">forever 的功能很简单，就是保证进程退出时，应用会自动重启。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="248"><br nodeIndex="526"></p><blockquote nodeIndex="249"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="250"><span nodeIndex="527"># 作为前台任务启动</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="251"><span nodeIndex="528">$ forever server.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="252"><br nodeIndex="529"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="253"><span nodeIndex="530"># 作为服务进程启动 </span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="254"><span nodeIndex="531">$ forever start app.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="255"><br nodeIndex="532"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="256"><span nodeIndex="533"># 停止服务进程</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="257"><span nodeIndex="534">$ forever stop Id</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="258"><br nodeIndex="535"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="259"><span nodeIndex="536"># 重启服务进程</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="260"><span nodeIndex="537">$ forever restart Id</span></p></blockquote><blockquote nodeIndex="261"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="262"><br nodeIndex="538"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="263"><span nodeIndex="539"># 监视当前目录的文件变动，一有变动就重启</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="264"><span nodeIndex="540">$ forever -w server.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="265"><br nodeIndex="541"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="266"><span nodeIndex="542"># -m 参数指定最多重启次数</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="267"><span nodeIndex="543">$ forever -m 5 server.js </span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="268"><br nodeIndex="544"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="269"><span nodeIndex="545"># 列出所有进程</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="270"><span nodeIndex="546">$ forever list</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="271"><br nodeIndex="547"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="272">nodemon一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="273"><br nodeIndex="548"></p><blockquote nodeIndex="274"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="275"><span nodeIndex="549"># 默认监视当前目录的文件变化</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="276"><span nodeIndex="550">$ nodemon server.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="277"><br nodeIndex="551"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="278"><span nodeIndex="552">＃ 监视指定文件的变化   </span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="279"><span nodeIndex="553">$ nodemon --watch app --watch libs server.js</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="280"><br nodeIndex="554"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="281">pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="282"><br nodeIndex="555"></p><blockquote nodeIndex="283"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="284"><span nodeIndex="556"># 启动应用</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="285"><span nodeIndex="557">$ pm2 start app.js</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="286"><br nodeIndex="558"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="287"><span nodeIndex="559"># 指定同时起多少个进程（由CPU核心数决定），组成一个集群</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="288"><span nodeIndex="560">$ pm2 start app.js -i max</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="289"><br nodeIndex="561"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="290"><span nodeIndex="562"># 列出所有任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="291"><span nodeIndex="563">$ pm2 list</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="292"><br nodeIndex="564"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="293"><span nodeIndex="565"># 停止指定任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="294"><span nodeIndex="566">$ pm2 stop 0</span></p></blockquote><blockquote nodeIndex="295"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="296"><br nodeIndex="567"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="297"><span nodeIndex="568">＃ 重启指定任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="298"><span nodeIndex="569">$ pm2 restart 0</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="299"><br nodeIndex="570"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="300"><span nodeIndex="571"># 删除指定任务</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="301"><span nodeIndex="572">$ pm2 delete 0</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="302"><br nodeIndex="573"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="303"><span nodeIndex="574"># 保存当前的所有任务，以后可以恢复</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="304"><span nodeIndex="575">$ pm2 save</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="305"><br nodeIndex="576"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="306"><span nodeIndex="577"># 列出每个进程的统计数据</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="307"><span nodeIndex="578">$ pm2 monit</span></p></blockquote><blockquote nodeIndex="308"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="309"><br nodeIndex="579"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="310"><span nodeIndex="580"># 查看所有日志</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="311"><span nodeIndex="581">$ pm2 logs</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="312"><br nodeIndex="582"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="313"><span nodeIndex="583"># 导出数据</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="314"><span nodeIndex="584">$ pm2 dump</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="315"><br nodeIndex="585"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="316"><span nodeIndex="586"># 重启所有进程</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="317"><span nodeIndex="587">$ pm2 kill</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="318"><span nodeIndex="588">$ pm2 resurect</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="319"><br nodeIndex="589"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="320"><span nodeIndex="590"># 启动web界面 http://localhost:9615</span></p></blockquote><blockquote nodeIndex="321"><p class=" _RIL_KEEPER_CLASS_" nodeIndex="322"><span nodeIndex="591">$ pm2 web</span></p></blockquote><p class=" _RIL_KEEPER_CLASS_" nodeIndex="323"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="592"><span nodeIndex="593"><br nodeIndex="594"></span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="324"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="595"><span nodeIndex="596">九、Systemd</span></strong></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="325"><br nodeIndex="597"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="326">除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。</p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="327"><br nodeIndex="598"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="328"><span nodeIndex="599">【今日微信公号推荐↓</span><span nodeIndex="600">】</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="329"><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2016-03-09-1219324615/2"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="330"><span nodeIndex="601">更多推荐请看</span><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="602"><span nodeIndex="603">《</span></strong><a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=415754379&idx=1&sn=fabfe6514dc817145df3bac5a8c571b3&scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=415754379&idx=1&sn=fabfe6514dc817145df3bac5a8c571b3&scene=21#wechat_redirect" nodeIndex="604"><span nodeIndex="605">值得关注的技术和设计公众号</span></a><span nodeIndex="606"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="607"><span nodeIndex="608">》</span></strong></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="331"><span nodeIndex="609"><br nodeIndex="610"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="332"><span nodeIndex="611">其中推荐了包括<strong class=" _RIL_KEEPER_CLASS_" nodeIndex="612">技术</strong>、<strong class=" _RIL_KEEPER_CLASS_" nodeIndex="613">设计</strong>、<strong class=" _RIL_KEEPER_CLASS_" nodeIndex="614">极客 </strong>和 <strong class=" _RIL_KEEPER_CLASS_" nodeIndex="615">IT相亲</strong>相关的热门公众号。技术涵盖：Python、Web前端、Java、安卓、iOS、PHP、C/C++、.NET、Linux、数据库、运维、大数据、算法、IT职场等。点击《</span><a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=415754379&idx=1&sn=fabfe6514dc817145df3bac5a8c571b3&scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=415754379&idx=1&sn=fabfe6514dc817145df3bac5a8c571b3&scene=21#wechat_redirect" nodeIndex="616"><span nodeIndex="617">值得关注的技术和设计公众号</span></a><span nodeIndex="618">》，发现精彩！</span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="333"><span nodeIndex="619"><br nodeIndex="620"></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="334"><div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2016-03-09-1219324615/3"/></div></p>
                </div>
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" nodeIndex="335"></div>

                
                                <p id="js_preview_reward_wording" class="tips_global reward_tips _RIL_KEEPER_CLASS_" nodeIndex="337"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="338">
                        <a class="reward_access" id="js_preview_reward_link" href=""><span class="icon-reward"></span>赞赏</a>

                    </p>
                <p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="340">长按二维码向我转账</p><p id="js_preview_reward_ios_wording" class="reward_tips _RIL_KEEPER_CLASS_" nodeIndex="341"></p><p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="342">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p><div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2016-03-09-1219324615/4"/></div>
                            </div>
                        
                        


                    </div>