---
layout: post
title: 轻松理解 Kerbreos 的认证过程
categories:
- Pocket
tags:
---
原文地址：http://mp.weixin.qq.com/s/D0HVdAB2XgYcCg0vdx65UA

收藏时间：2018-03-25 14:10:28

<div  >
            
                        <div id="img-content" nodeIndex="5">
                
                
                <p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="10">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">xazlsec</span>
                            </p><p class="profile_meta _RIL_KEEPER_CLASS_" nodeIndex="11">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">信安之路是一个学习分享信息安全技术的平台，在这里你可以学习别人的技术和心得，你也可以分享自己的学习成果和心得体会，这是一个有温度的平台，需要你我他的共同参与，一起发扬广大，成为安全圈的一方净土，目前也是 90sec 安全论坛的战略合作伙伴。</span>
                            </p>
                
                
                
                
                                                
                                                                
                
                <div class="rich_media_content " id="js_content" nodeIndex="12">
                    

                    

                    
                    
                    <blockquote cid="n0" mdtype="blockquote" nodeIndex="13"><p cid="n2" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="14"><span class="md-line md-end-block md-focus" cid="n3" mdtype="line" nodeIndex="223"><span md-inline="plain" class="md-expand" nodeIndex="224">本文作者：wulantian</span></span></p><p cid="n4" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="15"><span class="md-line md-end-block" cid="n5" mdtype="line" nodeIndex="225"><span md-inline="plain" nodeIndex="226">博文地址：</span><span md-inline="url" spellcheck="false" nodeIndex="227">http://blog.csdn.net/wulantian/article/details/42418231</span></span></p></blockquote><p cid="n6" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="16"><span class="md-line md-end-block" cid="n7" mdtype="line" nodeIndex="228"><span md-inline="plain" nodeIndex="229">前几天在给人解释 Windows 是如何通过 Kerberos 进行 Authentication 的时候，讲了半天也别把那位老兄讲明白，还差点把自己给绕进去。</span></span></p><p cid="n8" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="17"><span class="md-line md-end-block" cid="n9" mdtype="line" nodeIndex="230"><span md-inline="plain" nodeIndex="231">后来想想原因有以下两点：</span></span></p><p cid="n10" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="18"><span class="md-line md-end-block" cid="n11" mdtype="line" nodeIndex="232"><span md-inline="plain" nodeIndex="233">对于一个没有完全不了解 Kerberos 的人来说，Kerberos 的整个 Authentication 过程确实不好理解 —— 一会儿以这个 Key 进行加密、一会儿又要以另一个 Key 进行加密，确实很容易把人给弄晕；</span></span></p><p cid="n12" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="19"><span class="md-line md-end-block" cid="n13" mdtype="line" nodeIndex="234"><span md-inline="plain" nodeIndex="235">另一方面是我讲解方式有问题，一开始就从 Kerberos 的 3 个 Sub-protocol 全面讲述整个 Authentication 过程，对于一个完全不了解 Kerberos 的人来说要求也忒高了点。</span></span></p><p cid="n14" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="20"><span class="md-line md-end-block" cid="n15" mdtype="line" nodeIndex="236"><span md-inline="plain" nodeIndex="237">为此，我花了一些时间写了这篇文章，尽量以由浅入深、层层深入的方式讲述我所理解的基于 Kerberos 的 Windows Network Authentication，希望这篇文章能帮助那些对 Kerberos 不明就里的人带来一丝帮助。对于一些不对的地方，欢迎大家批评指正。</span></span></p><h3 cid="n16" mdtype="heading" class="md-end-block md-heading" nodeIndex="21"><span md-inline="plain" nodeIndex="238">一、 基本原理</span></h3><p cid="n17" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="22"><span class="md-line md-end-block" cid="n18" mdtype="line" nodeIndex="239"><span md-inline="plain" nodeIndex="240">Authentication 解决的是“如何证明某个人确确实实就是他或她所声称的那个人”的问题。</span></span></p><p cid="n19" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="23"><span class="md-line md-end-block" cid="n20" mdtype="line" nodeIndex="241"><span md-inline="plain" nodeIndex="242">对于如何进行 Authentication，我们采用这样的方法：如果一个秘密（secret）仅仅存在于 A 和 B，那么有个人对 B 声称自己就是 A，B 通过让 A 提供这个秘密来证明这个人就是他或她所声称的 A。这个过程实际上涉及到 3 个重要的关于 Authentication 的方面：</span></span></p><p cid="n21" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="24"><span class="md-line md-end-block" cid="n22" mdtype="line" nodeIndex="243"><span md-inline="plain" nodeIndex="244">1、Secret 如何表示。</span></span></p><p cid="n23" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="25"><span class="md-line md-end-block" cid="n24" mdtype="line" nodeIndex="245"><span md-inline="plain" nodeIndex="246">2、A 如何向 B 提供 Secret。</span></span></p><p cid="n25" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="26"><span class="md-line md-end-block" cid="n26" mdtype="line" nodeIndex="247"><span md-inline="plain" nodeIndex="248">3、B 如何识别 Secret。</span></span></p><p cid="n27" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="27"><span class="md-line md-end-block" cid="n28" mdtype="line" nodeIndex="249"><span md-inline="plain" nodeIndex="250">基于这 3 个方面，我们把 Kerberos Authentication 进行最大限度的简化：</span></span></p><p cid="n29" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="28"><span class="md-line md-end-block" cid="n30" mdtype="line" nodeIndex="251"><span md-inline="plain" nodeIndex="252">整个过程涉及到 Client 和 Server，他们之间的这个 Secret 我们用一个 Key（ </span><span md-inline="code" spellcheck="false" nodeIndex="253"><code nodeIndex="254">KServer-Client</code></span><span md-inline="plain" nodeIndex="255"> ）来表示。</span></span></p><p cid="n31" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="29"><span class="md-line md-end-block" cid="n32" mdtype="line" nodeIndex="256"><span md-inline="plain" nodeIndex="257">Client 为了让 Server 对自己进行有效的认证，向对方提供如下两组信息：</span></span></p><p cid="n33" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="30"><span class="md-line md-end-block" cid="n34" mdtype="line" nodeIndex="258"><span md-inline="plain" nodeIndex="259">1、代表 Client 自身 Identity 的信息，为了简便，它以明文的形式传递。</span></span></p><p cid="n35" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="31"><span class="md-line md-end-block" cid="n36" mdtype="line" nodeIndex="260"><span md-inline="plain" nodeIndex="261">2、将 Client 的 Identity 使用 </span><span md-inline="code" spellcheck="false" nodeIndex="262"><code nodeIndex="263">KServer-Client</code></span><span md-inline="plain" nodeIndex="264"> 作为 Public Key、并采用对称加密算法进行加密。</span></span></p><p cid="n37" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="32"><span class="md-line md-end-block" cid="n38" mdtype="line" nodeIndex="265"><span md-inline="plain" nodeIndex="266">由于 </span><span md-inline="code" spellcheck="false" nodeIndex="267"><code nodeIndex="268">KServer-Client</code></span><span md-inline="plain" nodeIndex="269"> 仅仅被 Client 和 Server 知晓，所以被 Client 使用 </span><span md-inline="code" spellcheck="false" nodeIndex="270"><code nodeIndex="271">KServer-Client</code></span><span md-inline="plain" nodeIndex="272"> 加密过的 Client Identity 只能被 Client 和 Server 解密。</span></span></p><p cid="n39" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="33"><span class="md-line md-end-block" cid="n40" mdtype="line" nodeIndex="273"><span md-inline="plain" nodeIndex="274">同理，Server 接收到 Client 传送的这两组信息，先通过 </span><span md-inline="code" spellcheck="false" nodeIndex="275"><code nodeIndex="276">KServer-Client</code></span><span md-inline="plain" nodeIndex="277"> 对后者进行解密，随后将机密的数据同前者进行比较，如果完全一样，则可以证明 Client 能够提供正确的 </span><span md-inline="code" spellcheck="false" nodeIndex="278"><code nodeIndex="279">KServer-Client</code></span><span md-inline="plain" nodeIndex="280">，而这个世界上，仅仅只有真正的 Client 和自己知道 </span><span md-inline="code" spellcheck="false" nodeIndex="281"><code nodeIndex="282">KServer-Client</code></span><span md-inline="plain" nodeIndex="283">，所以可以确定对方就是他所声称的那个人。</span></span><span class="md-line md-end-block" cid="n40" mdtype="line" nodeIndex="284"><span md-inline="plain" nodeIndex="285"></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="34"><div id="RIL_IMG_1" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/1"/></div></p><p cid="n41" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="35"><span class="md-line md-end-block" cid="n43" mdtype="line" nodeIndex="286"><span md-inline="plain" nodeIndex="287">Kerberos 大体上就是按照这样的一个原理来进行 Authentication 的。</span></span></p><p cid="n44" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="36"><span class="md-line md-end-block" cid="n45" mdtype="line" nodeIndex="288"><span md-inline="plain" nodeIndex="289">但是 Kerberos 远比这个复杂，我将在后续的章节中不断地扩充这个过程，了解 Kerberos 真实的认证过程。</span></span></p><p cid="n46" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="37"><span class="md-line md-end-block" cid="n47" mdtype="line" nodeIndex="290"><span md-inline="plain" nodeIndex="291">为了使读者更加容易理解后续的部分，在这里我们先给出两个重要的概念：</span></span></p><p cid="n48" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="38"><span class="md-line md-end-block" cid="n49" mdtype="line" nodeIndex="292"><span md-inline="strong" class="" nodeIndex="293"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="294">Long-term Key/Master Key:</strong></span></span></p><p cid="n50" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="39"><span class="md-line md-end-block" cid="n51" mdtype="line" nodeIndex="201"><span md-inline="plain" nodeIndex="295">在 Security 的领域中，有的 Key 可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key、以及由此派生的 Key 被称为 </span><span md-inline="code" spellcheck="false" nodeIndex="296"><code nodeIndex="297">Long-term Key</code></span><span md-inline="plain" nodeIndex="298">。</span></span></p><p cid="n52" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="40"><span class="md-line md-end-block" cid="n53" mdtype="line" nodeIndex="299"><span md-inline="plain" nodeIndex="300">对于 </span><span md-inline="code" spellcheck="false" nodeIndex="301"><code nodeIndex="302">Long-term Key</code></span><span md-inline="plain" nodeIndex="303"> 的使用有这样的原则：被 </span><span md-inline="code" spellcheck="false" nodeIndex="304"><code nodeIndex="305">Long-term Key</code></span><span md-inline="plain" nodeIndex="306"> 加密的数据不应该在网络上传输。</span></span></p><p cid="n54" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="41"><span class="md-line md-end-block" cid="n55" mdtype="line" nodeIndex="202"><span md-inline="plain" nodeIndex="307">原因很简单，一旦这些被 </span><span md-inline="code" spellcheck="false" nodeIndex="308"><code nodeIndex="309">Long-term Key</code></span><span md-inline="plain" nodeIndex="310"> 加密的数据包被恶意的网络监听者截获，在原则上，只要有充足的时间，他是可以通过计算来暴力猜解出 </span><span md-inline="code" spellcheck="false" nodeIndex="311"><code nodeIndex="312">Long-term Key</code></span><span md-inline="plain" nodeIndex="313"> 的——任何加密算法都不可能做到绝对安全。</span></span></p><p cid="n56" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="42"><span class="md-line md-end-block" cid="n57" mdtype="line" nodeIndex="203"><span md-inline="plain" nodeIndex="314">在一般情况下，对于一个 Account 来说，密码往往仅仅限于该 Account 的所有者知晓，甚至对于任何 Domain 的 Administrator，密码仍然应该是保密的。但是密码却又是证明身份的凭据，所以必须通过基于你密码的派生的信息来证明用户的真实身份，在这种情况下，一般将你的密码进行 Hash 运算得到一个 </span><span md-inline="code" spellcheck="false" nodeIndex="315"><code nodeIndex="316">Hash code</code></span><span md-inline="plain" nodeIndex="317">, 我们一般管这样的 </span><span md-inline="code" spellcheck="false" nodeIndex="318"><code nodeIndex="319">Hash Code</code></span><span md-inline="plain" nodeIndex="320"> 叫做 </span><span md-inline="code" spellcheck="false" nodeIndex="321"><code nodeIndex="322">Master Key</code></span><span md-inline="plain" nodeIndex="323">。</span></span></p><p cid="n58" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="43"><span class="md-line md-end-block" cid="n59" mdtype="line" nodeIndex="324"><span md-inline="plain" nodeIndex="325">由于 </span><span md-inline="code" spellcheck="false" nodeIndex="326"><code nodeIndex="327">Hash Algorithm</code></span><span md-inline="plain" nodeIndex="328"> 是不可逆的，同时保证密码和 </span><span md-inline="code" spellcheck="false" nodeIndex="329"><code nodeIndex="330">Master Key</code></span><span md-inline="plain" nodeIndex="331"> 是一一对应的，这样既保证了你密码的保密性，又同时保证你的 </span><span md-inline="code" spellcheck="false" nodeIndex="332"><code nodeIndex="333">Master Key</code></span><span md-inline="plain" nodeIndex="334"> 和密码本身在证明你身份的时候具有相同的效力。</span></span></p><p cid="n60" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="44"><span class="md-line md-end-block" cid="n61" mdtype="line" nodeIndex="335"><span md-inline="strong" class="" nodeIndex="336"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="337">Short-term Key/Session Key:</strong></span></span></p><p cid="n62" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="45"><span class="md-line md-end-block" cid="n63" mdtype="line" nodeIndex="204"><span md-inline="plain" nodeIndex="338">由于被 </span><span md-inline="code" spellcheck="false" nodeIndex="339"><code nodeIndex="340">Long-term Key</code></span><span md-inline="plain" nodeIndex="341"> 加密的数据包不能用于网络传送，所以我们使用另一种 </span><span md-inline="code" spellcheck="false" nodeIndex="342"><code nodeIndex="343">Short-term Key</code></span><span md-inline="plain" nodeIndex="344"> 来加密需要进行网络传输的数据。由于这种 Key 只在一段时间内有效，即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 早就已经过期了。</span></span></p><h3 cid="n64" mdtype="heading" class="md-end-block md-heading" nodeIndex="46"><span md-inline="plain" nodeIndex="345">二、引入 Key Distribution: KServer-Client 从何而来</span></h3><p cid="n65" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="47"><span class="md-line md-end-block" cid="n66" mdtype="line" nodeIndex="346"><span md-inline="strong" class="" nodeIndex="347"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="348">上面我们讨论了 Kerberos Authentication 的基本原理：</strong></span></span></p><p cid="n67" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="48"><span class="md-line md-end-block" cid="n68" mdtype="line" nodeIndex="205"><span md-inline="plain" nodeIndex="349">通过让被认证的一方提供一个仅限于他和认证方知晓的 Key 来鉴定对方的真实身份。而被这个 Key 加密的数据包需要在 Client 和 Server 之间传送，所以这个 Key 不能是一个 </span><span md-inline="code" spellcheck="false" nodeIndex="350"><code nodeIndex="351">Long-term Key</code></span><span md-inline="plain" nodeIndex="352">，而只可能是 </span><span md-inline="code" spellcheck="false" nodeIndex="353"><code nodeIndex="354">Short-term Key</code></span><span md-inline="plain" nodeIndex="355">，这个可以仅仅在 Client 和 Server 的一个 Session 中有效，所以我们称这个 Key 为 Client 和 Server 之间的 Session Key（ </span><span md-inline="code" spellcheck="false" nodeIndex="356"><code nodeIndex="357">SServer-Client</code></span><span md-inline="plain" nodeIndex="358">）。</span></span></p><p cid="n69" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="49"><span class="md-line md-end-block" cid="n70" mdtype="line" nodeIndex="359"><span md-inline="strong" class="" nodeIndex="360"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="361"><span md-inline="plain" nodeIndex="362">现在我们来讨论 Client 和 Server 如何得到这个 </span><span md-inline="code" spellcheck="false" nodeIndex="363"><code nodeIndex="364">SServer-Client</code></span><span md-inline="plain" nodeIndex="365">：</span></strong></span></span></p><p cid="n71" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="50"><span class="md-line md-end-block" cid="n72" mdtype="line" nodeIndex="366"><span md-inline="plain" nodeIndex="367">在这里我们要引入一个重要的角色： </span><span md-inline="code" spellcheck="false" nodeIndex="368"><code nodeIndex="369">Kerberos Distribution Center-KDC</code></span><span md-inline="plain" nodeIndex="370">。</span></span></p><p cid="n73" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="51"><span class="md-line md-end-block" cid="n74" mdtype="line" nodeIndex="206"><span md-inline="plain" nodeIndex="371">KDC 在整个 Kerberos Authentication 中作为 Client 和 Server 共同信任的第三方起着重要的作用，而 Kerberos 的认证过程就是通过这 3 方协作完成。顺便说一下，Kerberos 起源于希腊神话，是一支守护着冥界长着3个头颅的神犬，在 keberos Authentication 中，Kerberos 的 3 个头颅代表中认证过程中涉及的 3 方：</span><span md-inline="code" spellcheck="false" nodeIndex="372"><code nodeIndex="373">Client</code></span><span md-inline="plain" nodeIndex="374">、 </span><span md-inline="code" spellcheck="false" nodeIndex="375"><code nodeIndex="376">Server</code></span><span md-inline="plain" nodeIndex="377"> 和 </span><span md-inline="code" spellcheck="false" nodeIndex="378"><code nodeIndex="379">KDC</code></span><span md-inline="plain" nodeIndex="380">。</span></span></p><p cid="n75" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="52"><span class="md-line md-end-block" cid="n76" mdtype="line" nodeIndex="381"><span md-inline="plain" nodeIndex="382">对于一个 Windows Domain 来说，</span><span md-inline="code" spellcheck="false" nodeIndex="383"><code nodeIndex="384">Domain Controller</code></span><span md-inline="plain" nodeIndex="385"> 扮演着 KDC 的角色。KDC 维护着一个存储着该 Domain 中所有帐户的 </span><span md-inline="code" spellcheck="false" nodeIndex="386"><code nodeIndex="387">Account Database</code></span><span md-inline="plain" nodeIndex="388">（一般地，这个 Account Database 由 </span><span md-inline="code" spellcheck="false" nodeIndex="389"><code nodeIndex="390">AD</code></span><span md-inline="plain" nodeIndex="391"> 来维护），也就是说，他知道属于每个 Account 的名称和派生于该 Account Password 的 </span><span md-inline="code" spellcheck="false" nodeIndex="392"><code nodeIndex="393">Master Key</code></span><span md-inline="plain" nodeIndex="394">。而用于 Client 和 Server 相互认证的 </span><span md-inline="code" spellcheck="false" nodeIndex="395"><code nodeIndex="396">SServer-Client</code></span><span md-inline="plain" nodeIndex="397"> 就是由 KDC 分发。</span></span></p><p cid="n77" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="53"><span class="md-line md-end-block" cid="n78" mdtype="line" nodeIndex="398"><span md-inline="strong" class="" nodeIndex="399"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="400"><span md-inline="plain" nodeIndex="401">下面我们来看看 KDC 分发 </span><span md-inline="code" spellcheck="false" nodeIndex="402"><code nodeIndex="403">SServer-Client</code></span><span md-inline="plain" nodeIndex="404"> 的过程：</span></strong></span></span><span class="md-line md-end-block" cid="n78" mdtype="line" nodeIndex="405"><span md-inline="strong" class="" nodeIndex="406"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="407"><span md-inline="plain" nodeIndex="408"></span></strong></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="54"><div id="RIL_IMG_2" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/2"/></div></p><p cid="n81" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="55"><span class="md-line md-end-block" cid="n82" mdtype="line" nodeIndex="409"><span md-inline="plain" nodeIndex="410">通过上图我们可以看到 KDC 分发 </span><span md-inline="code" spellcheck="false" nodeIndex="411"><code nodeIndex="412">SServer-Client</code></span><span md-inline="plain" nodeIndex="413"> 的简单的过程：</span></span></p><p cid="n83" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="56"><span class="md-line md-end-block" cid="n84" mdtype="line" nodeIndex="207"><span md-inline="plain" nodeIndex="414">首先 Client 向 KDC 发送一个对 </span><span md-inline="code" spellcheck="false" nodeIndex="415"><code nodeIndex="416">SServer-Client</code></span><span md-inline="plain" nodeIndex="417"> 的申请。这个申请的内容可以简单概括为 </span><span md-inline="em" class="" nodeIndex="418"><em nodeIndex="419">“我是某个 Client，我需要一个 Session Key 用于访问某个 Server”</em></span><span md-inline="plain" nodeIndex="420">。KDC 在接收到这个请求的时候，生成一个 Session Key，为了保证这个 Session Key 仅仅限于发送请求的 Client 和他希望访问的 Server 知晓，KDC 会为这个 Session Key 生成两个 Copy，分别被 Client 和 Server 使用。然后从 Account database 中提取 Client 和 Server 的 Master Key 分别对这两个 Copy 进行对称加密。对于后者，和 Session Key 一起被加密的还包含关于 Client 的一些信息。</span></span></p><p cid="n85" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="57"><span class="md-line md-end-block" cid="n86" mdtype="line" nodeIndex="421"><span md-inline="plain" nodeIndex="422">KDC 现在有了两个分别被 Client 和 Server 的 Master Key 加密过的 Session Key，这两个 Session Key 如何分别被 Client 和 Server 获得呢？也许你 马上会说，KDC 直接将这两个加密过的包发送给 Client 和 Server 不就可以了吗，但是如果这样做，对于 Server 来说会出现下面两个问题：</span></span></p><p cid="n87" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="58"><span class="md-line md-end-block" cid="n88" mdtype="line" nodeIndex="423"><span md-inline="plain" nodeIndex="424">1、由于一个 Server 会面对若干不同的 Client, 而每个 Client 都具有一个不同的 Session Key。那么 Server 就会为所有的 Client 维护这样一个 Session Key 的列表，这样做对于 Server 来说是比较麻烦而低效的。</span></span></p><p cid="n89" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="59"><span class="md-line md-end-block" cid="n90" mdtype="line" nodeIndex="425"><span md-inline="plain" nodeIndex="426">2、由于网络传输的不确定性，可能出现这样一种情况：Client 很快获得 Session Key，并将这个 Session Key 作为 Credential 随同访问请求发送到 Server，但是用于 Server 的 Session Key 的确还没有收到，并且很有可能承载这个 Session Key 的永远也到不了 Server 端，Client 将永远得不到认证。</span></span></p><p cid="n91" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="60"><span class="md-line md-end-block" cid="n92" mdtype="line" nodeIndex="427"><span md-inline="plain" nodeIndex="428">为了解决这个问题，Kerberos 的做法很简单，将这两个被加密的 Copy 一并发送给 Client，属于 Server 的那份由 Client 发送给 Server。</span></span></p><p cid="n93" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="61"><span class="md-line md-end-block" cid="n94" mdtype="line" nodeIndex="429"><span md-inline="plain" nodeIndex="430">可能有人会问，KDC 并没有真正去认证，这个发送请求的 Client 是否真的就是那个他所声称的那个人，就把 Session Key 发送给他，会不会有什么问题？</span></span></p><p cid="n95" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="62"><span class="md-line md-end-block" cid="n96" mdtype="line" nodeIndex="431"><span md-inline="plain" nodeIndex="432">如果另一个人（比如 Client B）声称自己是 Client A，他同样会得到 Client A 和 Server 的 Session Key，这会不会有什么问题？</span></span></p><p cid="n97" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="63"><span class="md-line md-end-block" cid="n98" mdtype="line" nodeIndex="433"><span md-inline="plain" nodeIndex="434">实际上不存在问题，因为 Client B 声称自己是 Client A，KDC 就会使用 Client A 的 Password 派生的 Master Key 对 Session Key 进行加密，所以真正知道 Client A 的 Password 的一方才会通过解密获得 Session Key。 </span></span></p><h3 cid="n99" mdtype="heading" class="md-end-block md-heading" nodeIndex="64"><span md-inline="plain" nodeIndex="435">三、引入 Authenticator - 为有效的证明自己提供证据</span></h3><p cid="n100" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="65"><span class="md-line md-end-block" cid="n101" mdtype="line" nodeIndex="436"><span md-inline="strong" class="" nodeIndex="437"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="438">通过上面的过程，Client 实际上获得了两组信息：</strong></span></span></p><p cid="n102" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="66"><span class="md-line md-end-block" cid="n103" mdtype="line" nodeIndex="439"><span md-inline="plain" nodeIndex="440">一个通过自己 </span><span md-inline="code" spellcheck="false" nodeIndex="441"><code nodeIndex="442">Master Key</code></span><span md-inline="plain" nodeIndex="443"> 加密的 </span><span md-inline="code" spellcheck="false" nodeIndex="444"><code nodeIndex="445">Session Key</code></span><span md-inline="plain" nodeIndex="446">，另一个被 Server 的 </span><span md-inline="code" spellcheck="false" nodeIndex="447"><code nodeIndex="448">Master Key</code></span><span md-inline="plain" nodeIndex="449"> 加密的数据包，包含 </span><span md-inline="code" spellcheck="false" nodeIndex="450"><code nodeIndex="451">Session Key</code></span><span md-inline="plain" nodeIndex="452"> 和关于自己的一些确认信息。</span></span></p><p cid="n104" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="67"><span class="md-line md-end-block" cid="n105" mdtype="line" nodeIndex="208"><span md-inline="plain" nodeIndex="453">通过第一节，我们说只要通过一个双方知晓的 Key 就可以对对方进行有效的认证，但是在一个网络的环境中，这种简单的做法是具有安全漏洞，为此，Client 需要提供更多的证明信息，我们把这种证明信息称为 </span><span md-inline="code" spellcheck="false" nodeIndex="454"><code nodeIndex="455">Authenticator</code></span><span md-inline="plain" nodeIndex="456">，在 Kerberos 的 </span><span md-inline="code" spellcheck="false" nodeIndex="457"><code nodeIndex="458">Authenticator</code></span><span md-inline="plain" nodeIndex="459"> 实际上就是关于 Client 的一些信息和当前时间的一个 </span><span md-inline="code" spellcheck="false" nodeIndex="460"><code nodeIndex="461">Timestamp</code></span><span md-inline="plain" nodeIndex="462">（关于这个安全漏洞和 </span><span md-inline="code" spellcheck="false" nodeIndex="463"><code nodeIndex="464">Timestamp</code></span><span md-inline="plain" nodeIndex="465"> 的作用，我将在后面解释）。</span></span></p><p cid="n106" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="68"><span class="md-line md-end-block" cid="n107" mdtype="line" nodeIndex="466"><span md-inline="strong" class="" nodeIndex="467"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="468">在这个基础上，我们再来看看 Server 如何对 Client 进行认证：</strong></span></span></p><p cid="n108" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="69"><span class="md-line md-end-block" cid="n109" mdtype="line" nodeIndex="469"><span md-inline="plain" nodeIndex="470">Client 通过自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="471"><code nodeIndex="472">Master Key</code></span><span md-inline="plain" nodeIndex="473"> 对 KDC 加密的 Session Key 进行解密从而获得 </span><span md-inline="code" spellcheck="false" nodeIndex="474"><code nodeIndex="475">Session Key</code></span><span md-inline="plain" nodeIndex="476">，随后创建</span><span md-inline="code" spellcheck="false" nodeIndex="477"><code nodeIndex="478">Authenticator（Client Info + Timestamp）</code></span><span md-inline="plain" nodeIndex="479"> 并用 </span><span md-inline="code" spellcheck="false" nodeIndex="480"><code nodeIndex="481">Session Key</code></span><span md-inline="plain" nodeIndex="482"> 对其加密。最后连同从 KDC 获得的、被 Server 的 </span><span md-inline="code" spellcheck="false" nodeIndex="483"><code nodeIndex="484">Master Key</code></span><span md-inline="plain" nodeIndex="485"> 加密过的数据包（</span><span md-inline="code" spellcheck="false" nodeIndex="486"><code nodeIndex="487">Client Info + Session Key</code></span><span md-inline="plain" nodeIndex="488">）一并发送到 Server 端。我们把通过 Server 的 </span><span md-inline="code" spellcheck="false" nodeIndex="489"><code nodeIndex="490">Master Key</code></span><span md-inline="plain" nodeIndex="491"> 加密过的数据包称为 </span><span md-inline="code" spellcheck="false" nodeIndex="492"><code nodeIndex="493">Session Ticket</code></span><span md-inline="plain" nodeIndex="494">。</span></span></p><p cid="n110" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="70"><span class="md-line md-end-block" cid="n111" mdtype="line" nodeIndex="495"><span md-inline="plain" nodeIndex="496">当 Server 接收到这两组数据后，先使用他自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="497"><code nodeIndex="498">Master Key</code></span><span md-inline="plain" nodeIndex="499"> 对 </span><span md-inline="code" spellcheck="false" nodeIndex="500"><code nodeIndex="501">Session Ticket</code></span><span md-inline="plain" nodeIndex="502"> 进行解密，从而获得 </span><span md-inline="code" spellcheck="false" nodeIndex="503"><code nodeIndex="504">Session Key</code></span><span md-inline="plain" nodeIndex="505">。随后使用该 </span><span md-inline="code" spellcheck="false" nodeIndex="506"><code nodeIndex="507">Session Key</code></span><span md-inline="plain" nodeIndex="508"> 解密 </span><span md-inline="code" spellcheck="false" nodeIndex="509"><code nodeIndex="510">Authenticator</code></span><span md-inline="plain" nodeIndex="511">，通过比较 </span><span md-inline="code" spellcheck="false" nodeIndex="512"><code nodeIndex="513">Authenticator</code></span><span md-inline="plain" nodeIndex="514"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="515"><code nodeIndex="516">Client Info</code></span><span md-inline="plain" nodeIndex="517"> 和 </span><span md-inline="code" spellcheck="false" nodeIndex="518"><code nodeIndex="519">Session Ticket</code></span><span md-inline="plain" nodeIndex="520"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="521"><code nodeIndex="522">Client Info</code></span><span md-inline="plain" nodeIndex="523"> 从而实现对 Client 的认证。</span></span><span class="md-line md-end-block" cid="n111" mdtype="line" nodeIndex="524"><div id="RIL_IMG_3" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/3"/></div></span></p><p cid="n114" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="71"><span class="md-line md-end-block" cid="n115" mdtype="line" nodeIndex="525"><span md-inline="strong" class="" nodeIndex="526"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="527">为什么要使用 Timestamp？</strong></span></span></p><p cid="n116" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="72"><span class="md-line md-end-block" cid="n117" mdtype="line" nodeIndex="528"><span md-inline="plain" nodeIndex="529">到这里，很多人可能认为这样的认证过程天衣无缝：只有当 Client 提供正确的 Session Key 方能得到 Server 的认证。但是在现实环境中，这存在很大的安全漏洞。</span></span></p><p cid="n118" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="73"><span class="md-line md-end-block" cid="n119" mdtype="line" nodeIndex="209"><span md-inline="plain" nodeIndex="530">我们试想这样的现象：Client 向 Server 发送的数据包被某个恶意网络监听者截获，该监听者随后将数据包作为自己的 Credential 冒充该 Client 对 Server 进行访问，在这种情况下，依然可以很顺利地获得 Server 的成功认证。为了解决这个问题，Client 在 </span><span md-inline="code" spellcheck="false" nodeIndex="531"><code nodeIndex="532">Authenticator</code></span><span md-inline="plain" nodeIndex="533"> 中会加入一个当前时间的 </span><span md-inline="code" spellcheck="false" nodeIndex="534"><code nodeIndex="535">Timestamp</code></span><span md-inline="plain" nodeIndex="536">。</span></span></p><p cid="n120" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="74"><span class="md-line md-end-block" cid="n121" mdtype="line" nodeIndex="210"><span md-inline="plain" nodeIndex="537">在 Server 对 </span><span md-inline="code" spellcheck="false" nodeIndex="538"><code nodeIndex="539">Authenticator</code></span><span md-inline="plain" nodeIndex="540"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="541"><code nodeIndex="542">Client Info</code></span><span md-inline="plain" nodeIndex="543"> 和 </span><span md-inline="code" spellcheck="false" nodeIndex="544"><code nodeIndex="545">Session Ticket</code></span><span md-inline="plain" nodeIndex="546"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="547"><code nodeIndex="548">Client Info</code></span><span md-inline="plain" nodeIndex="549"> 进行比较之前，会先提取 </span><span md-inline="code" spellcheck="false" nodeIndex="550"><code nodeIndex="551">Authenticator</code></span><span md-inline="plain" nodeIndex="552"> 中的 </span><span md-inline="code" spellcheck="false" nodeIndex="553"><code nodeIndex="554">Timestamp</code></span><span md-inline="plain" nodeIndex="555">，并同</span><span md-inline="em" class="" nodeIndex="556"><em nodeIndex="557">当前的时间</em></span><span md-inline="plain" nodeIndex="558">进行比较，如果他们之间的偏差超出一个</span><span md-inline="em" class="" nodeIndex="559"><em nodeIndex="560">可以接受的时间范围（一般是 5mins）</em></span><span md-inline="plain" nodeIndex="561">，Server 会直接拒绝该 Client 的请求。在这里需要知道的是，Server 维护着一个列表，这个列表记录着在这个可接受的时间范围内所有进行认证的 Client 和认证的时间。</span></span></p><p cid="n122" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="75"><span class="md-line md-end-block" cid="n123" mdtype="line" nodeIndex="562"><span md-inline="strong" class="" nodeIndex="563"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="564">Time Synchronization 的重要性</strong></span></span></p><p cid="n124" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="76"><span class="md-line md-end-block" cid="n125" mdtype="line" nodeIndex="211"><span md-inline="plain" nodeIndex="565">上述基于 </span><span md-inline="code" spellcheck="false" nodeIndex="566"><code nodeIndex="567">Timestamp</code></span><span md-inline="plain" nodeIndex="568"> 的认证机制只有在 Client 和 Server 端的时间保持同步的情况才有意义。所以保持 Time Synchronization 在整个认证过程中显得尤为重要。在一个 Domain 中，一般通过访问同一个 </span><span md-inline="code" spellcheck="false" nodeIndex="569"><code nodeIndex="570">Time Service</code></span><span md-inline="plain" nodeIndex="571"> 获得当前时间的方式来实现时间的同步。</span></span></p><p cid="n126" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="77"><span class="md-line md-end-block" cid="n127" mdtype="line" nodeIndex="572"><span md-inline="strong" class="" nodeIndex="573"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="574">双向认证（Mutual Authentication）</strong></span></span></p><p cid="n128" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="78"><span class="md-line md-end-block" cid="n129" mdtype="line" nodeIndex="575"><span md-inline="plain" nodeIndex="576">Kerberos 一个重要的优势在于它能够提供双向认证：</span></span></p><p cid="n130" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="79"><span class="md-line md-end-block" cid="n131" mdtype="line" nodeIndex="577"><span md-inline="plain" nodeIndex="578">不但 Server 可以对 Client 进行认证，Client 也能对 Server 进行认证。</span></span></p><p cid="n132" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="80"><span class="md-line md-end-block" cid="n133" mdtype="line" nodeIndex="212"><span md-inline="plain" nodeIndex="579">具体过程是这样的，如果 Client 需要对他访问的 Server 进行认证，会在它向 Server 发送的 Credential 中设置一个是否需要认证的 Flag。Server 在对 Client 认证成功之后，会把 Authenticator 中的 Timestamp 提取出来，通过 Session Key 进行加密，当 Client 接收到并使用 Session Key 进行解密之后，如果确认 </span><span md-inline="code" spellcheck="false" nodeIndex="580"><code nodeIndex="581">Timestamp</code></span><span md-inline="plain" nodeIndex="582"> 和原来的完全一致，那么他可以认定 Server 正是他试图访问的 Server。</span></span></p><p cid="n134" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="81"><span class="md-line md-end-block" cid="n135" mdtype="line" nodeIndex="583"><span md-inline="em" class="" nodeIndex="584"><em nodeIndex="585">那么为什么 Server 不直接把通过 Session Key 进行加密的 Authenticator 原样发送给 Client，而要把 Timestamp 提取出来加密发送给 Client 呢？</em></span></span></p><p cid="n136" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="82"><span class="md-line md-end-block" cid="n137" mdtype="line" nodeIndex="586"><span md-inline="plain" nodeIndex="587">原因在于防止恶意的监听者通过获取的 Client 发送的 Authenticator 冒充 Server 获得 Client 的认证。</span></span></p><h3 cid="n138" mdtype="heading" class="md-end-block md-heading" nodeIndex="83"><span md-inline="plain" nodeIndex="588">四、引入 Ticket Granting  Service</span></h3><p cid="n139" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="84"><span class="md-line md-end-block" cid="n140" mdtype="line" nodeIndex="589"><span md-inline="plain" nodeIndex="590">通过上面的介绍，我们发现 Kerberos 实际上是一个基于 </span><span md-inline="code" spellcheck="false" nodeIndex="591"><code nodeIndex="592">Ticket</code></span><span md-inline="plain" nodeIndex="593"> 的认证方式。</span></span></p><p cid="n141" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="85"><span class="md-line md-end-block" cid="n142" mdtype="line" nodeIndex="594"><span md-inline="plain" nodeIndex="595">Client 想要获取 Server 端的资源，先得通过 Server 的认证；而认证的先决条件是 Client 向 Server 提供从 KDC 获得的一个由 </span><span md-inline="code" spellcheck="false" nodeIndex="596"><code nodeIndex="597">Server</code></span><span md-inline="plain" nodeIndex="598"> 的 </span><span md-inline="code" spellcheck="false" nodeIndex="599"><code nodeIndex="600">Master Key</code></span><span md-inline="plain" nodeIndex="601"> 进行加密的 </span><span md-inline="code" spellcheck="false" nodeIndex="602"><code nodeIndex="603">Session Ticket（Session Key + Client Info）</code></span><span md-inline="plain" nodeIndex="604">。</span></span></p><p cid="n143" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="86"><span class="md-line md-end-block" cid="n144" mdtype="line" nodeIndex="213"><span md-inline="plain" nodeIndex="605">可以这么说，</span><span md-inline="code" spellcheck="false" nodeIndex="606"><code nodeIndex="607">Session Ticket</code></span><span md-inline="plain" nodeIndex="608"> 是 Client 进入 Server 领域的一张门票。而这张门票必须从一个合法的 Ticket 颁发机构获得，这个颁发机构就是 Client 和 Server 双方信任的 KDC， 同时这张 Ticket 具有超强的防伪标识：它是被 Server 的 </span><span md-inline="code" spellcheck="false" nodeIndex="609"><code nodeIndex="610">Master Key</code></span><span md-inline="plain" nodeIndex="611"> 加密的。对 Client 来说， 获得 </span><span md-inline="code" spellcheck="false" nodeIndex="612"><code nodeIndex="613">Session Ticket</code></span><span md-inline="plain" nodeIndex="614"> 是整个认证过程中最为关键的部分。</span></span></p><p cid="n145" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="87"><span class="md-line md-end-block" cid="n146" mdtype="line" nodeIndex="615"><span md-inline="plain" nodeIndex="616">上面我们只是简单地从大体上说明了 KDC 向 Client 分发 Ticket 的过程，而真正在 Kerberos 中的 Ticket Distribution 要复杂一些。</span></span></p><p cid="n147" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="88"><span class="md-line md-end-block" cid="n148" mdtype="line" nodeIndex="214"><span md-inline="plain" nodeIndex="617">为了更好的说明整个 Ticket Distribution 的过程，我在这里做一个类比。现在的股事很火爆，上海基本上是全民炒股，我就举一个认股权证的例子。有的上市公司在股票配股、增发、基金扩募、股份减持等情况会向公众发行</span><span md-inline="em" class="" nodeIndex="618"><em nodeIndex="619">认股权证</em></span><span md-inline="plain" nodeIndex="620">，认股权证的持有人可以凭借这个权证认购一定数量的该公司股票，认股权证是一种具有看涨期权的金融衍生产品。</span></span></p><p cid="n149" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="89"><span class="md-line md-end-block" cid="n150" mdtype="line" nodeIndex="215"><span md-inline="plain" nodeIndex="621">而我们今天所讲的 Client 获得 Ticket 的过程也和通过认股权证购买股票的过程类似。如果我们把 Client 提供给 Server 进行认证的 Ticket 比作股票的话，那么 Client 在从 KDC 那边获得 Ticket 之前，需要先获得这个 Ticket 的认购权证，这个认购权证在 Kerberos 中被称为 </span><span md-inline="code" spellcheck="false" nodeIndex="622"><code nodeIndex="623">TGT：Ticket Granting Ticket</code></span><span md-inline="plain" nodeIndex="624">，TGT 的分发方仍然是 KDC。</span></span></p><p cid="n151" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="90"><span class="md-line md-end-block" cid="n152" mdtype="line" nodeIndex="625"><span md-inline="strong" class="" nodeIndex="626"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="627">我们现在来看看 Client 是如何从 KDC 处获得 TGT 的：</strong></span></span></p><p cid="n153" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="91"><span class="md-line md-end-block" cid="n154" mdtype="line" nodeIndex="628"><span md-inline="plain" nodeIndex="629">首先 Client 向 KDC 发起对 TGT 的申请，申请的内容大致可以这样表示：“</span><span md-inline="em" class="" nodeIndex="630"><em nodeIndex="631">我需要一张 TGT 用以申请获取用以访问所有 Server 的 Ticket</em></span><span md-inline="plain" nodeIndex="632">”。</span></span></p><p cid="n155" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="92"><span class="md-line md-end-block" cid="n156" mdtype="line" nodeIndex="633"><span md-inline="plain" nodeIndex="634">KDC 在收到该申请请求后，生成一个用于该 Client 和 KDC 进行安全通信的 </span><span md-inline="code" spellcheck="false" nodeIndex="635"><code nodeIndex="636">Session Key（SKDC-Client）</code></span><span md-inline="plain" nodeIndex="637">。</span></span></p><p cid="n157" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="93"><span class="md-line md-end-block" cid="n158" mdtype="line" nodeIndex="638"><span md-inline="plain" nodeIndex="639">为了保证该 Session Key 仅供该 Client 和自己使用，KDC 使用 </span><span md-inline="code" spellcheck="false" nodeIndex="640"><code nodeIndex="641">Client</code></span><span md-inline="plain" nodeIndex="642"> 的 </span><span md-inline="code" spellcheck="false" nodeIndex="643"><code nodeIndex="644">Master Key</code></span><span md-inline="plain" nodeIndex="645"> 和自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="646"><code nodeIndex="647">Master Key</code></span><span md-inline="plain" nodeIndex="648"> 对生成的 Session Key 进行加密，从而获得两个加密的 </span><span md-inline="code" spellcheck="false" nodeIndex="649"><code nodeIndex="650">SKDC-Client</code></span><span md-inline="plain" nodeIndex="651"> 的 Copy。对于后者，随 </span><span md-inline="code" spellcheck="false" nodeIndex="652"><code nodeIndex="653">SKDC-Client</code></span><span md-inline="plain" nodeIndex="654"> 一起被加密的还包含以后用于鉴定 Client 身份的关于 Client 的一些信息。</span></span></p><p cid="n159" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="94"><span class="md-line md-end-block" cid="n160" mdtype="line" nodeIndex="655"><span md-inline="plain" nodeIndex="656">最后 KDC 将这两份 Copy 一并发送给 Client。</span></span></p><p cid="n161" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="95"><span class="md-line md-end-block" cid="n162" mdtype="line" nodeIndex="657"><span md-inline="plain" nodeIndex="658">这里有一点需要注意的是：为了免去 KDC 对于基于不同 Client 的 Session Key 进行维护的麻烦，就像 Server 不会保存 </span><span md-inline="code" spellcheck="false" nodeIndex="659"><code nodeIndex="660">Session Key（SServer-Client）</code></span><span md-inline="plain" nodeIndex="661"> 一样，KDC 也不会去保存这个 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="662"><code nodeIndex="663">SKDC-Client</code></span><span md-inline="plain" nodeIndex="664">），而选择完全靠 Client 自己提供的方式。</span></span><span class="md-line md-end-block" cid="n162" mdtype="line" nodeIndex="665"><span md-inline="plain" nodeIndex="666"></span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="96"><div id="RIL_IMG_4" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/4"/></div></p><p cid="n163" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="97"><span class="md-line md-end-block" cid="n165" mdtype="line" nodeIndex="667"><span md-inline="plain" nodeIndex="668">当 Client 收到 KDC 的两个加密数据包之后，先使用自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="669"><code nodeIndex="670">Master Key</code></span><span md-inline="plain" nodeIndex="671"> 对第一个 Copy 进行解密，从而获得 KDC 和 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="672"><code nodeIndex="673">Session Key（SKDC-Client）</code></span><span md-inline="plain" nodeIndex="674">，并把该 Session 和 TGT 进行缓存。</span></span></p><p cid="n166" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="98"><span class="md-line md-end-block" cid="n167" mdtype="line" nodeIndex="216"><span md-inline="plain" nodeIndex="675">有了 Session Key 和 TGT，Client 自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="676"><code nodeIndex="677">Master Key</code></span><span md-inline="plain" nodeIndex="678"> 将不再需要，因为此后 Client 可以使用 </span><span md-inline="code" spellcheck="false" nodeIndex="679"><code nodeIndex="680">SKDC-Client</code></span><span md-inline="plain" nodeIndex="681"> 向 KDC 申请用以访问每个 Server 的 Ticket，相对于 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="682"><code nodeIndex="683">Master Key</code></span><span md-inline="plain" nodeIndex="684"> 即 </span><span md-inline="code" spellcheck="false" nodeIndex="685"><code nodeIndex="686">Long-term Key</code></span><span md-inline="plain" nodeIndex="687">，</span><span md-inline="code" spellcheck="false" nodeIndex="688"><code nodeIndex="689">SKDC-Client</code></span><span md-inline="plain" nodeIndex="690"> 是一个 </span><span md-inline="code" spellcheck="false" nodeIndex="691"><code nodeIndex="692">Short-term Key</code></span><span md-inline="plain" nodeIndex="693">，安全保证得到更好的保障，这也是 Kerberos 多了这一步的关键所在。同时需要注意的是 </span><span md-inline="code" spellcheck="false" nodeIndex="694"><code nodeIndex="695">SKDC-Client</code></span><span md-inline="plain" nodeIndex="696"> 是一个 Session Key，他具有自己的生命周期，同时 TGT 与 Session 相互关联，当 Session Key 过期，TGT 也就宣告失效，此后 Client 不得不重新向 KDC 申请新的 TGT，KDC 将会生成一个不同 Session Key 和与之关联的 TGT。同时，由于 Client Log off 也导致 </span><span md-inline="code" spellcheck="false" nodeIndex="697"><code nodeIndex="698">SKDC-Client</code></span><span md-inline="plain" nodeIndex="699"> 的失效，所以 </span><span md-inline="code" spellcheck="false" nodeIndex="700"><code nodeIndex="701">SKDC-Client</code></span><span md-inline="plain" nodeIndex="702"> 又被称为 </span><span md-inline="code" spellcheck="false" nodeIndex="703"><code nodeIndex="704">Logon Session Key</code></span><span md-inline="plain" nodeIndex="705">。</span></span></p><p cid="n168" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="99"><span class="md-line md-end-block" cid="n169" mdtype="line" nodeIndex="217"><span md-inline="plain" nodeIndex="706">接下来，我们看看 Client 如何使用 TGT 来从 KDC 获得基于某个 Server 的 Ticket。在这里我要强调一下，Ticket 是基于某个具体的 Server 的，而 TGT 则是和具体的 Server 无关的，Client 可以使用一个 TGT 从 KDC 获得基于不同 Server 的 Ticket。我们言归正传，Client 在获得自己和 KDC 的 </span><span md-inline="code" spellcheck="false" nodeIndex="707"><code nodeIndex="708">Session Key（SKDC-Client）</code></span><span md-inline="plain" nodeIndex="709"> 之后，生成自己的 Authenticator 以及所要访问的 Server 名称,并使用 </span><span md-inline="code" spellcheck="false" nodeIndex="710"><code nodeIndex="711">SKDC-Client</code></span><span md-inline="plain" nodeIndex="712"> 进行加密。随后连同 TGT 一并发送给 KDC。KDC 使用自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="713"><code nodeIndex="714">Master Key</code></span><span md-inline="plain" nodeIndex="715"> 对 TGT 进行解密，提取 </span><span md-inline="code" spellcheck="false" nodeIndex="716"><code nodeIndex="717">Client Info</code></span><span md-inline="plain" nodeIndex="718"> 和 </span><span md-inline="code" spellcheck="false" nodeIndex="719"><code nodeIndex="720">Session Key（SKDC-Client）</code></span><span md-inline="plain" nodeIndex="721">，然后使用这个 </span><span md-inline="code" spellcheck="false" nodeIndex="722"><code nodeIndex="723">SKDC-Client</code></span><span md-inline="plain" nodeIndex="724"> 解密 Authenticator 获得 Client Info，对两个 Client Info 进行比较进而验证对方的真实身份。验证成功，生成一份基于 Client 所要访问的 Server 的 Ticket 给 Client，这个过程就是我们第二节中介绍的一样了。 </span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="100"><div id="RIL_IMG_5" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/5"/></div></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="101"><br nodeIndex="725"></p><h3 cid="n172" mdtype="heading" class="md-end-block md-heading" nodeIndex="102"><span md-inline="plain" nodeIndex="726">五、Kerberos 的 3 个 Sub-protocol：整个 Authentication`</span></h3><p cid="n173" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="103"><span class="md-line md-end-block" cid="n174" mdtype="line" nodeIndex="727"><span md-inline="plain" nodeIndex="728">通过以上的介绍，我们基本上了解了 Kerberos authentication 的整个流程：整个流程大体上包含以下 3 个子过程：</span></span></p><p cid="n175" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="104"><span class="md-line md-end-block" cid="n176" mdtype="line" nodeIndex="729"><span md-inline="plain" nodeIndex="730">1、Client 向 KDC 申请 TGT（Ticket Granting Ticket）。</span></span></p><p cid="n177" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="105"><span class="md-line md-end-block" cid="n178" mdtype="line" nodeIndex="731"><span md-inline="plain" nodeIndex="732">2、Client 通过获得 TGT 向 KDC 申请用于访问 Server 的 Ticket。</span></span></p><p cid="n179" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="106"><span class="md-line md-end-block" cid="n180" mdtype="line" nodeIndex="733"><span md-inline="plain" nodeIndex="734">3、Client 最终向为了 Server 对自己的认证向其提交 Ticket。</span></span></p><p cid="n181" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="107"><span class="md-line md-end-block" cid="n182" mdtype="line" nodeIndex="735"><span md-inline="plain" nodeIndex="736">不过上面的介绍离真正的 Kerberos Authentication 还是有一点出入。</span></span></p><p cid="n183" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="108"><span class="md-line md-end-block" cid="n184" mdtype="line" nodeIndex="737"><span md-inline="plain" nodeIndex="738">Kerberos 整个认证过程通过 3 个 sub-protocol 来完成。这 3 个 Sub-Protocol 分别完成上面列出的 3 个子过程。</span></span></p><p cid="n185" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="109"><span class="md-line md-end-block" cid="n186" mdtype="line" nodeIndex="739"><span md-inline="plain" nodeIndex="740">这 3 个 sub-protocol 分别为：</span></span></p><p cid="n187" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="110"><span class="md-line md-end-block" cid="n188" mdtype="line" nodeIndex="741"><span md-inline="plain" nodeIndex="742">1、Authentication Service Exchange</span></span></p><p cid="n189" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="111"><span class="md-line md-end-block" cid="n190" mdtype="line" nodeIndex="743"><span md-inline="plain" nodeIndex="744">2、Ticket Granting Service Exchange</span></span></p><p cid="n191" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="112"><span class="md-line md-end-block" cid="n192" mdtype="line" nodeIndex="745"><span md-inline="plain" nodeIndex="746">3、Client/Server Exchange</span></span></p><p cid="n193" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="113"><span class="md-line md-end-block" cid="n194" mdtype="line" nodeIndex="747"><span md-inline="plain" nodeIndex="748">下图简单展示了完成这个 3 个 Sub-protocol 所进行 Message Exchange。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="114"><div id="RIL_IMG_6" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/6"/></div></p><p cid="n197" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="115"><span class="md-line md-end-block" cid="n198" mdtype="line" nodeIndex="749"><span md-inline="strong" class="" nodeIndex="750"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="751">1． Authentication Service Exchange</strong></span></span></p><p cid="n199" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="116"><span class="md-line md-end-block" cid="n200" mdtype="line" nodeIndex="752"><span md-inline="plain" nodeIndex="753">通过这个 Sub-protocol，KDC（确切地说是 KDC 中的 Authentication Service）实现对 Client 身份的确认，并颁发给该 Client一个 TGT。</span></span></p><p cid="n201" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="117"><span class="md-line md-end-block" cid="n202" mdtype="line" nodeIndex="754"><span md-inline="em" class="" nodeIndex="755"><em nodeIndex="756">具体过程如下：</em></span></span></p><p cid="n203" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="118"><span class="md-line md-end-block" cid="n204" mdtype="line" nodeIndex="757"><span md-inline="plain" nodeIndex="758">Client 向 KDC 的 Authentication Service 发送 Authentication Service Request（</span><span md-inline="code" spellcheck="false" nodeIndex="759"><code nodeIndex="760">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="761">）, 为了确保 </span><span md-inline="code" spellcheck="false" nodeIndex="762"><code nodeIndex="763">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="764"> 仅限于自己和 KDC 知道，Client 使用自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="765"><code nodeIndex="766">Master Key</code></span><span md-inline="plain" nodeIndex="767"> 对 </span><span md-inline="code" spellcheck="false" nodeIndex="768"><code nodeIndex="769">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="770"> 的主体部分进行加密（KDC 可以通过 Domain 的 Account Database 获得该 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="771"><code nodeIndex="772">Master Key</code></span><span md-inline="plain" nodeIndex="773">）。</span></span></p><p cid="n205" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="119"><span class="md-line md-end-block" cid="n206" mdtype="line" nodeIndex="774"><span md-inline="em" class="" nodeIndex="775"><em nodeIndex="776"><span md-inline="code" spellcheck="false" nodeIndex="777"><code nodeIndex="778">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="779"> 的大体包含以下的内容：</span></em></span></span></p><p cid="n207" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="120"><span class="md-line md-end-block" cid="n208" mdtype="line" nodeIndex="218"><span md-inline="plain" nodeIndex="780">1、Pre-authentication data： 包含用以证明自己身份的信息。说白了，就是证明自己知道自己声称的那个 account 的 Password。一般地，它的内容是一个被 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="781"><code nodeIndex="782">Master key</code></span><span md-inline="plain" nodeIndex="783"> 加密过的 </span><span md-inline="code" spellcheck="false" nodeIndex="784"><code nodeIndex="785">Timestamp</code></span><span md-inline="plain" nodeIndex="786">。</span></span></p><p cid="n209" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="121"><span class="md-line md-end-block" cid="n210" mdtype="line" nodeIndex="787"><span md-inline="plain" nodeIndex="788">2、Client name & realm: 简单地说就是 </span><span md-inline="code" spellcheck="false" nodeIndex="789"><code nodeIndex="790">Domain name\Client</code></span></span></p><p cid="n211" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="122"><span class="md-line md-end-block" cid="n212" mdtype="line" nodeIndex="791"><span md-inline="plain" nodeIndex="792">3、Server Name： 注意这里的 Server Name 并不是 Client 真正要访问的 Server 的名称，而我们也说了 TGT 是和 Server 无关的（Client 只能使用 Ticket，而不是 TGT 去访问 Server）。这里的 Server Name 实际上是 KDC 的 </span><span md-inline="code" spellcheck="false" nodeIndex="793"><code nodeIndex="794">Ticket Granting Service</code></span><span md-inline="plain" nodeIndex="795"> 的 </span><span md-inline="code" spellcheck="false" nodeIndex="796"><code nodeIndex="797">Server Name</code></span><span md-inline="plain" nodeIndex="798">。</span></span></p><p cid="n213" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="123"><span class="md-line md-end-block" cid="n214" mdtype="line" nodeIndex="799"><span md-inline="plain" nodeIndex="800">AS（Authentication Service）通过它接收到的 </span><span md-inline="code" spellcheck="false" nodeIndex="801"><code nodeIndex="802">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="803"> 验证发送方的是否是在 </span><span md-inline="code" spellcheck="false" nodeIndex="804"><code nodeIndex="805">Client name & realm</code></span><span md-inline="plain" nodeIndex="806"> 中声称的那个人，也就是说要验证发送放是否知道 Client 的 Password。</span></span></p><p cid="n215" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="124"><span class="md-line md-end-block" cid="n216" mdtype="line" nodeIndex="807"><span md-inline="plain" nodeIndex="808">所以 AS 只需从 Account Database 中提取 Client 对应的 </span><span md-inline="code" spellcheck="false" nodeIndex="809"><code nodeIndex="810">Master Key</code></span><span md-inline="plain" nodeIndex="811"> 对 Pre-authentication data 进行解密，如果是一个合法的 </span><span md-inline="code" spellcheck="false" nodeIndex="812"><code nodeIndex="813">Timestamp</code></span><span md-inline="plain" nodeIndex="814">，则可以证明发送放提供的是正确无误的密码。</span></span></p><p cid="n217" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="125"><span class="md-line md-end-block" cid="n218" mdtype="line" nodeIndex="815"><span md-inline="plain" nodeIndex="816">验证通过之后，AS 将一份 Authentication Service Response（</span><span md-inline="code" spellcheck="false" nodeIndex="817"><code nodeIndex="818">KRB_AS_REP</code></span><span md-inline="plain" nodeIndex="819">）发送给 Client。</span></span></p><p cid="n219" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="126"><span class="md-line md-end-block" cid="n220" mdtype="line" nodeIndex="820"><span md-inline="code" spellcheck="false" nodeIndex="821"><code nodeIndex="822">KRB_AS_REQ</code></span><span md-inline="plain" nodeIndex="823"> 主要包含两个部分：本 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="824"><code nodeIndex="825">Master Key</code></span><span md-inline="plain" nodeIndex="826"> 加密过的 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="827"><code nodeIndex="828">SKDC-Client</code></span><span md-inline="plain" nodeIndex="829">：Logon Session Key）和被自己（KDC）加密的 TGT。</span></span></p><p cid="n221" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="127"><span class="md-line md-end-block" cid="n222" mdtype="line" nodeIndex="830"><span md-inline="em" class="" nodeIndex="831"><em nodeIndex="832">而 TGT 大体又包含以下的内容：</em></span></span></p><p cid="n223" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="128"><span class="md-line md-end-block" cid="n224" mdtype="line" nodeIndex="833"><span md-inline="plain" nodeIndex="834">1、Session Key: </span><span md-inline="code" spellcheck="false" nodeIndex="835"><code nodeIndex="836">SKDC-Client</code></span><span md-inline="plain" nodeIndex="837">：Logon Session Key</span></span></p><p cid="n225" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="129"><span class="md-line md-end-block" cid="n226" mdtype="line" nodeIndex="838"><span md-inline="plain" nodeIndex="839">2、Client name & realm: 简单地说就是 </span><span md-inline="code" spellcheck="false" nodeIndex="840"><code nodeIndex="841">Domain name\Client</code></span></span></p><p cid="n227" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="130"><span class="md-line md-end-block" cid="n228" mdtype="line" nodeIndex="842"><span md-inline="plain" nodeIndex="843">3、End time: TGT 到期的时间。</span></span></p><p cid="n229" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="131"><span class="md-line md-end-block" cid="n230" mdtype="line" nodeIndex="844"><span md-inline="plain" nodeIndex="845">Client 通过自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="846"><code nodeIndex="847">Master Key</code></span><span md-inline="plain" nodeIndex="848"> 对第一部分解密获得 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="849"><code nodeIndex="850">SKDC-Client</code></span><span md-inline="plain" nodeIndex="851">：Logon Session Key）之后，携带着 TGT 便可以进入下一步：TGS（Ticket Granting Service）Exchange。</span></span></p><blockquote cid="n231" mdtype="blockquote" nodeIndex="132"><p cid="n232" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="133"><span class="md-line md-end-block" cid="n233" mdtype="line" nodeIndex="219"><span md-inline="plain" nodeIndex="852">完成这个阶段的认证需要一个核心的东西就是 Client 的 </span><span md-inline="code" spellcheck="false" nodeIndex="853"><code nodeIndex="854">Master key</code></span><span md-inline="plain" nodeIndex="855">，而这个 </span><span md-inline="code" spellcheck="false" nodeIndex="856"><code nodeIndex="857">Master key</code></span><span md-inline="plain" nodeIndex="858"> 就是我们在域控上抓取到的用户 hash，通常在内网渗透中虽然抓取到了 hash 但是不一定可以破解出明文密码，但是我又想要访问该用户的资源，怎么办呢？</span></span></p><p cid="n234" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="134"><span class="md-line md-end-block" cid="n235" mdtype="line" nodeIndex="859"><span md-inline="plain" nodeIndex="860">这里就用到了一个技术叫 </span><span md-inline="code" spellcheck="false" nodeIndex="861"><code nodeIndex="862">Pass-the-Hash</code></span><span md-inline="plain" nodeIndex="863">，通过 hash 传递的方式来访问该用户的资源。</span></span></p></blockquote><p cid="n236" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="135"><span class="md-line md-end-block" cid="n237" mdtype="line" nodeIndex="864"><span md-inline="strong" class="" nodeIndex="865"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="866">2． TGS（Ticket Granting Service）Exchange</strong></span></span></p><p cid="n238" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="136"><span class="md-line md-end-block" cid="n239" mdtype="line" nodeIndex="867"><span md-inline="plain" nodeIndex="868">TGS（Ticket Granting Service）Exchange 通过 Client 向 KDC 中的 TGS（Ticket Granting Service） 发送 Ticket Granting Service Request（</span><span md-inline="code" spellcheck="false" nodeIndex="869"><code nodeIndex="870">KRB_TGS_REQ</code></span><span md-inline="plain" nodeIndex="871">）开始。</span></span></p><p cid="n240" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="137"><span class="md-line md-end-block" cid="n241" mdtype="line" nodeIndex="872"><span md-inline="em" class="" nodeIndex="873"><em nodeIndex="874">KRB_TGS_REQ 大体包含以下的内容：</em></span></span></p><p cid="n242" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="138"><span class="md-line md-end-block" cid="n243" mdtype="line" nodeIndex="875"><span md-inline="plain" nodeIndex="876">1、TGT：Client 通过 AS Exchange 获得的 Ticket Granting Ticket，TGT 被 KDC 的 Master Key 进行加密。</span></span></p><p cid="n244" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="139"><span class="md-line md-end-block" cid="n245" mdtype="line" nodeIndex="220"><span md-inline="plain" nodeIndex="877">2、Authenticator：用以证明当初 TGT 的拥有者是否就是自己，所以它必须以 TGT 的颁发方和自己的 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="878"><code nodeIndex="879">SKDC-Client</code></span><span md-inline="plain" nodeIndex="880">：Logon Session Key）来进行加密。</span></span></p><p cid="n246" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="140"><span class="md-line md-end-block" cid="n247" mdtype="line" nodeIndex="881"><span md-inline="plain" nodeIndex="882">3、Client name & realm: 简单地说就是 </span><span md-inline="code" spellcheck="false" nodeIndex="883"><code nodeIndex="884">Domain name\Client</code></span><span md-inline="plain" nodeIndex="885">。</span></span></p><p cid="n248" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="141"><span class="md-line md-end-block" cid="n249" mdtype="line" nodeIndex="886"><span md-inline="plain" nodeIndex="887">4、Server name & realm: 简单地说就是 </span><span md-inline="code" spellcheck="false" nodeIndex="888"><code nodeIndex="889">Domain name\Server</code></span><span md-inline="plain" nodeIndex="890">，这回是 Client 试图访问的那个 Server。</span></span></p><p cid="n250" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="142"><span class="md-line md-end-block" cid="n251" mdtype="line" nodeIndex="891"><span md-inline="plain" nodeIndex="892">TGS 收到 </span><span md-inline="code" spellcheck="false" nodeIndex="893"><code nodeIndex="894">KRB_TGS_REQ</code></span><span md-inline="plain" nodeIndex="895">, 在发给 Client 真正的 Ticket 之前，先得确定 Client 提供的那个 TGT 是否是 AS 颁发给它的。于是它不得不通过 Client 提供的 Authenticator 来证明。</span></span></p><p cid="n252" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="143"><span class="md-line md-end-block" cid="n253" mdtype="line" nodeIndex="896"><span md-inline="plain" nodeIndex="897">但是 Authentication 是通过 Logon Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="898"><code nodeIndex="899">SKDC-Client</code></span><span md-inline="plain" nodeIndex="900">） 进行加密的，而自己并没有保存这个 Session Key。</span></span></p><p cid="n254" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="144"><span class="md-line md-end-block" cid="n255" mdtype="line" nodeIndex="901"><span md-inline="plain" nodeIndex="902">所以 TGS 先得通过自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="903"><code nodeIndex="904">Master Key</code></span><span md-inline="plain" nodeIndex="905"> 对 Client 提供的 TGT 进行解密，从而获得这个 Logon Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="906"><code nodeIndex="907">SKDC-Client</code></span><span md-inline="plain" nodeIndex="908">），再通过这个 Logon Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="909"><code nodeIndex="910">SKDC-Client</code></span><span md-inline="plain" nodeIndex="911">） 解密 Authenticator 进行验证。</span></span></p><p cid="n256" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="145"><span class="md-line md-end-block" cid="n257" mdtype="line" nodeIndex="912"><span md-inline="plain" nodeIndex="913">验证通过向对方发送 Ticket Granting Service Response（</span><span md-inline="code" spellcheck="false" nodeIndex="914"><code nodeIndex="915">KRB_TGS_REP</code></span><span md-inline="plain" nodeIndex="916">）。</span></span></p><p cid="n258" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="146"><span class="md-line md-end-block" cid="n259" mdtype="line" nodeIndex="917"><span md-inline="em" class="" nodeIndex="918"><em nodeIndex="919"><span md-inline="plain" nodeIndex="920">这个 </span><span md-inline="code" spellcheck="false" nodeIndex="921"><code nodeIndex="922">KRB_TGS_REP</code></span><span md-inline="plain" nodeIndex="923"> 有两部分组成：</span></em></span></span></p><p cid="n260" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="147"><span class="md-line md-end-block" cid="n261" mdtype="line" nodeIndex="924"><span md-inline="plain" nodeIndex="925">1、使用 Logon Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="926"><code nodeIndex="927">SKDC-Client</code></span><span md-inline="plain" nodeIndex="928">） 加密后用于 Client 和 Server 的 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="929"><code nodeIndex="930">SServer-Client</code></span><span md-inline="plain" nodeIndex="931">） </span></span></p><p cid="n262" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="148"><span class="md-line md-end-block" cid="n263" mdtype="line" nodeIndex="932"><span md-inline="plain" nodeIndex="933">2、使用 Server 的 </span><span md-inline="code" spellcheck="false" nodeIndex="934"><code nodeIndex="935">Master Key</code></span><span md-inline="plain" nodeIndex="936"> 进行加密的 Ticket。</span></span></p><p cid="n264" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="149"><span class="md-line md-end-block" cid="n265" mdtype="line" nodeIndex="937"><span md-inline="em" class="" nodeIndex="938"><em nodeIndex="939">该 Ticket 大体包含以下一些内容：</em></span></span></p><p cid="n266" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="150"><span class="md-line md-end-block" cid="n267" mdtype="line" nodeIndex="940"><span md-inline="plain" nodeIndex="941">1、Session Key：</span><span md-inline="code" spellcheck="false" nodeIndex="942"><code nodeIndex="943">SServer-Client</code></span><span md-inline="plain" nodeIndex="944">。</span></span></p><p cid="n268" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="151"><span class="md-line md-end-block" cid="n269" mdtype="line" nodeIndex="945"><span md-inline="plain" nodeIndex="946">2、Client name & realm: 简单地说就是 </span><span md-inline="code" spellcheck="false" nodeIndex="947"><code nodeIndex="948">Domain name\Client</code></span><span md-inline="plain" nodeIndex="949">。</span></span></p><p cid="n270" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="152"><span class="md-line md-end-block" cid="n271" mdtype="line" nodeIndex="950"><span md-inline="plain" nodeIndex="951">3、End time: Ticket 的到期时间。</span></span></p><p cid="n272" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="153"><span class="md-line md-end-block" cid="n273" mdtype="line" nodeIndex="952"><span md-inline="plain" nodeIndex="953">Client 收到 </span><span md-inline="code" spellcheck="false" nodeIndex="954"><code nodeIndex="955">KRB_TGS_REP</code></span><span md-inline="plain" nodeIndex="956">，使用 Logon Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="957"><code nodeIndex="958">SKDC-Client</code></span><span md-inline="plain" nodeIndex="959">） 解密第一部分后获得 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="960"><code nodeIndex="961">SServer-Client</code></span><span md-inline="plain" nodeIndex="962">）。</span></span></p><p cid="n274" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="154"><span class="md-line md-end-block" cid="n275" mdtype="line" nodeIndex="963"><span md-inline="plain" nodeIndex="964">有了 Session Key 和 Ticket，Client 就可以和 Server 进行交互，而无须再通过 KDC 作中间人了。所以我们说 Kerberos 是一种高效的认证方式，它可以直接通过 Client 和 Server 双方来完成，不像 Windows NT 4 下的 NTLM 认证方式，每次认证都要通过一个双方信任的第 3 方来完成。</span></span></p><p cid="n276" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="155"><span class="md-line md-end-block" cid="n277" mdtype="line" nodeIndex="965"><span md-inline="plain" nodeIndex="966">我们现在来看看 Client 如果使用 Ticket 和 Server 怎样进行交互的，这个阶段通过我们的第 3 个 Sub-protocol 来完成：</span><span md-inline="code" spellcheck="false" nodeIndex="967"><code nodeIndex="968">CS（Client/Server ）Exchange</code></span><span md-inline="plain" nodeIndex="969">。</span></span></p><blockquote cid="n278" mdtype="blockquote" nodeIndex="156"><p cid="n279" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="157"><span class="md-line md-end-block" cid="n280" mdtype="line" nodeIndex="221"><span md-inline="plain" nodeIndex="970">在这个阶段，用到一个比较重要的东西，就是域控服务器的 </span><span md-inline="code" spellcheck="false" nodeIndex="971"><code nodeIndex="972">Master key</code></span><span md-inline="plain" nodeIndex="973"> 也就是账户 </span><span md-inline="code" spellcheck="false" nodeIndex="974"><code nodeIndex="975">krbtgt</code></span><span md-inline="plain" nodeIndex="976"> 的 hash 值，在黑客攻陷域控服务器之后，能够抓取到 </span><span md-inline="code" spellcheck="false" nodeIndex="977"><code nodeIndex="978">krbtgt</code></span><span md-inline="plain" nodeIndex="979"> 的 hash 值，对于 </span><span md-inline="code" spellcheck="false" nodeIndex="980"><code nodeIndex="981">krbtgt</code></span><span md-inline="plain" nodeIndex="982"> 的密码一般不会修改，所以只要这个账号的密码不修改，我们就可以随时绕过第一步的认证为任意用户伪造任意的 TGT，然后访问任意的服务器资源，这种技术叫做 </span><span md-inline="code" spellcheck="false" nodeIndex="983"><code nodeIndex="984">golden ticket</code></span><span md-inline="plain" nodeIndex="985">(黄金票据)，作为长期控制域环境的技术。</span></span></p></blockquote><p cid="n281" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="158"><span class="md-line md-end-block" cid="n282" mdtype="line" nodeIndex="986"><span md-inline="strong" class="" nodeIndex="987"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="988">3． CS（Client/Server ）Exchange</strong></span></span></p><p cid="n283" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="159"><span class="md-line md-end-block" cid="n284" mdtype="line" nodeIndex="989"><span md-inline="plain" nodeIndex="990">这个已经在本文的第二节中已经介绍过，对于重复发内容就不再累赘了。</span></span></p><p cid="n285" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="160"><span class="md-line md-end-block" cid="n286" mdtype="line" nodeIndex="991"><span md-inline="plain" nodeIndex="992">Client 通过 TGS Exchange 获得 Client 和 Server 的 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="993"><code nodeIndex="994">SServer-Client</code></span><span md-inline="plain" nodeIndex="995">），随后创建用于证明自己就是 Ticket 的真正所有者的 Authenticator，并使用 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="996"><code nodeIndex="997">SServer-Client</code></span><span md-inline="plain" nodeIndex="998">）进行加密。</span></span></p><p cid="n287" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="161"><span class="md-line md-end-block" cid="n288" mdtype="line" nodeIndex="999"><span md-inline="plain" nodeIndex="1000">最后将这个被加密过的 Authenticator 和 Ticket 作为 Application Service Request（</span><span md-inline="code" spellcheck="false" nodeIndex="1001"><code nodeIndex="1002">KRB_AP_REQ</code></span><span md-inline="plain" nodeIndex="1003">）发送给 Server。</span></span></p><p cid="n289" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="162"><span class="md-line md-end-block" cid="n290" mdtype="line" nodeIndex="1004"><span md-inline="plain" nodeIndex="1005">除了上述两项内容之外，</span><span md-inline="code" spellcheck="false" nodeIndex="1006"><code nodeIndex="1007">KRB_AP_REQ</code></span><span md-inline="plain" nodeIndex="1008"> 还包含一个 Flag 用于表示 Client 是否需要进行双向验证（Mutual Authentication）。</span></span></p><p cid="n291" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="163"><span class="md-line md-end-block" cid="n292" mdtype="line" nodeIndex="1009"><span md-inline="plain" nodeIndex="1010">Server 接收到 </span><span md-inline="code" spellcheck="false" nodeIndex="1011"><code nodeIndex="1012">KRB_AP_REQ</code></span><span md-inline="plain" nodeIndex="1013"> 之后，通过自己的 </span><span md-inline="code" spellcheck="false" nodeIndex="1014"><code nodeIndex="1015">Master Key</code></span><span md-inline="plain" nodeIndex="1016"> 解密 Ticket，从而获得 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="1017"><code nodeIndex="1018">SServer-Client</code></span><span md-inline="plain" nodeIndex="1019">）。</span></span></p><p cid="n293" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="164"><span class="md-line md-end-block" cid="n294" mdtype="line" nodeIndex="222"><span md-inline="plain" nodeIndex="1020">通过 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="1021"><code nodeIndex="1022">SServer-Client</code></span><span md-inline="plain" nodeIndex="1023">）解密 Authenticator，进而验证对方的身份。验证成功，让 Client 访问需要访问的资源，否则直接拒绝对方的请求。</span></span></p><p cid="n295" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="165"><span class="md-line md-end-block" cid="n296" mdtype="line" nodeIndex="1024"><span md-inline="plain" nodeIndex="1025">对于需要进行双向验证，Server 从 Authenticator 提取 </span><span md-inline="code" spellcheck="false" nodeIndex="1026"><code nodeIndex="1027">Timestamp</code></span><span md-inline="plain" nodeIndex="1028">，使用 Session Key（</span><span md-inline="code" spellcheck="false" nodeIndex="1029"><code nodeIndex="1030">SServer-Client</code></span><span md-inline="plain" nodeIndex="1031">）进行加密，并将其发送给 Client 用于 Client 验证 Server 的身份。</span></span></p><h3 cid="n297" mdtype="heading" class="md-end-block md-heading" nodeIndex="166"><span md-inline="plain" nodeIndex="1032">六、Kerberos 的优点</span></h3><p cid="n298" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="167"><span class="md-line md-end-block" cid="n299" mdtype="line" nodeIndex="1033"><span md-inline="plain" nodeIndex="1034">分析整个 Kerberos 的认证过程之后，我们来总结一下 Kerberos 都有哪些优点：</span></span></p><p cid="n300" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="168"><span class="md-line md-end-block" cid="n301" mdtype="line" nodeIndex="1035"><span md-inline="strong" class="" nodeIndex="1036"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="1037">1．较高的 Performance</strong></span></span></p><p cid="n302" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="169"><span class="md-line md-end-block" cid="n303" mdtype="line" nodeIndex="1038"><span md-inline="plain" nodeIndex="1039">虽然我们一再地说 Kerberos 是一个涉及到 3 方的认证过程：</span><span md-inline="code" spellcheck="false" nodeIndex="1040"><code nodeIndex="1041">Client</code></span><span md-inline="plain" nodeIndex="1042">、</span><span md-inline="code" spellcheck="false" nodeIndex="1043"><code nodeIndex="1044">Server</code></span><span md-inline="plain" nodeIndex="1045">、</span><span md-inline="code" spellcheck="false" nodeIndex="1046"><code nodeIndex="1047">KDC</code></span><span md-inline="plain" nodeIndex="1048">。但是一旦 </span><span md-inline="code" spellcheck="false" nodeIndex="1049"><code nodeIndex="1050">Client</code></span><span md-inline="plain" nodeIndex="1051"> 获得用过访问某个 </span><span md-inline="code" spellcheck="false" nodeIndex="1052"><code nodeIndex="1053">Server</code></span><span md-inline="plain" nodeIndex="1054"> 的 </span><span md-inline="code" spellcheck="false" nodeIndex="1055"><code nodeIndex="1056">Ticket</code></span><span md-inline="plain" nodeIndex="1057">，该 </span><span md-inline="code" spellcheck="false" nodeIndex="1058"><code nodeIndex="1059">Server</code></span><span md-inline="plain" nodeIndex="1060"> 就能根据这个 </span><span md-inline="code" spellcheck="false" nodeIndex="1061"><code nodeIndex="1062">Ticket</code></span><span md-inline="plain" nodeIndex="1063"> 实现对 </span><span md-inline="code" spellcheck="false" nodeIndex="1064"><code nodeIndex="1065">Client</code></span><span md-inline="plain" nodeIndex="1066"> 的验证，而无须</span><span md-inline="code" spellcheck="false" nodeIndex="1067"><code nodeIndex="1068">KDC</code></span><span md-inline="plain" nodeIndex="1069"> 的再次参与。和传统的基于 Windows NT 4.0 的每个完全依赖 Trusted Third Party 的 NTLM 比较，具有较大的性能提升。</span></span></p><p cid="n304" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="170"><span class="md-line md-end-block" cid="n305" mdtype="line" nodeIndex="1070"><span md-inline="strong" class="" nodeIndex="1071"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="1072">2．实现了双向验证（Mutual Authentication）</strong></span></span></p><p cid="n306" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="171"><span class="md-line md-end-block" cid="n307" mdtype="line" nodeIndex="1073"><span md-inline="plain" nodeIndex="1074">传统的 NTLM 认证基于这样一个前提：Client 访问的远程 Service 是可信的、无需对其进行验证，所以 NTLM 不曾提供双向验证的功能。这显然有点理想主义，为此 Kerberos 弥补了这个不足：Client 在访问 Server 的资源之前，可以要求对 Server 的身份执行认证。</span></span></p><p cid="n308" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="172"><span class="md-line md-end-block" cid="n309" mdtype="line" nodeIndex="1075"><span md-inline="strong" class="" nodeIndex="1076"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="1077">3．对 Delegation 的支持</strong></span></span></p><p cid="n310" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="173"><span class="md-line md-end-block" cid="n311" mdtype="line" nodeIndex="1078"><span md-inline="plain" nodeIndex="1079">Impersonation 和 Delegation 是一个分布式环境中两个重要的功能。Impersonation 允许 Server 在本地使用 Logon 的 Account 执行某些操作，Delegation 需用 Server 将 logon 的 Account 带入到另过一个 Context 执行相应的操作。NTLM 仅对 Impersonation 提供支持，而 Kerberos 通过一种双向的、可传递的（Mutual 、Transitive）信任模式实现了对 Delegation 的支持。</span></span></p><p cid="n312" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="174"><span class="md-line md-end-block" cid="n313" mdtype="line" nodeIndex="1080"><span md-inline="strong" class="" nodeIndex="1081"><strong class=" _RIL_KEEPER_CLASS_" nodeIndex="1082">4．互操作性（Interoperability）</strong></span></span></p><p cid="n314" mdtype="paragraph" class=" _RIL_KEEPER_CLASS_" nodeIndex="175"><span class="md-line md-end-block" cid="n315" mdtype="line" nodeIndex="1083"><span md-inline="plain" class="" nodeIndex="1084">Kerberos 最初由 MIT 首创，现在已经成为一行被广泛接受的标准。所以对于不同的平台可以进行广泛的互操作。</span></span></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="176"><div id="RIL_IMG_7" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/7"/></div></p>
                </div>
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" nodeIndex="177"></div>

                
                                <p id="js_preview_reward_wording" class="tips_global reward_tips _RIL_KEEPER_CLASS_" nodeIndex="179"></p><p class=" _RIL_KEEPER_CLASS_" nodeIndex="180">
                        <a class="reward_access" id="js_preview_reward_link" href=""><span class="icon-reward"></span>赞赏</a>

                    </p>
                <p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="182">长按二维码向我转账</p><p id="js_preview_reward_ios_wording" class="reward_tips _RIL_KEEPER_CLASS_" nodeIndex="183"></p><p class="tips_global _RIL_KEEPER_CLASS_" nodeIndex="184">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p><div id="RIL_IMG_8" class="RIL_IMG"><img src="/media/posts_images/2018-03-25-2128064650/8"/></div>
                            </div>
                        
                        


                    </div>